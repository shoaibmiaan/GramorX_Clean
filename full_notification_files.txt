============================================================
FILE #1
PATH: hooks/useLiveSession.ts
============================================================
import { useCallback, useEffect, useRef, useState } from 'react';

type LiveSessionConnectionState = 'idle' | 'connecting' | 'connected' | 'disconnecting';

type UseLiveSessionOptions = {
  sessionId: string;
  token: string | null;
  autoConnect?: boolean;
  onConnectionChange?: (state: LiveSessionConnectionState) => void;
};

type UseLiveSessionResult = {
  connectionState: LiveSessionConnectionState;
  connected: boolean;
  error: string | null;
  connect: () => Promise<void>;
  disconnect: () => Promise<void>;
  startRecording: () => Promise<void>;
  stopRecording: () => Promise<void>;
  isRecording: boolean;
  recordingDurationSeconds: number;
};

function wait(ms: number) {
  return new Promise<void>((resolve) => {
    setTimeout(resolve, ms);
  });
}

export function useLiveSession({ sessionId, token, autoConnect = false, onConnectionChange }: UseLiveSessionOptions): UseLiveSessionResult {
  const [connectionState, setConnectionState] = useState<LiveSessionConnectionState>('idle');
  const [error, setError] = useState<string | null>(null);
  const [isRecording, setIsRecording] = useState(false);
  const [recordingTick, setRecordingTick] = useState(0);
  const [recordingDurationSeconds, setRecordingDurationSeconds] = useState(0);
  const recordingStartedAt = useRef<number | null>(null);
  const tokenRef = useRef<string | null>(token);

  useEffect(() => {
    tokenRef.current = token;
  }, [token]);

  useEffect(() => {
    setConnectionState('idle');
    setIsRecording(false);
    recordingStartedAt.current = null;
    setRecordingTick(0);
    setRecordingDurationSeconds(0);
  }, [sessionId]);

  const notify = useCallback(
    (next: LiveSessionConnectionState) => {
      onConnectionChange?.(next);
    },
    [onConnectionChange],
  );

  const connect = useCallback(async () => {
    if (connectionState === 'connected' || connectionState === 'connecting') {
      return;
    }

    setError(null);

    if (!tokenRef.current) {
      setError('Missing session token');
      return;
    }

    setConnectionState('connecting');
    notify('connecting');

    try {
      await wait(50);
      setConnectionState('connected');
      notify('connected');
    } catch (err) {
      setError((err as Error).message ?? 'Failed to connect');
      setConnectionState('idle');
      notify('idle');
    }
  }, [connectionState, notify]);

  const disconnect = useCallback(async () => {
    if (connectionState === 'idle') return;

    setConnectionState('disconnecting');
    notify('disconnecting');

    try {
      await wait(25);
    } finally {
      setConnectionState('idle');
      notify('idle');
      setIsRecording(false);
      recordingStartedAt.current = null;
      setRecordingTick(0);
      setRecordingDurationSeconds(0);
    }
  }, [connectionState, notify]);

  const startRecording = useCallback(async () => {
    if (connectionState !== 'connected') {
      setError('Cannot start recording while disconnected');
      return;
    }

    if (isRecording) return;

    setIsRecording(true);
    recordingStartedAt.current = Date.now();
    setRecordingTick(0);
    setRecordingDurationSeconds(0);
  }, [connectionState, isRecording]);

  const stopRecording = useCallback(async () => {
    if (!isRecording) return;

    setIsRecording(false);
    recordingStartedAt.current = null;
    setRecordingTick(0);
    setRecordingDurationSeconds(0);
  }, [isRecording]);

  useEffect(() => {
    if (!autoConnect) return;
    if (!tokenRef.current) return;
    if (connectionState !== 'idle') return;

    void connect();
  }, [autoConnect, connect, connectionState]);

  useEffect(() => {
    if (!isRecording) return;

    const interval = window.setInterval(() => {
      setRecordingTick((value) => value + 1);
    }, 1000);

    return () => {
      window.clearInterval(interval);
    };
  }, [isRecording]);

  useEffect(() => {
    if (!isRecording || !recordingStartedAt.current) return;
    const elapsed = (Date.now() - recordingStartedAt.current) / 1000;
    setRecordingDurationSeconds(Math.max(0, Math.floor(elapsed)));
  }, [recordingTick, isRecording]);

  return {
    connectionState,
    connected: connectionState === 'connected',
    error,
    connect,
    disconnect,
    startRecording,
    stopRecording,
    isRecording,
    recordingDurationSeconds,
  };
}





============================================================
FILE #2
PATH: mobile/android/twa/src/main/AndroidManifest.xml
============================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    package="com.gramorx.twa">

    <uses-permission
        android:name="android.permission.POST_NOTIFICATIONS"
        tools:targetApi="tiramisu" />

    <queries>
        <intent>
            <action android:name="android.intent.action.VIEW" />
            <category android:name="android.intent.category.BROWSABLE" />
            <data android:scheme="https" />
        </intent>
    </queries>

    <application
        android:allowBackup="false"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:manageSpaceActivity="com.google.androidbrowserhelper.trusted.ManageDataLauncherActivity"
        android:name="androidx.multidex.MultiDexApplication"
        android:networkSecurityConfig="@xml/network_security_config"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:usesCleartextTraffic="false"
        android:theme="@style/Theme.TrustedWebActivity">

        <meta-data
            android:name="asset_statements"
            android:value="@string/asset_statements" />

        <activity
            android:name="com.google.androidbrowserhelper.trusted.ManageDataLauncherActivity"
            android:exported="false">
            <meta-data
                android:name="android.support.customtabs.trusted.MANAGE_SPACE_URL"
                android:value="@string/production_url" />
        </activity>

        <activity
            android:name="com.google.androidbrowserhelper.trusted.LauncherActivity"
            android:exported="true"
            android:launchMode="singleTask"
            android:screenOrientation="unspecified">
            <meta-data
                android:name="android.support.customtabs.trusted.DEFAULT_URL"
                android:value="@string/production_url" />
            <meta-data
                android:name="android.support.customtabs.trusted.STATUS_BAR_COLOR"
                android:resource="@color/twa_status_bar" />
            <meta-data
                android:name="android.support.customtabs.trusted.NAVIGATION_BAR_COLOR"
                android:resource="@color/twa_navigation_bar" />
            <meta-data
                android:name="android.support.customtabs.trusted.FILE_PROVIDER_AUTHORITY"
                android:value="@string/file_provider_authority" />

            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>

            <intent-filter android:autoVerify="true">
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.BROWSABLE" />
                <category android:name="android.intent.category.DEFAULT" />
                <data
                    android:host="gramorx.com"
                    android:scheme="https" />
            </intent-filter>
        </activity>

        <activity android:name="com.google.androidbrowserhelper.trusted.FocusActivity" />

        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="@string/file_provider_authority"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/filepaths" />
        </provider>

        <service
            android:name="com.google.androidbrowserhelper.trusted.DelegationService"
            android:exported="true"
            tools:ignore="ExportedService">
            <intent-filter>
                <action android:name="android.support.customtabs.trusted.TRUSTED_WEB_ACTIVITY_SERVICE" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>

            <meta-data
                android:name="android.support.customtabs.trusted.DELEGATES"
                android:resource="@array/twa_delegated_scopes" />
        </service>
    </application>
</manifest>





============================================================
FILE #3
PATH: pages/teacher/Welcome.tsx
============================================================
'use client';

import React, { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { Card } from '@/components/design-system/Card';
import { Button } from '@/components/design-system/Button';
import { Input } from '@/components/design-system/Input';
import { Textarea } from '@/components/design-system/Textarea';
import { Badge } from '@/components/design-system/Badge';
import { ProgressBar } from '@/components/design-system/ProgressBar';
import { Section } from '@/components/design-system/Section';
import { Tabs } from '@/components/design-system/Tabs';
import { Alert } from '@/components/design-system/Alert';
import { supabase } from '@/lib/supabaseClient';

export default function TeacherWelcome() {
  const router = useRouter();
  const [user, setUser] = useState<{ id: string; fullName: string; email: string } | null>(null);
  const [formData, setFormData] = useState({
    fullName: '',
    subjectExpertise: '',
    teachingExperience: '',
    linkedIn: '',
  });
  const [loading, setLoading] = useState(true);
  const [submitting, setSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [progress, setProgress] = useState(40); // Example: static for now, update based on API if needed
  const [status, setStatus] = useState<'pending' | 'review' | 'approved'>('pending'); // Example: static for now

  useEffect(() => {
    let mounted = true;

    const fetchUser = async () => {
      try {
        const { data: { user }, error } = await supabase.auth.getUser();
        if (error) throw error;
        if (mounted) {
          if (!user) {
            router.push('/login?next=/teacher/welcome');
            return;
          }
          setUser({
            id: user.id,
            fullName: user.user_metadata?.full_name || '',
            email: user.email || '',
          });
          setFormData((prev) => ({
            ...prev,
            fullName: user.user_metadata?.full_name || '',
            linkedIn: user.user_metadata?.linkedIn || '',
          }));
        }
      } catch (err) {
        console.error('Failed to fetch user:', err);
        if (mounted) setError('Failed to load user data. Please try again.');
      } finally {
        if (mounted) setLoading(false);
      }
    };

    fetchUser();

    return () => {
      mounted = false;
    };
  }, [router]);

  const handleInputChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setSubmitting(true);
    setError(null);

    try {
      const { data: { session }, error: sessionError } = await supabase.auth.getSession();
      if (sessionError || !session) {
        console.error('No session for form submission:', sessionError);
        setError('Please sign in to submit the form.');
        router.push('/login?next=/teacher/welcome');
        return;
      }

      const res = await fetch('/api/teacher/onboarding', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${session.access_token}`,
        },
        body: JSON.stringify({
          userId: user?.id,
          fullName: formData.fullName,
          subjectExpertise: formData.subjectExpertise,
          teachingExperience: formData.teachingExperience,
          linkedIn: formData.linkedIn,
        }),
      });

      if (!res.ok) {
        const { error } = await res.json();
        throw new Error(error || 'Failed to submit onboarding form');
      }

      // Update progress and status (example: adjust based on API response)
      setProgress(80);
      setStatus('review');
      router.push('/teacher/dashboard'); // Redirect to dashboard after submission
    } catch (err) {
      console.error('Form submission error:', err);
      setError(err.message || 'Failed to submit form. Please try again.');
    } finally {
      setSubmitting(false);
    }
  };

  if (loading) return <div className="p-6 text-muted-foreground">Loading...</div>;
  if (error) return <Alert variant="warning" className="m-6">{error}</Alert>;

  return (
    <div className="container mx-auto max-w-4xl py-10">
      <Section>
        <h1 className="text-3xl font-bold text-foreground">ðŸ‘‹ Welcome, Teacher!</h1>
        <p className="mt-2 text-muted-foreground">
          Weâ€™re excited to have you join GramorX as an educator. To get started, please
          complete your onboarding so we can approve your profile and unlock your dashboard.
        </p>
      </Section>

      <div className="mt-8 grid gap-8 md:grid-cols-2">
        {/* Left: Profile Setup Form */}
        <Card className="p-6">
          <h2 className="text-xl font-semibold text-foreground">Onboarding Form</h2>
          <p className="mb-4 text-sm text-muted-foreground">
            Provide accurate details to help us verify your teaching profile.
          </p>
          <form className="grid gap-4" onSubmit={handleSubmit}>
            <Input
              label="Full Name"
              name="fullName"
              placeholder="Enter your full name"
              value={formData.fullName}
              onChange={handleInputChange}
              required
            />
            <Input
              label="Subject Expertise"
              name="subjectExpertise"
              placeholder="e.g., IELTS Writing"
              value={formData.subjectExpertise}
              onChange={handleInputChange}
              required
            />
            <Textarea
              label="Teaching Experience"
              name="teachingExperience"
              placeholder="Describe your years of teaching and certifications"
              value={formData.teachingExperience}
              onChange={handleInputChange}
              rows={4}
              required
            />
            <Input
              label="LinkedIn / Portfolio (optional)"
              name="linkedIn"
              placeholder="https://..."
              value={formData.linkedIn}
              onChange={handleInputChange}
            />
            <Button
              type="submit"
              tone="primary"
              className="w-full mt-2"
              disabled={submitting}
              loading={submitting}
              loadingText="Submitting..."
            >
              Submit for Approval
            </Button>
          </form>
        </Card>

        {/* Right: Progress & Guidance */}
        <div className="flex flex-col gap-6">
          <Card className="p-6">
            <h2 className="text-xl font-semibold text-foreground">Approval Progress</h2>
            <p className="text-sm text-muted-foreground mb-3">
              Once you submit your details, our admin team will review and notify you.
            </p>
            <ProgressBar value={progress} tone="info" />
            <ul className="mt-4 space-y-2 text-sm">
              <li>
                <Badge tone={status === 'pending' ? 'warning' : 'success'}>
                  {status === 'pending' ? 'Pending' : 'Completed'}
                </Badge>{' '}
                Profile Information
              </li>
              <li>
                <Badge tone={status === 'review' ? 'warning' : 'default'}>
                  {status === 'review' ? 'In Review' : 'Waiting'}
                </Badge>{' '}
                Admin Review
              </li>
              <li>
                <Badge tone={status === 'approved' ? 'success' : 'default'}>
                  {status === 'approved' ? 'Unlocked' : 'Locked'}
                </Badge>{' '}
                Dashboard Access
              </li>
            </ul>
          </Card>

          <Card className="p-6">
            <h2 className="text-xl font-semibold text-foreground">Helpful Links</h2>
            <Tabs
              items={[
                {
                  label: 'Guidelines',
                  content: (
                    <ul className="list-disc ml-5 text-sm space-y-1 text-muted-foreground">
                      <li>Complete all required fields honestly.</li>
                      <li>Attach certificates or references where possible.</li>
                      <li>Response time: typically 24â€“48 hours.</li>
                    </ul>
                  ),
                },
                {
                  label: 'FAQ',
                  content: (
                    <p className="text-sm text-muted-foreground">
                      Need help? Visit the{' '}
                      <a href="/support" className="text-accent">
                        Support Center
                      </a>
                      .
                    </p>
                  ),
                },
              ]}
            />
          </Card>
        </div>
      </div>
    </div>
  );
}




============================================================
FILE #4
PATH: pages/teacher/onboarding.tsx
============================================================
'use client';

import * as React from 'react';
import Link from 'next/link';
import { useRouter } from 'next/router';
import { z } from 'zod';
import { Container } from '@/components/design-system/Container';
import { Card } from '@/components/design-system/Card';
import { Input } from '@/components/design-system/Input';
import { Textarea } from '@/components/design-system/Textarea';
import { Select } from '@/components/design-system/Select';
import { Checkbox } from '@/components/design-system/Checkbox';
import { Button } from '@/components/design-system/Button';
import { Alert } from '@/components/design-system/Alert';
import { Badge } from '@/components/design-system/Badge';
import OnboardingProgress from '@/components/teacher/OnboardingProgress';
import DocumentUploadStub from '@/components/teacher/DocumentUploadStub';

const FormSchema = z.object({
  fullName: z.string().min(3),
  email: z.string().email(),
  phone: z.string().min(8),
  country: z.string().min(2),
  city: z.string().min(2),
  subjects: z.array(z.string()).min(1),
  experienceYears: z.number().min(0).max(50),
  bio: z.string().min(50),
  languages: z.array(z.string()).min(1),
  availability: z.array(z.string()).min(1), // slots or days
  hourlyRate: z.number().min(0),
  linkedin: z.string().url().optional().or(z.literal('')),
  portfolio: z.string().url().optional().or(z.literal('')),
  agree: z.boolean().refine((v) => v, 'Consent required'),
  // documents handled by stub (frontend-only)
});

export default function TeacherOnboarding() {
  const router = useRouter();
  const [err, setErr] = React.useState<string | null>(null);
  const [ok, setOk] = React.useState(false);
  const [loading, setLoading] = React.useState(false);

  // Local state (frontend-only)
  const [subjects, setSubjects] = React.useState<string[]>([]);
  const [languages, setLanguages] = React.useState<string[]>([]);
  const [availability, setAvailability] = React.useState<string[]>([]);
  const [docCount, setDocCount] = React.useState(0);

  const handleSubmit: React.FormEventHandler<HTMLFormElement> = async (e) => {
    e.preventDefault();
    setErr(null);
    setLoading(true);

    const form = new FormData(e.currentTarget);
    const payload = {
      fullName: String(form.get('fullName') ?? ''),
      email: String(form.get('email') ?? ''),
      phone: String(form.get('phone') ?? ''),
      country: String(form.get('country') ?? ''),
      city: String(form.get('city') ?? ''),
      subjects,
      experienceYears: Number(form.get('experienceYears') ?? '0'),
      bio: String(form.get('bio') ?? ''),
      languages,
      availability,
      hourlyRate: Number(form.get('hourlyRate') ?? '0'),
      linkedin: String(form.get('linkedin') ?? ''),
      portfolio: String(form.get('portfolio') ?? ''),
      agree: Boolean(form.get('agree')),
    };

    const parsed = FormSchema.safeParse(payload);
    if (!parsed.success) {
      setErr(parsed.error.errors[0]?.message ?? 'Please fix the highlighted fields.');
      setLoading(false);
      return;
    }

    // FE-only: store locally to simulate submission + progress
    try {
      const percent = Math.min(100, 30 + subjects.length * 10 + (docCount > 0 ? 20 : 0) + (payload.bio.length > 80 ? 20 : 0));
      localStorage.setItem('teacher.onboarding.data', JSON.stringify({ ...payload, docCount }));
      localStorage.setItem('teacher.onboarding.percent', String(percent));
      setOk(true);
      setLoading(false);
      setTimeout(() => router.push('/teacher/pending'), 600);
    } catch (e) {
      setErr('Could not save locally. Please try again.');
      setLoading(false);
    }
  };

  return (
    <Container className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold">Teacher Onboarding</h1>
          <p className="text-mutedText">Complete the form below. Weâ€™ll notify you once approved.</p>
        </div>
        <Badge variant="secondary">Frontend-only</Badge>
      </div>

      {ok && <Alert variant="success">Submitted! Redirecting to Pendingâ€¦</Alert>}
      {err && <Alert variant="destructive">{err}</Alert>}

      <OnboardingProgress percentKey="teacher.onboarding.percent" />

      <form onSubmit={handleSubmit} className="grid gap-6">
        <Card className="grid md:grid-cols-2 gap-4">
          <div className="space-y-3">
            <label className="text-sm font-medium">Full Name</label>
            <Input name="fullName" placeholder="Your full name" />
            <label className="text-sm font-medium">Email</label>
            <Input type="email" name="email" placeholder="you@gramorx.com" />
            <label className="text-sm font-medium">Phone</label>
            <Input name="phone" placeholder="+92 3XX XXXXXXX" />
          </div>
          <div className="space-y-3">
            <label className="text-sm font-medium">Country</label>
            <Input name="country" placeholder="Pakistan" />
            <label className="text-sm font-medium">City</label>
            <Input name="city" placeholder="Lahore" />
            <label className="text-sm font-medium">Years of Experience</label>
            <Input type="number" min={0} max={50} name="experienceYears" placeholder="3" />
          </div>
        </Card>

        <Card className="grid md:grid-cols-2 gap-4">
          <div className="space-y-3">
            <label className="text-sm font-medium">Subjects</label>
            <Select
              multiple
              value={subjects}
              onChange={(v) => setSubjects(v as string[])}
              options={[
                { label: 'IELTS Speaking', value: 'speaking' },
                { label: 'IELTS Writing', value: 'writing' },
                { label: 'IELTS Reading', value: 'reading' },
                { label: 'IELTS Listening', value: 'listening' },
              ]}
              placeholder="Select one or more"
            />
            <label className="text-sm font-medium">Languages</label>
            <Select
              multiple
              value={languages}
              onChange={(v) => setLanguages(v as string[])}
              options={[
                { label: 'English', value: 'en' },
                { label: 'Urdu', value: 'ur' },
                { label: 'Punjabi', value: 'pa' },
                { label: 'Arabic', value: 'ar' },
              ]}
              placeholder="Select languages you can teach in"
            />
            <label className="text-sm font-medium">Availability</label>
            <Select
              multiple
              value={availability}
              onChange={(v) => setAvailability(v as string[])}
              options={[
                { label: 'Weekdays (Evening)', value: 'weekdays_eve' },
                { label: 'Weekdays (Morning)', value: 'weekdays_morn' },
                { label: 'Weekends', value: 'weekends' },
              ]}
              placeholder="Pick availability"
            />
          </div>
          <div className="space-y-3">
            <label className="text-sm font-medium">Hourly Rate (USD)</label>
            <Input type="number" min={0} name="hourlyRate" placeholder="10" />
            <label className="text-sm font-medium">LinkedIn (optional)</label>
            <Input name="linkedin" placeholder="https://linkedin.com/in/..." />
            <label className="text-sm font-medium">Portfolio / Website (optional)</label>
            <Input name="portfolio" placeholder="https://your.site" />
            <label className="text-sm font-medium">Teaching Bio</label>
            <Textarea name="bio" rows={6} placeholder="Share your teaching approach, achievements, and focus areas..." />
          </div>
        </Card>

        <Card id="documents" className="space-y-4">
          <div className="flex items-center justify-between">
            <h3 className="text-xl font-semibold">Document Verification</h3>
            <Badge>{docCount} file(s) selected</Badge>
          </div>
          <DocumentUploadStub onCountChange={setDocCount} />
        </Card>

        <Card className="space-y-3">
          <div className="flex items-center gap-2">
            <Checkbox name="agree" />
            <span className="text-sm">
              I confirm all details are accurate and agree to GramorX terms & policies.
            </span>
          </div>
          <div className="flex gap-3">
            <Button type="submit" disabled={loading}>{loading ? 'Submittingâ€¦' : 'Submit for Review'}</Button>
            <Link href="/teacher" className="btn">Back</Link>
          </div>
        </Card>
      </form>
    </Container>
  );
}





============================================================
FILE #5
PATH: mobile/android/twa/src/main/res/values/strings.xml
============================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">GramorX</string>
    <string name="production_url">https://gramorx.com/</string>
    <string name="production_origin">https://gramorx.com</string>
    <string name="file_provider_authority">com.gramorx.twa.fileprovider</string>
    <string name="asset_statements">[{"relation":["delegate_permission/common.handle_all_urls"],"target":{"namespace":"web","site":"https://gramorx.com"}}]</string>
    <string name="delegate_default_scope">https://gramorx.com/</string>
    <string name="delegate_notifications_scope">https://gramorx.com/</string>
    <string name="delegate_file_handling_scope">https://gramorx.com/</string>
</resources>





============================================================
FILE #6
PATH: pages/teacher/cohorts/[id].tsx
============================================================
// pages/teacher/cohorts/[id].tsx
import * as React from "react";
import Head from "next/head";
import Link from "next/link";
import { useRouter } from "next/router";
import { Container } from "@/components/design-system/Container";
import { CohortTable, type CohortRow } from "@/components/teacher/CohortTable";
import { AssignTaskModal } from "@/components/teacher/AssignTaskModal";
import { supabaseBrowser } from "@/lib/supabaseBrowser";
import { resolveAvatarUrl } from '@/lib/avatar';

type Cohort = { id: string; name: string; created_at: string };

export default function CohortDetail() {
  const router = useRouter();
  const cohortId = (router.query.id as string) || "";

  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<string | null>(null);
  const [cohort, setCohort] = React.useState<Cohort | null>(null);
  const [rows, setRows] = React.useState<CohortRow[]>([]);
  const [assignOpen, setAssignOpen] = React.useState(false);

  const refresh = React.useCallback(async () => {
    if (!cohortId) return;
    try {
      setLoading(true);
      setError(null);

      // Load cohort shell (enforced by RLS: must be teacher's cohort)
      const { data: cRow, error: e1 } = await supabaseBrowser
        .from("teacher_cohorts")
        .select("*")
        .eq("id", cohortId)
        .single();

      if (e1 || !cRow) throw new Error(e1?.message || "Cohort not found");
      setCohort(cRow as Cohort);

      // Load members with profile info if available
      const { data: members, error: e2 } = await supabaseBrowser
        .from("teacher_cohort_members")
        .select("id, cohort_id, student_id, joined_at, progress, profiles(full_name, email, avatar_url)")
        .eq("cohort_id", cohortId);

      if (e2) throw new Error(e2.message);

      const normalized: CohortRow[] = await Promise.all((members as any[]).map(async (m) => {
        const prog = m.progress || {};
        // crude completion: count truthy "done" values
        const completed = Object.values(prog).filter((v: any) => v === "done" || v === true).length;
        const total = Math.max(completed, 14); // assume 14-day track; adjust when real tasks exist
        const resolvedAvatar = await resolveAvatarUrl(m.profiles?.avatar_url ?? null);
        return {
          id: m.id,
          cohortId: m.cohort_id,
          studentId: m.student_id,
          joinedAt: m.joined_at,
          progress: prog,
          fullName: m.profiles?.full_name ?? "Student",
          email: m.profiles?.email ?? undefined,
          avatarUrl: resolvedAvatar.signedUrl ?? undefined,
          completed,
          total,
        };
      }));

      setRows(normalized);
    } catch (e: any) {
      setError(e.message ?? "Error");
    } finally {
      setLoading(false);
    }
  }, [cohortId]);

  React.useEffect(() => {
    void refresh();
  }, [refresh]);

  const onNudge = async (studentId: string) => {
    const message = `Reminder: Please complete today's challenge task for cohort ${cohort?.name}.`;
    const res = await fetch("/api/notifications/nudge", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ to: studentId, message }),
    });
    if (!res.ok) {
      const j = await res.json().catch(() => ({}));
      alert(j?.error ?? "Failed to send nudge");
    } else {
      alert("Nudge sent!");
    }
  };

  const onRemove = async (membershipId: string) => {
    // RLS delete policy not defined earlier; may fail until policy is added.
    const { error } = await supabaseBrowser
      .from("teacher_cohort_members")
      .delete()
      .eq("id", membershipId);
    if (error) {
      alert(error.message);
    } else {
      setRows((prev) => prev.filter((r) => r.id !== membershipId));
    }
  };

  return (
    <>
      <Head>
        <title>{cohort ? `${cohort.name} Â· Cohort` : "Cohort"} Â· GramorX</title>
        <meta name="description" content="Manage cohort members and assignments." />
      </Head>

      <div className="py-6">
        <Container>
          <header className="mb-4 flex items-center justify-between">
            <div>
              <h1 className="text-h2 font-bold text-foreground">
                {cohort?.name || "Cohort"}
              </h1>
              <p className="text-small text-muted-foreground">
                Track member progress and assign tasks.
              </p>
            </div>
            <nav className="flex items-center gap-3">
              <Link
                href="/teacher"
                className="rounded-md border border-border bg-background px-3 py-1.5 text-small text-foreground hover:bg-border/30"
              >
                All Cohorts
              </Link>
              <button
                type="button"
                onClick={() => setAssignOpen(true)}
                className="rounded-md border border-border bg-primary px-3 py-1.5 text-small text-background hover:opacity-90"
              >
                Assign task
              </button>
            </nav>
          </header>

          {loading ? (
            <div className="rounded-xl border border-border bg-card p-4 text-small text-muted-foreground">
              Loading cohortâ€¦
            </div>
          ) : error ? (
            <div className="rounded-xl border border-border bg-card p-4 text-small text-danger">
              {error}
            </div>
          ) : !cohort ? (
            <div className="rounded-xl border border-border bg-card p-4 text-small text-muted-foreground">
              Cohort not found.
            </div>
          ) : (
            <CohortTable rows={rows} onNudge={onNudge} onRemove={onRemove} />
          )}
        </Container>
      </div>

      <AssignTaskModal
        open={assignOpen}
        onClose={() => setAssignOpen(false)}
        cohortId={cohortId}
        onSubmit={async (data) => {
          // Uses API route which expects teacher_assignments table. If missing, backend will return error.
          const res = await fetch("/api/teacher/assignments", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(data),
          });
          if (!res.ok) {
            const j = await res.json().catch(() => ({}));
            alert(j?.error ?? "Failed to assign task");
          } else {
            setAssignOpen(false);
            alert("Task assigned");
          }
        }}
      />
    </>
  );
}





============================================================
FILE #7
PATH: mobile/android/twa/src/main/res/values/arrays.xml
============================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="twa_delegated_scopes">
        <item>@string/delegate_default_scope</item>
        <item>@string/delegate_notifications_scope</item>
        <item>@string/delegate_file_handling_scope</item>
    </string-array>
</resources>





============================================================
FILE #8
PATH: pages/api/writing/reports/band.ts
============================================================
import type { NextApiRequest, NextApiResponse } from 'next';

import { withPlan } from '@/lib/apiGuard';
import { getClientIp, getRequestId } from '@/lib/api/requestContext';
import { trackor } from '@/lib/analytics/trackor.server';
import { createRequestLogger } from '@/lib/obs/logger';
import { sendTransactionalEmail } from '@/lib/email';
import { getServerClient } from '@/lib/supabaseServer';
import { dispatchWhatsAppTask } from '@/lib/tasks/whatsapp';
import { buildBandReportPdf } from '@/lib/writing/reporting';
import { evaluateReadiness } from '@/lib/writing/readiness';
import { BandReportBody } from '@/lib/writing/schemas';

const DEFAULT_RANGE_DAYS = 7;
const SITE_URL = process.env.NEXT_PUBLIC_SITE_URL ?? (process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : 'https://app.gramorx.com');

type Data =
  | {
      downloadToken: string;
      reportId: string;
    }
  | { error: string; details?: unknown };

async function handler(req: NextApiRequest, res: NextApiResponse<Data>) {
  if (req.method !== 'POST') {
    res.setHeader('Allow', 'POST');
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const requestId = getRequestId(req);
  const clientIp = getClientIp(req);
  const logger = createRequestLogger('api/writing/reports/band', { requestId, clientIp });

  const parsed = BandReportBody.safeParse(req.body ?? {});
  if (!parsed.success) {
    logger.warn('invalid band report payload', { issues: parsed.error.flatten() });
    return res.status(400).json({ error: 'Invalid body', details: parsed.error.flatten() });
  }

  const rangeDays = parsed.data.rangeDays ?? DEFAULT_RANGE_DAYS;
  const supabase = getServerClient(req, res);
  const {
    data: { user },
    error: userError,
  } = await supabase.auth.getUser();

  if (userError || !user) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const periodEnd = new Date();
  const periodStart = new Date(Date.now() - rangeDays * 24 * 60 * 60 * 1000);

  const [{ data: profile }, { data: attempts }, { data: drills }] = await Promise.all([
    supabase
      .from('profiles')
      .select('full_name, email, notification_channels, phone')
      .eq('id', user.id)
      .maybeSingle(),
    supabase
      .from('writing_attempts')
      .select('id, created_at, overall_band, scores_json, writing_prompts(topic)')
      .eq('user_id', user.id)
      .eq('status', 'scored')
      .gte('created_at', periodStart.toISOString())
      .order('created_at', { ascending: false }),
    supabase
      .from('writing_drill_events')
      .select('tags')
      .eq('user_id', user.id)
      .gte('completed_at', periodStart.toISOString()),
  ]);

  const readiness = await evaluateReadiness(supabase, user.id);

  const attemptSummaries = (attempts ?? []).map((row, index, arr) => {
    const prev = arr[index + 1];
    const band = row.overall_band ?? null;
    const prevBand = prev?.overall_band ?? null;
    const delta = band !== null && prevBand !== null ? band - prevBand : null;
    return {
      topic: (row.writing_prompts as { topic?: string } | null)?.topic ?? 'Prompt',
      createdAt: row.created_at,
      band,
      delta,
    };
  });

  const averageBand = attemptSummaries.length
    ? attemptSummaries.reduce((sum, attempt) => sum + (attempt.band ?? 0), 0) / attemptSummaries.length
    : null;

  const drillSummary = (drills ?? []).reduce<Record<string, number>>((acc, row) => {
    const tags = Array.isArray(row.tags) ? (row.tags as string[]) : [];
    tags.forEach((tag) => {
      acc[tag] = (acc[tag] ?? 0) + 1;
    });
    return acc;
  }, {});

  const pdf = await buildBandReportPdf({
    userName: profile?.full_name ?? 'Learner',
    periodStart: periodStart.toISOString(),
    periodEnd: periodEnd.toISOString(),
    averageBand,
    attempts: attemptSummaries,
    drills: { total: drills?.length ?? 0, tags: drillSummary },
    readiness: { pass: readiness.pass, missing: readiness.missing },
  });

  const summary = {
    rangeDays,
    attemptCount: attemptSummaries.length,
    averageBand,
    drillCount: drills?.length ?? 0,
    readiness: readiness.pass ? 'pass' : 'fail',
  };

  const channels = new Set(parsed.data.channels ?? profile?.notification_channels ?? ['in_app']);

  const { data: reportRow, error: insertError } = await supabase
    .from('writing_band_reports')
    .insert({
      user_id: user.id,
      period_start: periodStart.toISOString(),
      period_end: periodEnd.toISOString(),
      summary,
      pdf,
      channels: Array.from(channels),
    })
    .select('id, download_token')
    .single();

  if (insertError || !reportRow) {
    logger.error('failed to save band report', { error: insertError?.message, userId: user.id });
    return res.status(500).json({ error: insertError?.message ?? 'Failed to generate report' });
  }

  const downloadUrl = `${SITE_URL}/api/writing/reports/${reportRow.download_token}`;

  if (channels.has('email') && profile?.email) {
    try {
      await sendTransactionalEmail({
        to: profile.email,
        subject: 'Your GramorX writing band report is ready',
        text: `Download your report: ${downloadUrl}`,
        html: `<p>Your weekly writing band report is ready.</p><p><a href="${downloadUrl}">Download the PDF</a></p>`,
        attachments: [
          {
            filename: `band-report-${periodEnd.toISOString().slice(0, 10)}.pdf`,
            content: pdf.toString('base64'),
            mimetype: 'application/pdf',
          },
        ],
      });
    } catch (error) {
      logger.warn('email delivery failed', { error: error instanceof Error ? error.message : String(error) });
    }
  }

  if (channels.has('whatsapp') && profile?.phone) {
    try {
      await dispatchWhatsAppTask(supabase, {
        userId: user.id,
        type: 'task',
        message: `Your GramorX writing band report is ready. Download it here: ${downloadUrl}`,
        metadata: { reportId: reportRow.id },
      });
    } catch (error) {
      logger.warn('whatsapp dispatch failed', { error: error instanceof Error ? error.message : String(error) });
    }
  }

  await supabase
    .from('writing_band_reports')
    .update({ sent_at: new Date().toISOString() })
    .eq('id', reportRow.id);

  await trackor.log('writing_band_report_generated', {
    user_id: user.id,
    report_id: reportRow.id,
    request_id: requestId,
    ip: clientIp,
  });

  return res.status(200).json({ downloadToken: reportRow.download_token, reportId: reportRow.id });
}

export default withPlan('starter', handler, { allowRoles: ['teacher', 'admin'] });





============================================================
FILE #9
PATH: hooks/useNotifications.ts
============================================================
import * as React from 'react';
import useSWR from 'swr';
import type { NotificationNudge, NotificationListResponse } from '@/lib/schemas/notifications';

const NOTIFICATIONS_KEY = '/api/notifications';
const NOTIFICATIONS_LIST_KEY = '/api/notifications/list';

export function useNotifications() {
  const { data, error, mutate } = useSWR(NOTIFICATIONS_KEY, async (url) => {
    const response = await fetch(url);
    if (!response.ok) throw new Error('Failed to fetch notifications');
    return response.json();
  });

  const notifications: NotificationNudge[] = data?.notifications || [];
  const unreadCount: number = data?.unread || 0;

  const markAsRead = React.useCallback(async (notificationId: string) => {
    try {
      // Optimistic update
      const optimisticData = {
        ...data,
        notifications: notifications.map(n => 
          n.id === notificationId ? { ...n, read: true } : n
        ),
        unread: Math.max(0, unreadCount - 1),
      };

      mutate(optimisticData, false);

      const response = await fetch(`/api/notifications/${notificationId}`, {
        method: 'PATCH',
      });

      if (!response.ok) throw new Error('Failed to mark as read');
      
      // Revalidate
      mutate();
    } catch (error) {
      console.error('Failed to mark notification as read:', error);
      mutate(); // Revert by re-fetching
    }
  }, [data, mutate, notifications, unreadCount]);

  const markAllAsRead = React.useCallback(async () => {
    try {
      // Optimistic update
      const optimisticData = {
        ...data,
        notifications: notifications.map(n => ({ ...n, read: true })),
        unread: 0,
      };

      mutate(optimisticData, false);

      const response = await fetch('/api/notifications', {
        method: 'PATCH',
      });

      if (!response.ok) throw new Error('Failed to mark all as read');
      
      mutate();
    } catch (error) {
      console.error('Failed to mark all notifications as read:', error);
      mutate();
    }
  }, [data, mutate, notifications]);

  return {
    notifications,
    unreadCount,
    isLoading: !error && !data,
    isError: error,
    markAsRead,
    markAllAsRead,
    refresh: mutate,
  };
}

export function useNotificationsList(limit: number = 20) {
  const [cursor, setCursor] = React.useState<string | null>(null);
  const [items, setItems] = React.useState<NotificationNudge[]>([]);
  const [hasMore, setHasMore] = React.useState(true);

  const { data, error, isLoading, mutate } = useSWR(
    cursor ? `${NOTIFICATIONS_LIST_KEY}?limit=${limit}&cursor=${cursor}` : `${NOTIFICATIONS_LIST_KEY}?limit=${limit}`,
    async (url) => {
      const response = await fetch(url);
      if (!response.ok) throw new Error('Failed to fetch notifications');
      return response.json() as Promise<NotificationListResponse>;
    }
  );

  React.useEffect(() => {
    if (data) {
      setItems(prev => {
        // Avoid duplicates when cursor changes
        const newItems = cursor ? data.items : data.items;
        const merged = cursor ? [...prev, ...newItems] : newItems;
        
        // Remove duplicates by id
        return merged.filter((item, index, self) => 
          index === self.findIndex(t => t.id === item.id)
        );
      });
      setHasMore(!!data.nextCursor);
    }
  }, [data, cursor]);

  const loadMore = React.useCallback(() => {
    if (data?.nextCursor) {
      setCursor(data.nextCursor);
    }
  }, [data?.nextCursor]);

  const refresh = React.useCallback(() => {
    setCursor(null);
    setItems([]);
    mutate();
  }, [mutate]);

  return {
    items,
    isLoading,
    isError: error,
    hasMore,
    loadMore,
    refresh,
    unreadCount: data?.unreadCount || 0,
  };
}




============================================================
FILE #10
PATH: lib/writing/notifications.ts
============================================================
import microPrompts from '@/data/writing/micro-prompts.json';

export type WritingNotificationChannel = 'in_app' | 'whatsapp' | 'email';
export type WritingNotificationType = 'micro_prompt' | 'retake_reminder';

const CHANNEL_WHITELIST: readonly WritingNotificationChannel[] = ['in_app', 'whatsapp', 'email'] as const;
const MICRO_PROMPTS = (microPrompts as string[]).filter((entry) => typeof entry === 'string' && entry.trim().length > 0);

export interface RetakePlanProgress {
  windowStart: string;
  windowEnd: string | null;
  redraftsCompleted: number;
  drillsCompleted: number;
  mocksCompleted: number;
}

export interface RetakePlanTargets {
  redrafts: number;
  drills: number;
  mocks: number;
}

export function ensureNotificationChannels(input: unknown): WritingNotificationChannel[] {
  const normalized = new Set<WritingNotificationChannel>(['in_app']);

  const attempt = (() => {
    if (!input) return [];
    if (Array.isArray(input)) return input;
    if (typeof input === 'string') return [input];
    if (typeof input === 'object') {
      if (Array.isArray((input as any).channels)) {
        return (input as any).channels;
      }
      if (Array.isArray((input as any).value)) {
        return (input as any).value;
      }
    }
    return [];
  })();

  attempt
    .filter((value): value is string => typeof value === 'string' && value.trim().length > 0)
    .map((value) => value.trim().toLowerCase())
    .forEach((value) => {
      const channel = CHANNEL_WHITELIST.find((candidate) => candidate === value);
      if (channel) normalized.add(channel);
    });

  return Array.from(normalized);
}

export function getDailyMicroPrompt(reference: Date = new Date()): { message: string; index: number } {
  const pool = MICRO_PROMPTS.length ? MICRO_PROMPTS : ['Practice a focused revision task today.'];
  const seed = new Date(reference);
  seed.setUTCHours(0, 0, 0, 0);
  const epochDay = Math.floor(seed.getTime() / 86_400_000);
  const index = ((epochDay % pool.length) + pool.length) % pool.length;
  return { message: pool[index], index };
}

export function isSameUtcDay(a: Date | string, b: Date | string): boolean {
  const first = new Date(a);
  const second = new Date(b);
  return (
    first.getUTCFullYear() === second.getUTCFullYear() &&
    first.getUTCMonth() === second.getUTCMonth() &&
    first.getUTCDate() === second.getUTCDate()
  );
}

export function buildRetakeReminder(
  progress: RetakePlanProgress,
  targets: RetakePlanTargets = { redrafts: 6, drills: 8, mocks: 2 },
): { message: string; missing: string[]; completion: number } {
  const missing: string[] = [];
  const ratios: number[] = [];

  const pairs: Array<{ label: string; completed: number; target: number }> = [
    { label: 'redraft', completed: progress.redraftsCompleted, target: Math.max(targets.redrafts, 1) },
    { label: 'drill', completed: progress.drillsCompleted, target: Math.max(targets.drills, 1) },
    { label: 'mock', completed: progress.mocksCompleted, target: Math.max(targets.mocks, 1) },
  ];

  pairs.forEach(({ label, completed, target }) => {
    const ratio = Math.min(completed / target, 1);
    ratios.push(ratio);
    if (completed < target) {
      const remaining = target - completed;
      const noun = `${label}${remaining === 1 ? '' : 's'}`;
      missing.push(`${remaining} ${noun}`);
    }
  });

  const completion = Math.round((ratios.reduce((sum, value) => sum + value, 0) / ratios.length) * 100) / 100;
  const windowEnd = progress.windowEnd ? new Date(progress.windowEnd) : null;
  const deadline = windowEnd ? windowEnd.toLocaleDateString(undefined, { month: 'short', day: 'numeric' }) : null;

  let message: string;
  if (missing.length === 0) {
    message = 'Nice workâ€”your 14-day retake plan is on track. Schedule the next attempt while momentum is high.';
  } else {
    const checklist = missing.join(' and ');
    message = `Keep the retake window alive by completing ${checklist}.`;
    if (deadline) {
      message += ` You have until ${deadline}.`;
    }
  }

  return { message, missing, completion };
}

export function shouldSendMicroPromptToday(lastSentAt: string | null | undefined, reference: Date = new Date()): boolean {
  if (!lastSentAt) return true;
  return !isSameUtcDay(lastSentAt, reference);
}






============================================================
FILE #11
PATH: pages/api/writing/notifications/micro-prompt.ts
============================================================
import type { NextApiRequest, NextApiResponse } from 'next';

import { getServerClient } from '@/lib/supabaseServer';
import { createRequestLogger } from '@/lib/obs/logger';
import { getRequestId } from '@/lib/api/requestContext';
import { dispatchWhatsAppTask } from '@/lib/tasks/whatsapp';
import { buildRetakeReminder, ensureNotificationChannels, getDailyMicroPrompt, shouldSendMicroPromptToday } from '@/lib/writing/notifications';
import { MicroPromptRequestBody } from '@/lib/writing/schemas';

interface MicroPromptGetResponse {
  ok: true;
  message: string;
  lastSentAt: string | null;
  channels: string[];
  canSendWhatsApp: boolean;
  alreadySentToday: boolean;
  retakeReminder: {
    message: string;
    completion: number;
    missing: string[];
  } | null;
}

interface MicroPromptPostResponse {
  ok: true;
  message: string;
  delivered: { channel: string; notificationId?: string | null }[];
}

interface ErrorResponse {
  ok: false;
  error: string;
  code?: string;
}

type Response = MicroPromptGetResponse | MicroPromptPostResponse | ErrorResponse;

const ROUTE_NAME = 'api/writing/notifications/micro-prompt';

async function loadProfileAndPlan(supabase: ReturnType<typeof getServerClient>, userId: string) {
  const [profileRes, redraftRes, drillRes, mockRes, readinessRes] = await Promise.all([
    supabase
      .from('profiles')
      .select('notification_channels, whatsapp_opt_in, phone, settings')
      .eq('id', userId)
      .maybeSingle(),
    supabase
      .from('writing_attempts')
      .select('id', { count: 'exact', head: true })
      .eq('user_id', userId)
      .not('version_of', 'is', null),
    supabase
      .from('writing_drill_events')
      .select('id', { count: 'exact', head: true })
      .eq('user_id', userId),
    supabase
      .from('writing_attempts')
      .select('id', { count: 'exact', head: true })
      .eq('user_id', userId)
      .is('version_of', null)
      .eq('status', 'scored'),
    supabase
      .from('writing_readiness')
      .select('window_start, window_end, status')
      .eq('user_id', userId)
      .order('window_start', { ascending: false })
      .limit(1)
      .maybeSingle(),
  ]);

  return {
    profileRow: profileRes.data ?? null,
    planSummary: {
      redraftsCompleted: redraftRes.count ?? 0,
      drillsCompleted: drillRes.count ?? 0,
      mocksCompleted: mockRes.count ?? 0,
    },
    readiness: readinessRes.data ?? null,
  } as const;
}

async function getLastMicroPrompt(supabase: ReturnType<typeof getServerClient>, userId: string) {
  const { data } = await supabase
    .from('writing_notification_events')
    .select('id, channel, created_at, message')
    .eq('user_id', userId)
    .eq('type', 'micro_prompt')
    .order('created_at', { ascending: false })
    .limit(1)
    .maybeSingle();
  return data ?? null;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse<Response>) {
  const requestId = getRequestId(req);
  const logger = createRequestLogger(ROUTE_NAME, { requestId });

  const supabase = getServerClient(req, res);
  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser();

  if (authError || !user) {
    logger.warn('unauthorized', { reason: authError?.message });
    return res.status(401).json({ ok: false, error: 'Unauthorized', code: 'auth_required' });
  }

  if (req.method === 'GET') {
    const [{ profileRow, planSummary, readiness }, lastEvent] = await Promise.all([
      loadProfileAndPlan(supabase, user.id),
      getLastMicroPrompt(supabase, user.id),
    ]);

    const channels = ensureNotificationChannels(profileRow?.notification_channels ?? []);
    const microPrompt = getDailyMicroPrompt();
    const alreadySentToday = !shouldSendMicroPromptToday(lastEvent?.created_at ?? null);

    const retakeReminder = buildRetakeReminder(
      {
        windowStart:
          readiness?.window_start ?? new Date(Date.now() - 14 * 24 * 60 * 60 * 1000).toISOString(),
        windowEnd: readiness?.window_end ?? null,
        ...planSummary,
      },
      { redrafts: 6, drills: 8, mocks: 2 },
    );

    return res.status(200).json({
      ok: true,
      message: microPrompt.message,
      lastSentAt: lastEvent?.created_at ?? null,
      channels,
      canSendWhatsApp: channels.includes('whatsapp') && Boolean(profileRow?.whatsapp_opt_in),
      alreadySentToday,
      retakeReminder,
    });
  }

  if (req.method !== 'POST') {
    res.setHeader('Allow', 'GET,POST');
    return res.status(405).json({ ok: false, error: 'Method not allowed', code: 'method_not_allowed' });
  }

  const parseResult = MicroPromptRequestBody.safeParse(req.body ?? {});
  if (!parseResult.success) {
    logger.warn('invalid body', { issues: parseResult.error.issues });
    return res.status(400).json({ ok: false, error: 'Invalid request body', code: 'invalid_body' });
  }

  const [{ profileRow }, lastEvent] = await Promise.all([
    loadProfileAndPlan(supabase, user.id),
    getLastMicroPrompt(supabase, user.id),
  ]);

  const allowedChannels = ensureNotificationChannels(
    parseResult.data.channels ?? profileRow?.notification_channels ?? [],
  );

  const microPrompt = getDailyMicroPrompt();
  const alreadySentToday = !shouldSendMicroPromptToday(lastEvent?.created_at ?? null);

  if (alreadySentToday) {
    logger.info('micro prompt already sent today', { userId: user.id, lastSentAt: lastEvent?.created_at });
    return res.status(200).json({
      ok: true,
      message: microPrompt.message,
      delivered: [],
    });
  }

  const deliveries: { channel: string; notificationId?: string | null }[] = [];

  if (allowedChannels.includes('in_app')) {
    const { data: notificationRow, error: notificationError } = await supabase
      .from('notifications')
      .insert({ user_id: user.id, message: microPrompt.message, url: '/writing' })
      .select('id')
      .single();

    if (notificationError) {
      logger.error('failed to create in-app notification', { error: notificationError.message });
      return res.status(500).json({ ok: false, error: 'Failed to queue notification', code: 'notification_failed' });
    }

    deliveries.push({ channel: 'in_app', notificationId: notificationRow?.id ?? null });

    await supabase.from('writing_notification_events').insert({
      user_id: user.id,
      channel: 'in_app',
      type: 'micro_prompt',
      message: microPrompt.message,
      metadata: { source: parseResult.data.source, notification_id: notificationRow?.id ?? null },
    });
  }

  if (allowedChannels.includes('whatsapp') && profileRow?.whatsapp_opt_in) {
    try {
      await dispatchWhatsAppTask(supabase, {
        userId: user.id,
        type: 'task',
        message: `${microPrompt.message}\n\nReply DONE when you have applied this tip in todayâ€™s draft.`,
        metadata: { source: ROUTE_NAME, reason: parseResult.data.source },
      });
      deliveries.push({ channel: 'whatsapp' });
      await supabase.from('writing_notification_events').insert({
        user_id: user.id,
        channel: 'whatsapp',
        type: 'micro_prompt',
        message: microPrompt.message,
        metadata: { source: parseResult.data.source, delivery: 'queued' },
      });
    } catch (error) {
      logger.error('failed to queue whatsapp task', { error: error instanceof Error ? error.message : error });
      return res.status(502).json({ ok: false, error: 'Failed to queue WhatsApp micro prompt', code: 'whatsapp_failed' });
    }
  }

  logger.info('micro prompt delivered', { userId: user.id, deliveries });

  return res.status(200).json({
    ok: true,
    message: microPrompt.message,
    delivered: deliveries,
  });
}





============================================================
FILE #12
PATH: mobile/android/twa/README.md
============================================================
# GramorX Trusted Web Activity (TWA)

This module wraps the production Progressive Web App at https://gramorx.com in a Trusted Web Activity so it can be published to the Google Play Store. The build uses the `com.google.androidbrowserhelper` tooling, delegates push notifications, and supports file uploads by default.

## Project layout

- [`build.gradle`](./build.gradle) â€“ Android application module configuration.
- [`src/main/AndroidManifest.xml`](./src/main/AndroidManifest.xml) â€“ declares the Trusted Web Activity launcher, delegated origins for push/file uploads, and maps the default URL to the production domain.
- [`src/main/res/xml/network_security_config.xml`](./src/main/res/xml/network_security_config.xml) â€“ pins HTTPS traffic to `gramorx.com` and subdomains.
- [`assetlinks.json`](./assetlinks.json) â€“ Digital Asset Links statement mirrored on the web app under `/.well-known/assetlinks.json`.

## Requirements

1. **Java 17** and the **Android SDK** (API level 34).
2. **Gradle 8** and the Android Gradle Plugin 8.2.x (bundled via the root `mobile/android/app/build.gradle`).
3. The [Android Browser Helper](https://github.com/GoogleChrome/android-browser-helper) Gradle plugin, pulled automatically from Maven Central.

Install the [Bubblewrap CLI](https://github.com/GoogleChromeLabs/bubblewrap) if you prefer interactive scaffolding and Play Store publishing helpers:

```bash
npm install -g @bubblewrap/cli
bubblewrap updateConfig --appVersionName 1.0.0
```

## Keystore and signing

1. **Create or import the release keystore.** The recommended approach is to generate a dedicated upload key once and store the `.jks` file in your secrets manager:
   ```bash
   keytool -genkeypair \
     -alias upload \
     -keyalg RSA \
     -keysize 2048 \
     -validity 10000 \
     -storepass "<STORE_PASSWORD>" \
     -keypass "<KEY_PASSWORD>" \
     -keystore upload-key.jks
   ```
2. **Configure local environment variables** before running Gradle so the signing block in `build.gradle` can locate the keystore:
   ```bash
   export ANDROID_KEYSTORE="/secure/path/upload-key.jks"
   export ANDROID_KEYSTORE_PASSWORD="<STORE_PASSWORD>"
   export ANDROID_KEY_ALIAS="upload"
   export ANDROID_KEY_PASSWORD="<KEY_PASSWORD>"
   ```
3. **Capture the SHA-256 fingerprint** that must appear in both `assetlinks.json` files and the Play Console. Replace `<KEYSTORE>` with your keystore path:
   ```bash
   keytool -list -v -alias "$ANDROID_KEY_ALIAS" -keystore "$ANDROID_KEYSTORE" | grep 'SHA256:'
   ```
   Update the fingerprint in:
   - [`mobile/android/twa/assetlinks.json`](./assetlinks.json)
   - [`pages/.well-known/assetlinks.json`](../../../pages/.well-known/assetlinks.json)

## Building and releasing

1. **Assemble a release bundle**:
   ```bash
   cd mobile/android
   ./gradlew :twa:bundleRelease
   ```
   The output `app-release.aab` lives under `mobile/android/twa/build/outputs/bundle/release/` and is ready for Play Console upload.
2. **Generate Play signing keys if prompted** in the Play Console and register the upload certificate fingerprint. Ensure the console fingerprint matches the one committed above.
3. **Verify Digital Asset Links** after deployment:
   - Serve `https://gramorx.com/.well-known/assetlinks.json` and confirm it matches the module copy.
   - Run `adb shell am start -a android.intent.action.VIEW -d https://gramorx.com` on a device with the app installed. Chrome should open inside the TWA without displaying the URL bar.

## QA checklist for push & file uploads

1. **Push notifications delegation**
   - Install the release build on a device running Android 13+.
   - Visit `https://gramorx.com` inside the TWA and grant the notification permission prompt.
   - Trigger a test push (e.g., via Supabase or the staging push endpoint) and confirm it arrives while the TWA is foregrounded and backgrounded.
   - Validate `adb logcat | grep DelegationService` shows no delegation errors.
2. **File uploads & captures**
   - From any form inside the PWA, open a file picker (e.g., profile photo upload) and ensure the native document picker appears.
   - Test camera capture by selecting the camera option; verify the photo uploads successfully.
   - Confirm `content://com.gramorx.twa.fileprovider/...` URIs are produced in the logs.
3. **Chrome verification commands**
   ```bash
   adb shell dumpsys activity services | grep -A2 gramorx
   adb shell pm get-app-links com.gramorx.twa
   ```
   These commands confirm the Play Store build trusts the declared delegates and the app-link verification has passed.

## Release checklist summary

- [ ] Keystore stored securely and environment variables configured.
- [ ] SHA-256 fingerprint confirmed in both Asset Links manifests and the Play Console.
- [ ] Release bundle generated and uploaded to the appropriate Play track.
- [ ] Push notifications tested end-to-end in a signed build.
- [ ] File uploads (document picker + camera capture) verified in the Trusted Web Activity.





============================================================
FILE #13
PATH: pages/writing/overview.tsx
============================================================
import React, { useCallback, useMemo, useState } from 'react';
import type { GetServerSideProps } from 'next';
import Link from 'next/link';

import { Badge } from '@/components/design-system/Badge';
import { Button } from '@/components/design-system/Button';
import { Card } from '@/components/design-system/Card';
import { EmptyState } from '@/components/design-system/EmptyState';
import { ProgressBar } from '@/components/design-system/ProgressBar';
import { Separator } from '@/components/design-system/Separator';
import { WritingLayout } from '@/layouts/WritingLayout';
import { withPlan } from '@/lib/plan/withPlan';
import { getServerClient } from '@/lib/supabaseServer';
import type { Database } from '@/types/supabase';
import type { PlanId } from '@/types/pricing';
import type { AttemptSummary, ReadinessSummary } from '@/types/writing-dashboard';
import { mapAttemptRow } from '@/lib/writing/mappers';
import {
  buildRetakeReminder,
  ensureNotificationChannels,
  getDailyMicroPrompt,
  shouldSendMicroPromptToday,
} from '@/lib/writing/notifications';

/*
  This file centralises lightweight UI primitives that wrap your existing DS components.
  It's intentionally placed so you can later split each primitive into its own file under
  `@/components/ui` and re-export from the design-system barrel.

  If you prefer, move `ActionButton`, `OverviewCard`, `StatItem`, and `AttemptCard` to:
  - components/ui/ActionButton.tsx
  - components/ui/OverviewCard.tsx
  - components/ui/StatItem.tsx
  - components/ui/AttemptCard.tsx

  Then export them from `@/components/ui/index.ts` and update imports in this page to:
  `import { ActionButton, OverviewCard, StatItem, AttemptCard } from '@/components/ui';`
*/

/* --------------------------- Design-system wrappers (thin) --------------------------- */

// ActionButton wraps the DS Button and centralises how we render links vs buttons.
export type ActionButtonProps = React.ComponentProps<typeof Button> & { to?: string };
export const ActionButton = ({ to, children, ...rest }: ActionButtonProps) =>
  to ? (
    <Button {...(rest as any)} href={to}>
      {children}
    </Button>
  ) : (
    <Button {...(rest as any)}>{children}</Button>
  );

// OverviewCard provides a single place to change card surface for overview pages.
export const OverviewCard: React.FC<React.PropsWithChildren<{ className?: string }>> = ({ children, className = '' }) => (
  <Card className={`card-surface p-6 sm:p-8 ${className}`}>{children}</Card>
);

export const StatItem: React.FC<{
  label: string;
  value: string | number;
  meta?: string | React.ReactNode;
  progress?: number; // 0..100
}> = ({ label, value, meta, progress }) => {
  return (
    <div className="space-y-2">
      <div className="flex items-center justify-between text-xs uppercase tracking-wider text-muted-foreground">
        <span>{label}</span>
        <span className="font-semibold text-foreground">{value}</span>
      </div>
      {typeof progress === 'number' && <ProgressBar value={progress} tone="info" ariaLabel={`${label} progress`} />}
      {meta && <div className="text-xs text-muted-foreground">{meta}</div>}
    </div>
  );
};

export const AttemptCard: React.FC<{ attempt: AttemptSummary; compact?: boolean }> = ({ attempt, compact = false }) => {
  return (
    <li className={`flex flex-col gap-3 rounded-2xl border border-border/60 bg-card/70 p-5 shadow-sm transition-transform ${compact ? 'sm:flex-row sm:items-center' : ''}`}>
      <div className="flex-1">
        <p className="text-sm font-medium text-foreground">{attempt.promptTopic}</p>
        <p className="text-xs text-muted-foreground">Updated {new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' }).format(new Date(attempt.updatedAt))}</p>
      </div>

      <div className="mt-3 flex items-center gap-3 text-sm text-muted-foreground sm:mt-0 sm:flex-col sm:items-end">
        <span>{attempt.wordCount} words</span>
        {attempt.overallBand ? <span className="font-semibold text-foreground">Band {attempt.overallBand.toFixed(1)}</span> : <span>Awaiting score</span>}
      </div>

      <div className="mt-3 flex gap-2 sm:mt-0">
        <ActionButton size="sm" variant="outline" to={`/writing/${attempt.promptSlug}?attemptId=${attempt.id}`}>
          View
        </ActionButton>
        {attempt.hasFeedback && (
          <ActionButton size="sm" variant="ghost" to={`/writing/review/${attempt.id}`}>
            Review
          </ActionButton>
        )}
      </div>
    </li>
  );
};

/* --------------------------- Page implementation (uses the wrappers above) --------------------------- */

const RETAKE_PLAN_TARGETS = { redrafts: 6, drills: 8, mocks: 2 } as const;

const progressPercentage = (value: number, target: number) => {
  if (target <= 0) return value > 0 ? 100 : 0;
  return Math.max(0, Math.min(100, Math.round((value / target) * 100)));
};

const formatDate = (value: string) => new Intl.DateTimeFormat(undefined, { dateStyle: 'medium' }).format(new Date(value));
const formatDateTime = (value: string) =>
  new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' }).format(new Date(value));

const statusLabel: Record<AttemptSummary['status'], string> = {
  draft: 'Draft in progress',
  submitted: 'Scoring pending',
  scored: 'Scored',
};

const planLimitCopy: Record<PlanId, { label: string; description: string }> = {
  free: {
    label: 'Explorer preview',
    description: 'Upgrade to Seedling to unlock the full library with filters and drill recommendations.',
  },
  starter: {
    label: '100 prompts unlocked',
    description: 'Browse the 100 most recent prompts curated for Seedling plans with smart filters.',
  },
  booster: {
    label: '500 detailed prompts',
    description: 'Rocket members unlock 500 prompts with deeper outlines and historical metadata.',
  },
  master: {
    label: '500 prompts + AI',
    description: 'Owl unlocks the full 500 prompt vault plus on-demand AI prompt generation.',
  },
};

interface OverviewPageProps {
  readiness: ReadinessSummary | null;
  planSummary: {
    windowStart: string;
    windowEnd: string | null;
    redraftsCompleted: number;
    drillsCompleted: number;
    mocksCompleted: number;
  };
  microPrompt: {
    message: string;
    lastSentAt: string | null;
    channels: string[];
    canSendWhatsApp: boolean;
    alreadySentToday: boolean;
    retakeReminder: {
      message: string;
      completion: number;
      missing: string[];
    } | null;
  };
  stats: {
    activeDrafts: number;
    recentAttempts: AttemptSummary[];
  };
  __plan: PlanId;
}

const WritingOverview = ({ readiness, planSummary, microPrompt, stats, __plan }: OverviewPageProps) => {
  const [microPromptState, setMicroPromptState] = useState(microPrompt);
  const [microPromptLoading, setMicroPromptLoading] = useState(false);
  const [microPromptError, setMicroPromptError] = useState<string | null>(null);
  const [announcement, setAnnouncement] = useState('');

  const passReadiness = readiness?.pass ?? false;
  const missingSummary = readiness?.missing ?? [];

  const planTargets = RETAKE_PLAN_TARGETS;

  const planProgressItems = useMemo(
    () => [
      { key: 'redrafts', label: 'Redrafts completed', value: planSummary.redraftsCompleted, target: planTargets.redrafts },
      { key: 'drills', label: 'Micro-drills logged', value: planSummary.drillsCompleted, target: planTargets.drills },
      { key: 'mocks', label: 'Mock attempts reviewed', value: planSummary.mocksCompleted, target: planTargets.mocks },
    ] as const,
    [planSummary.drillsCompleted, planSummary.mocksCompleted, planSummary.redraftsCompleted, planTargets.drills, planTargets.mocks, planTargets.redrafts],
  );

  const refreshMicroPrompt = useCallback(async () => {
    try {
      const response = await fetch('/api/writing/notifications/micro-prompt');
      const payload = (await response.json()) as
        | ({ ok: true; message: string; lastSentAt: string | null; channels: string[]; canSendWhatsApp: boolean; alreadySentToday: boolean; retakeReminder: OverviewPageProps['microPrompt']['retakeReminder'] })
        | ({ ok: false; error: string });

      if (!response.ok || !payload || !('ok' in payload) || !payload.ok) {
        const reason = !payload || !('error' in payload) ? 'Unable to refresh micro prompt' : payload.error;
        throw new Error(reason);
      }

      setMicroPromptState({
        message: payload.message,
        lastSentAt: payload.lastSentAt,
        channels: payload.channels,
        canSendWhatsApp: payload.canSendWhatsApp,
        alreadySentToday: payload.alreadySentToday,
        retakeReminder: payload.retakeReminder,
      });
      setMicroPromptError(null);
      setAnnouncement('Daily micro prompt refreshed.');
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Unable to refresh micro prompt';
      setMicroPromptError(message);
      setAnnouncement(message);
    }
  }, []);

  const handleSendMicroPrompt = useCallback(async () => {
    setMicroPromptLoading(true);
    setMicroPromptError(null);
    setAnnouncement('Sending micro promptâ€¦');
    try {
      const response = await fetch('/api/writing/notifications/micro-prompt', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ channels: ['in_app', 'whatsapp'], source: 'dashboard' }),
      });
      const payload = (await response.json()) as { ok: boolean; error?: string };
      if (!response.ok || !payload.ok) {
        throw new Error(payload.error ?? 'Unable to send micro prompt');
      }
      await refreshMicroPrompt();
    } catch (err) {
      setMicroPromptError(err instanceof Error ? err.message : 'Unable to send micro prompt');
      setAnnouncement('Unable to send micro prompt');
    } finally {
      setMicroPromptLoading(false);
    }
  }, [refreshMicroPrompt]);

  const currentPlanCopy = planLimitCopy[__plan];

  return (
    <WritingLayout plan={__plan} current="overview">
      <div aria-live="polite" role="status" className="sr-only">
        {announcement}
      </div>

      {/* Primary overview hero */}
      <OverviewCard className="relative overflow-hidden border border-border/50 bg-gradient-to-br from-primary/10 via-background/80 to-background/95 shadow-xl">
        <div className="flex flex-col gap-8 lg:flex-row lg:items-start lg:justify-between">
          <div className="max-w-2xl space-y-4">
            <Badge variant="default" tone={passReadiness ? 'success' : 'info'} size="sm">
              {passReadiness ? 'Redraft unlocked' : 'Stay consistent'}
            </Badge>

            <div className="space-y-3">
              <h2 className="text-3xl font-semibold text-foreground sm:text-4xl">Your writing overview</h2>
              <p className="text-base leading-relaxed text-muted-foreground sm:text-lg">
                Track readiness, review reminders, and hop into focused drills. Use the navigation above to explore the full prompt library and analyze your history.
              </p>
            </div>

            <div className="flex flex-wrap gap-3">
              <ActionButton variant="primary" size="lg" to="/writing/library">
                Browse prompt library
              </ActionButton>
              <ActionButton variant="outline" size="lg" to="/writing/progress">
                View drafts &amp; feedback
              </ActionButton>
              <ActionButton variant="ghost" size="lg" to="/writing/drills">
                Jump into drills
              </ActionButton>
            </div>

            {!passReadiness && missingSummary.length > 0 && (
              <p className="text-sm text-muted-foreground">Unlock redrafts by completing: {missingSummary.join(', ')}</p>
            )}
          </div>

          <div className="flex w-full flex-col gap-4 rounded-2xl border border-border/60 bg-background/70 p-5 text-sm text-muted-foreground shadow-inner lg:max-w-xs">
            <div className="flex items-center justify-between">
              <span className="font-medium text-foreground">Study window</span>
              <Badge variant="default" tone="info" size="sm">
                {formatDate(planSummary.windowStart)} &ndash; {planSummary.windowEnd ? formatDate(planSummary.windowEnd) : 'TBD'}
              </Badge>
            </div>

            <Separator />

            <ul className="space-y-3">
              {planProgressItems.map((item) => (
                <li key={item.key} className="space-y-2">
                  <StatItem label={item.label} value={`${item.value}/${item.target}`} progress={progressPercentage(item.value, item.target)} />
                </li>
              ))}
            </ul>
          </div>
        </div>
      </OverviewCard>

      {/* Prompt access + Micro prompt */}
      <section className="grid gap-6 lg:grid-cols-[minmax(0,1.4fr)_minmax(0,1fr)] mt-6">
        <OverviewCard>
          <div className="flex items-start justify-between gap-3">
            <div>
              <h3 className="text-2xl font-semibold text-foreground">Prompt access</h3>
              <p className="text-sm text-muted-foreground">{currentPlanCopy.description}</p>
            </div>
            <Badge variant="default" tone="default" size="sm">
              {currentPlanCopy.label}
            </Badge>
          </div>

          <div className="mt-4 rounded-2xl border border-dashed border-border/50 bg-muted/40 p-4 text-sm text-muted-foreground">
            <p>{currentPlanCopy.description}</p>
          </div>

          <div className="mt-4 flex flex-wrap gap-3">
            <ActionButton variant="primary" to="/writing/library">Open prompt library</ActionButton>
            <ActionButton variant="ghost" to="/pricing?need=starter">Upgrade plans</ActionButton>
          </div>
        </OverviewCard>

        <OverviewCard>
          <div className="flex items-start justify-between gap-3">
            <div>
              <h3 className="text-xl font-semibold text-foreground">Daily micro prompt</h3>
              <p className="text-sm text-muted-foreground">A quick nudge to sharpen today&apos;s session.</p>
            </div>
            <Badge variant="default" tone="info" size="sm">Updated daily</Badge>
          </div>

          <div className="mt-3 rounded-2xl border border-dashed border-border/50 bg-muted/50 p-3 text-sm text-foreground">{microPromptState.message}</div>

          {microPromptState.retakeReminder && (
            <div className="mt-3 rounded-2xl border border-dashed border-border/40 bg-card/60 p-3 text-xs text-muted-foreground">{microPromptState.retakeReminder.message}</div>
          )}

          {microPromptError && <p className="mt-2 text-sm text-danger">{microPromptError}</p>}

          <div className="mt-3 flex items-center justify-between gap-3 text-xs text-muted-foreground">
            <span>{microPromptState.lastSentAt ? `Last nudged ${formatDateTime(microPromptState.lastSentAt)}` : 'Not delivered yet today'}</span>
            {!microPromptState.canSendWhatsApp && (
              <span>
                WhatsApp nudges require opt-in &mdash; manage in{' '}
                <Link href="/notifications" className="text-primary underline underline-offset-4">
                  notification settings
                </Link>
                .
              </span>
            )}
          </div>

          <div className="mt-3 flex flex-wrap items-center gap-3">
            <ActionButton size="sm" variant="primary" onClick={handleSendMicroPrompt} disabled={microPromptState.alreadySentToday && !microPromptLoading} loading={microPromptLoading}>
              {microPromptState.alreadySentToday ? 'Sent for today' : 'Send reminder now'}
            </ActionButton>
            <ActionButton size="sm" variant="ghost" onClick={refreshMicroPrompt}>Refresh tip</ActionButton>
          </div>

          {microPromptState.alreadySentToday && <p className="mt-2 text-xs text-muted-foreground">Tip already delivered today &mdash; check back tomorrow for a fresh cue.</p>}
        </OverviewCard>
      </section>

      {/* Drafts & Submissions */}
      <section className="grid gap-6 lg:grid-cols-2 mt-6">
        <OverviewCard>
          <div className="flex items-center justify-between gap-3">
            <div>
              <h3 className="text-xl font-semibold text-foreground">Active drafts</h3>
              <p className="text-sm text-muted-foreground">Pick up where you left off with autosaved work.</p>
            </div>
            <Badge variant="default" tone="default" size="sm">{stats.activeDrafts} active</Badge>
          </div>

          <div className="mt-4">
            {stats.recentAttempts.filter((a) => a.status !== 'scored').length === 0 ? (
              <EmptyState title="No active drafts" description="Start a new attempt or revisit a scored attempt to launch a redraft." />
            ) : (
              <ul className="space-y-4">
                {stats.recentAttempts.filter((a) => a.status !== 'scored').slice(0, 3).map((attempt) => (
                  <AttemptCard key={attempt.id} attempt={attempt} />
                ))}
              </ul>
            )}
          </div>

          <div className="mt-4">
            <ActionButton variant="ghost" to="/writing/progress">View full progress</ActionButton>
          </div>
        </OverviewCard>

        <OverviewCard>
          <div className="flex items-center justify-between gap-3">
            <div>
              <h3 className="text-xl font-semibold text-foreground">Recent submissions</h3>
              <p className="text-sm text-muted-foreground">See what you submitted recently and track your scores.</p>
            </div>
            <Badge variant="default" tone="default" size="sm">Last {Math.min(stats.recentAttempts.length, 6)}</Badge>
          </div>

          <div className="mt-4">
            {stats.recentAttempts.length === 0 ? (
              <EmptyState title="No attempts yet" description="Submit an essay to unlock AI feedback and trend tracking." />
            ) : (
              <ul className="space-y-4">{stats.recentAttempts.slice(0, 6).map((attempt) => <AttemptCard key={attempt.id} attempt={attempt} />)}</ul>
            )}
          </div>

          <div className="mt-4">
            <ActionButton variant="ghost" to="/writing/progress">View all attempts</ActionButton>
          </div>
        </OverviewCard>
      </section>

      {/* Resources / Boost */}
      <OverviewCard className="mt-6">
        <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
          <div>
            <h3 className="text-xl font-semibold text-foreground">Boost your next attempt</h3>
            <p className="text-sm text-muted-foreground">Layer drills, reviews, and mock feedback to sharpen your routine.</p>
          </div>
          <Badge variant="default" tone="info" size="sm">Curated resources</Badge>
        </div>

        <div className="mt-4 grid gap-4 md:grid-cols-3">
          <Link href="/writing/drills" className="group block rounded-2xl border border-border/60 bg-card/60 p-4 transition hover:border-primary/60 hover:bg-card">
            <div className="flex flex-col h-full">
              <span className="text-sm font-semibold text-foreground">Skill drills</span>
              <span className="mt-2 text-sm text-muted-foreground">Target coherence, task achievement, and grammar with 10-minute micro drills.</span>
              <span className="mt-auto text-sm font-medium text-primary group-hover:underline">Visit drills</span>
            </div>
          </Link>

          <Link href="/writing/reviews" className="group block rounded-2xl border border-border/60 bg-card/60 p-4 transition hover:border-primary/60 hover:bg-card">
            <div className="flex flex-col h-full">
              <span className="text-sm font-semibold text-foreground">AI reviews</span>
              <span className="mt-2 text-sm text-muted-foreground">Compare attempts, highlight improvements, and plan your next rewrite.</span>
              <span className="mt-auto text-sm font-medium text-primary group-hover:underline">Open reviews</span>
            </div>
          </Link>

          <Link href="/writing/drills?tab=mocks" className="group block rounded-2xl border border-border/60 bg-card/60 p-4 transition hover:border-primary/60 hover:bg-card">
            <div className="flex flex-col h-full">
              <span className="text-sm font-semibold text-foreground">Mock library</span>
              <span className="mt-2 text-sm text-muted-foreground">Revisit scored mocks, analyse feedback themes, and schedule your next redraft.</span>
              <span className="mt-auto text-sm font-medium text-primary group-hover:underline">Browse mocks</span>
            </div>
          </Link>
        </div>
      </OverviewCard>
    </WritingLayout>
  );
};

export const getServerSideProps: GetServerSideProps<OverviewPageProps> = withPlan('starter')(async (ctx) => {
  const supabase = getServerClient(ctx.req as any, ctx.res as any);
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return {
      redirect: {
        destination: '/welcome?from=/writing',
        permanent: false,
      },
    };
  }

  const [{ data: attemptRows }, { data: readinessRow }] = await Promise.all([
    supabase
      .from('writing_attempts')
      .select('id, prompt_id, status, updated_at, word_count, overall_band, task_type, feedback_json, writing_prompts (slug, topic)')
      .eq('user_id', user.id)
      .order('updated_at', { ascending: false })
      .limit(12),
    supabase
      .from('writing_readiness')
      .select('status, gates_json, window_start, window_end')
      .eq('user_id', user.id)
      .order('window_start', { ascending: false })
      .limit(1)
      .maybeSingle(),
  ]);

  const attempts = (attemptRows ?? []).map((row) =>
    mapAttemptRow({
      ...row,
      prompt: row.writing_prompts as Pick<Database['public']['Tables']['writing_prompts']['Row'], 'slug' | 'topic'> | null,
    }),
  );

  const draftsActive = attempts.filter((attempt) => attempt.status !== 'scored').length;

  const gates = (readinessRow?.gates_json ?? null) as { missing?: unknown } | null;
  const readiness: ReadinessSummary | null = readinessRow
    ? {
        pass: readinessRow.status === 'pass',
        missing:
          readinessRow.status === 'pass'
            ? []
            : Array.isArray(gates?.missing)
            ? ((gates?.missing as string[]) ?? [])
            : [],
      }
    : null;

  const planWindowStart = readinessRow?.window_start ?? new Date(Date.now() - 14 * 24 * 60 * 60 * 1000).toISOString();
  const planWindowEnd = readinessRow?.window_end ?? null;

  const [{ count: planDrillsCount }, { count: redraftCount }, { count: mockCount }] = await Promise.all([
    supabase
      .from('writing_drill_events')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .gte('completed_at', planWindowStart),
    supabase
      .from('writing_attempts')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .not('version_of', 'is', null)
      .gte('created_at', planWindowStart),
    supabase
      .from('writing_attempts')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .is('version_of', null)
      .eq('status', 'scored')
      .gte('created_at', planWindowStart),
  ]);

  const [{ data: profileRow }, { data: lastMicroPrompt }] = await Promise.all([
    supabase
      .from('profiles')
      .select('notification_channels, whatsapp_opt_in')
      .eq('id', user.id)
      .maybeSingle(),
    supabase
      .from('writing_notification_events')
      .select('created_at, channel')
      .eq('user_id', user.id)
      .eq('type', 'micro_prompt')
      .order('created_at', { ascending: false })
      .limit(1)
      .maybeSingle(),
  ]);

  const microPromptSeed = getDailyMicroPrompt();
  const microChannels = ensureNotificationChannels(profileRow?.notification_channels ?? []);
  const microAlreadySent = !shouldSendMicroPromptToday(lastMicroPrompt?.created_at ?? null);
  const retakeReminder = buildRetakeReminder(
    {
      windowStart: planWindowStart,
      windowEnd: planWindowEnd,
      redraftsCompleted: redraftCount ?? 0,
      drillsCompleted: planDrillsCount ?? 0,
      mocksCompleted: mockCount ?? 0,
    },
    RETAKE_PLAN_TARGETS,
  );

  return {
    props: {
      readiness,
      planSummary: {
        windowStart: planWindowStart,
        windowEnd: planWindowEnd,
        redraftsCompleted: redraftCount ?? 0,
        drillsCompleted: planDrillsCount ?? 0,
        mocksCompleted: mockCount ?? 0,
      },
      microPrompt: {
        message: microPromptSeed.message,
        lastSentAt: lastMicroPrompt?.created_at ?? null,
        channels: microChannels,
        canSendWhatsApp: microChannels.includes('whatsapp') && Boolean(profileRow?.whatsapp_opt_in),
        alreadySentToday: microAlreadySent,
        retakeReminder,
      },
      stats: {
        activeDrafts: draftsActive,
        recentAttempts: attempts,
      },
      __plan: ctx.__plan ?? 'starter',
    },
  } as any;
});

export default WritingOverview;




============================================================
FILE #14
PATH: pages/writing/mock/[mockId]/start.tsx
============================================================
// pages/writing/mock/[mockId]/start.tsx
import React, { useCallback, useState } from 'react';
import type { GetServerSideProps } from 'next';
import Link from 'next/link';
import { useRouter } from 'next/router';

import { Container } from '@/components/design-system/Container';
import { Card } from '@/components/design-system/Card';
import { Button } from '@/components/design-system/Button';
import { Badge } from '@/components/design-system/Badge';
import { toast } from '@/components/design-system/Toaster';

import { writingExamSummaries, type WritingExamSummary } from '@/data/writing/exam-index';
import { getServerClient } from '@/lib/supabaseServer';
import { setMockAttemptId } from '@/lib/mock/state';
import { api, isQuotaExceeded } from '@/lib/http';

interface LatestAttempt {
  attemptId: string;
  status: string;
  startedAt: string | null;
}

interface PageProps {
  mockId: string;
  summary: WritingExamSummary;
  latestAttempt: LatestAttempt | null;
}

const formatAttemptStatus = (status: string) => {
  switch (status) {
    case 'in_progress':
      return 'In progress';
    case 'submitted':
    case 'completed':
      return 'Submitted';
    default:
      return status.replace(/_/g, ' ');
  }
};

const formatTimestamp = (iso: string | null) => {
  if (!iso) return 'Not available';
  try {
    return new Intl.DateTimeFormat(undefined, {
      dateStyle: 'medium',
      timeStyle: 'short',
    }).format(new Date(iso));
  } catch {
    return iso;
  }
};

const WritingMockStartPage: React.FC<PageProps> = ({ mockId, summary, latestAttempt }) => {
  const router = useRouter();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleBegin = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const data = await api<{ attempt: { id: string } }>('/api/mock/writing/start', {
        method: 'POST',
        body: JSON.stringify({ promptId: mockId, mockId }),
      });

      setMockAttemptId('writing', mockId, data.attempt.id);
      await router.push(`/writing/mock/${data.attempt.id}/workspace`);
    } catch (e: any) {
      if (isQuotaExceeded(e)) {
        const moduleName = (e.meta?.module as string) || 'writing';
        const remaining = (e.meta?.remaining ?? 0) as number;
        const resetAtISO = (e.meta?.resetAt as string | undefined) || null;

        toast.error(`No ${moduleName} attempts left.`, {
          description: resetAtISO
            ? `Quota resets ${new Date(resetAtISO).toLocaleString()}.`
            : 'Upgrade to continue.',
          duration: 5000,
        });

        // NEW: route to quota+subscription overview with context
        const usp = new URLSearchParams({
          reason: 'quota_limit',
          from: router.asPath,
          qk: 'writing_mock_attempts',
        });
        if (remaining != null) usp.set('remaining', String(remaining));
        if (resetAtISO) usp.set('resetAt', resetAtISO);

        setTimeout(() => router.push(`/pricing/overview?${usp.toString()}`), 250);
        return;
      }

      setError(e?.error ?? e?.message ?? 'Unexpected error while starting the mock test');
    } finally {
      setLoading(false);
    }
  }, [mockId, router]);

  const handleResume = useCallback(async () => {
    if (!latestAttempt) return;
    setMockAttemptId('writing', mockId, latestAttempt.attemptId);
    await router.push(`/writing/mock/${latestAttempt.attemptId}/workspace`);
  }, [latestAttempt, mockId, router]);

  return (
    <Container className="py-16">
      <div className="mx-auto flex max-w-3xl flex-col gap-6">
        <div className="space-y-3">
          <Link href="/writing/mock" className="text-sm text-primary underline">
            â† Back to writing mock library
          </Link>
          <h1 className="text-3xl font-semibold text-foreground">{summary.title}</h1>
          <p className="text-sm text-muted-foreground">{summary.description}</p>
          <div className="flex flex-wrap items-center gap-2 text-xs text-muted-foreground">
            <Badge variant="info" size="sm">{summary.task1Type}</Badge>
            <Badge variant="secondary" size="sm">Task 1: {summary.task1Focus}</Badge>
            <Badge variant="secondary" size="sm">Task 2: {summary.task2Focus}</Badge>
            <Badge variant="ghost" size="sm">{summary.durationMinutes} minutes</Badge>
            {summary.register ? <Badge variant="outline" size="sm">{summary.register}</Badge> : null}
          </div>
        </div>

        {latestAttempt ? (
          <Card className="rounded-ds-2xl border border-info/40 bg-info/10 p-5">
            <div className="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
              <div>
                <p className="text-sm font-semibold text-info">Last attempt</p>
                <p className="text-sm text-muted-foreground">
                  Status: {formatAttemptStatus(latestAttempt.status)} Â· Started {formatTimestamp(latestAttempt.startedAt)}
                </p>
              </div>
              {latestAttempt.status === 'in_progress' ? (
                <Button onClick={handleResume} variant="secondary" className="rounded-ds">
                  Resume attempt
                </Button>
              ) : (
                <Button
                  href={`/writing/mock/${latestAttempt.attemptId}/results`}
                  variant="secondary"
                  className="rounded-ds"
                >
                  View last results
                </Button>
              )}
            </div>
          </Card>
        ) : null}

        <Card className="card-surface rounded-ds-2xl p-6 space-y-6">
          <div className="space-y-2">
            <h2 className="text-xl font-semibold text-foreground">Before you begin</h2>
            <p className="text-sm text-muted-foreground">
              You&apos;ll complete Task 1 and Task 2 in one sitting. Autosave keeps your work safe every few seconds and focus guard pauses the timer if you leave the tab.
            </p>
          </div>

          <div className="grid gap-4 md:grid-cols-2">
            <Card className="rounded-ds-xl border border-border/50 bg-background/80 p-4 text-sm">
              <p className="font-medium text-foreground">Timing &amp; word targets</p>
              <ul className="mt-2 list-disc pl-5 text-muted-foreground">
                <li>60 minutes total (20 for Task 1, 40 for Task 2)</li>
                <li>Minimum 150 words for Task 1</li>
                <li>Minimum 250 words for Task 2</li>
              </ul>
            </Card>
            <Card className="rounded-ds-xl border border-border/50 bg-background/80 p-4 text-sm">
              <p className="font-medium text-foreground">Scoring criteria</p>
              <ul className="mt-2 list-disc pl-5 text-muted-foreground">
                <li>Task achievement / response</li>
                <li>Coherence and cohesion</li>
                <li>Lexical resource</li>
                <li>Grammatical range and accuracy</li>
              </ul>
            </Card>
          </div>

          <div className="rounded-ds-xl border border-muted/60 bg-muted/30 p-4 text-sm text-muted-foreground">
            <p>
              Stay in full-screen if possible, close extra tabs, and keep notifications off. We track focus to mirror exam conditions and let you review idle time after submitting.
            </p>
          </div>

          {error ? <p className="text-sm text-destructive">{error}</p> : null}

          <div className="flex flex-wrap items-center gap-3">
            <Button onClick={handleBegin} disabled={loading} variant="primary" className="rounded-ds">
              {loading ? 'Preparing...' : 'Begin test'}
            </Button>
            <Button href="/writing/mock" variant="ghost" className="rounded-ds">
              Cancel
            </Button>
          </div>
        </Card>
      </div>
    </Container>
  );
};

export const getServerSideProps: GetServerSideProps<PageProps> = async (ctx) => {
  const supabase = getServerClient(ctx.req as any, ctx.res as any);
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return {
      redirect: {
        destination: '/welcome',
        permanent: false,
      },
    };
  }

  const { mockId } = ctx.params as { mockId: string };
  const summary = writingExamSummaries.find((paper) => paper.id === mockId);
  if (!summary) {
    return { notFound: true };
  }

  const { data: latest } = await supabase
    .from('exam_attempts')
    .select('id, status, started_at, metadata')
    .eq('user_id', user.id)
    .eq('exam_type', 'writing')
    .order('created_at', { ascending: false })
    .limit(5);

  const latestAttempt = (latest ?? []).find((row) => {
    const metadata = (row.metadata as Record<string, unknown> | null) ?? null;
    return typeof metadata?.mockId === 'string' && metadata.mockId === mockId;
  });

  return {
    props: {
      mockId,
      summary,
      latestAttempt: latestAttempt
        ? {
            attemptId: latestAttempt.id,
            status: latestAttempt.status ?? 'in_progress',
            startedAt: latestAttempt.started_at ?? null,
          }
        : null,
    },
  };
};

export default WritingMockStartPage;





============================================================
FILE #15
PATH: pages/writing/mock/[mockId]/workspace.tsx
============================================================
import React, { useEffect, useMemo, useState } from 'react';
import type { GetServerSideProps } from 'next';
import { useRouter } from 'next/router';

import WritingExamRoom from '@/components/writing/WritingExamRoom';
import { Button } from '@/components/design-system/Button';
import { KeyboardAwareSheet } from '@/components/mobile/KeyboardAwareSheet';
import { PushOptInCard } from '@/components/mobile/PushOptInCard';
import { InstallBanner } from '@/components/mobile/InstallBanner';
import { getServerClient } from '@/lib/supabaseServer';
import type { WritingExamPrompts } from '@/types/writing';
import type { PlanId } from '@/types/pricing';
import { planAllows, writingMockLimit } from '@/lib/plan/gates';
import { withPlan } from '@/lib/plan/withPlan';
import { useInstalledApp } from '@/hooks/useInstalledApp';
import { useInstallPrompt } from '@/hooks/useInstallPrompt';
import { clearMockAttemptId } from '@/lib/mock/state';

type PageProps = {
  attemptId: string;
  durationSeconds: number;
  prompts: WritingExamPrompts;
  initialDraft: {
    task1?: { essay: string; wordCount: number };
    task2?: { essay: string; wordCount: number };
    updatedAt?: string | null;
  } | null;
  mockId?: string | null;

  /** server-computed count of attempts started today */
  usedToday: number;
};

const mapPrompt = (row: any) => {
  const topic: string | null =
    (typeof row.topic === 'string' && row.topic) ? row.topic : null;

  const promptText: string | null =
    (typeof row.prompt_text === 'string' && row.prompt_text) ? row.prompt_text
    : (row?.outline_json?.outline_summary ? String(row.outline_json.outline_summary) : null) ||
      topic || null;

  const taskType: string =
    (typeof row.task_type === 'string' && row.task_type) ? row.task_type : 'task2';

  return {
    id: row.id,
    slug: row.slug ?? row.id,
    title: topic ?? 'Untitled',
    promptText,
    taskType,
    module: row.module ?? 'academic',
    difficulty: row.difficulty ?? null,
    source: row.source ?? null,
    tags: row.tags ?? null,
    estimatedMinutes: row.estimated_minutes ?? null,
    wordTarget: row.word_target ?? null,
    metadata: row.metadata ?? null,
  };
};

const WritingMockWorkspacePage: React.FC<PageProps & { __plan?: PlanId }> = ({
  __plan = 'starter',
  attemptId,
  prompts,
  durationSeconds,
  initialDraft,
  mockId = null,
  usedToday,
}) => {
  const router = useRouter();
  const plan = __plan;

  // Quiet test-taking experience (keeps noise down)
  const QUIET_MODE = true;

  const limit = writingMockLimit(plan);
  const remaining = Math.max(0, limit - (usedToday ?? 0));

  const mockLimit = limit;
  const boosterMockLimit = writingMockLimit('booster');
  const masterMockLimit = writingMockLimit('master');
  const formatMockLimit = (l: number) => `${l} daily writing mock test${l === 1 ? '' : 's'}`;

  const { isInstalled } = useInstalledApp();
  const { promptEvent, clearPrompt } = useInstallPrompt();

  const [sheetOpen, setSheetOpen] = useState(false);
  const [installDismissed, setInstallDismissed] = useState(false);
  const [pushDismissed, setPushDismissed] = useState(false);
  const [pushStatus, setPushStatus] = useState<NotificationPermission>(() => {
    if (typeof window === 'undefined' || typeof Notification === 'undefined') return 'default';
    return Notification.permission;
  });

  useEffect(() => {
    if (typeof window === 'undefined' || typeof Notification === 'undefined') return;
    setPushStatus(Notification.permission);
  }, []);

  const supportsPush = typeof window !== 'undefined' && typeof Notification !== 'undefined';

  const shouldShowInstall = useMemo(() => {
    if (QUIET_MODE) return false;
    if (!planAllows(plan, 'writing.install.prompt')) return false;
    if (isInstalled || installDismissed) return false;
    return Boolean(promptEvent);
  }, [QUIET_MODE, installDismissed, isInstalled, plan, promptEvent]);

  const shouldShowPush = useMemo(() => {
    if (QUIET_MODE) return false;
    if (!planAllows(plan, 'writing.push.optin')) return false;
    if (!supportsPush) return false;
    if (pushStatus === 'granted' || pushDismissed) return false;
    return true;
  }, [QUIET_MODE, plan, pushDismissed, pushStatus, supportsPush]);

  const hasEngagementPrompts = shouldShowInstall || shouldShowPush;

  useEffect(() => {
    if (!hasEngagementPrompts) setSheetOpen(false);
  }, [hasEngagementPrompts]);

  const handleInstallComplete = (outcome: 'accepted' | 'dismissed') => {
    setInstallDismissed(true);
    clearPrompt();
    if (outcome === 'accepted') setSheetOpen(false);
  };

  const handlePushGranted = () => {
    setPushStatus('granted');
    setSheetOpen(false);
  };

  const handlePushDismiss = () => setPushDismissed(true);

  return (
    <>
      {/* Calm, universal heading */}
      <div className="mb-4 flex items-end justify-between">
        <div>
          <p className="text-[11px] uppercase tracking-wider text-muted-foreground">IELTS Writing</p>
          <h1 className="text-xl md:text-2xl font-semibold text-foreground">Exam Workspace</h1>
          <p className="mt-1 text-sm text-muted-foreground">
            Complete Task 1 and Task 2 within the time limit. Autosave is on.
          </p>
        </div>

        {/* Quota chip (visible when you still have attempts) */}
        {remaining > 0 && (
          <div
            className="ml-2 inline-flex h-8 items-center rounded-full border border-border/60 bg-muted/40 px-3 text-xs text-muted-foreground"
            aria-live="polite"
          >
            {usedToday}/{mockLimit} today
          </div>
        )}
      </div>

      {/* Clear notice when the daily quota is exhausted (no surprise redirect later) */}
      {remaining === 0 && (
        <div
          className="mb-4 rounded-2xl border border-destructive/40 bg-destructive/10 p-4 text-sm text-destructive"
          role="alert"
        >
          Youâ€™ve reached your daily limit for writing mock tests ({mockLimit}/{mockLimit}). Try again tomorrow
          or{' '}
          <a href={`/pricing/overview?reason=writing_quota&used=${usedToday}&limit=${mockLimit}`} className="underline">
            see plans
          </a>
          .
        </div>
      )}

      {/* Upsell muted while taking test */}
      {!QUIET_MODE && plan !== 'booster' && plan !== 'master' ? (
        <div className="mb-4 rounded-2xl border border-border/50 bg-muted/30 p-4 text-sm text-muted-foreground">
          Starter plans include {formatMockLimit(mockLimit)}. Upgrade to Booster for {formatMockLimit(boosterMockLimit)} and
          advanced analytics, or go Master for {formatMockLimit(masterMockLimit)} plus exportable reports and printable
          certificates.
        </div>
      ) : null}

      {/* Engagement prompts hidden in quiet mode */}
      {hasEngagementPrompts ? (
        <div className="mb-4 hidden gap-4 md:grid md:grid-cols-2">
          {shouldShowInstall ? (
            <InstallBanner promptEvent={promptEvent} onComplete={handleInstallComplete} onDismiss={handleInstallComplete} />
          ) : null}
          {shouldShowPush ? <PushOptInCard onGranted={handlePushGranted} onDismiss={handlePushDismiss} /> : null}
        </div>
      ) : null}

      {hasEngagementPrompts ? (
        <div className="mb-4 flex justify-center md:hidden">
          <Button size="lg" variant="secondary" onClick={() => setSheetOpen(true)}>
            Stay connected
          </Button>
        </div>
      ) : null}

      <WritingExamRoom
        attemptId={attemptId}
        prompts={prompts}
        durationSeconds={durationSeconds}
        initialDraft={initialDraft ?? undefined}
        onSubmitSuccess={(result) => {
          if (mockId) clearMockAttemptId('writing', mockId);
          void router.push(`/writing/mock/${result.attemptId}/evaluating`);
        }}
      />

      <KeyboardAwareSheet
        open={sheetOpen && hasEngagementPrompts}
        title="Stay connected"
        description="Install the app or enable notifications so you never miss feedback."
        onClose={() => setSheetOpen(false)}
      >
        {shouldShowInstall ? (
          <InstallBanner promptEvent={promptEvent} onComplete={handleInstallComplete} onDismiss={handleInstallComplete} />
        ) : null}
        {shouldShowPush ? <PushOptInCard onGranted={handlePushGranted} onDismiss={handlePushDismiss} /> : null}
      </KeyboardAwareSheet>
    </>
  );
};

export const getServerSideProps: GetServerSideProps<PageProps> = withPlan('starter')(async (ctx) => {
  const supabase = getServerClient(ctx.req as any, ctx.res as any);
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { redirect: { destination: '/welcome', permanent: false } };
  }

  const params = ctx.params as { mockId: string };
  const queryAttemptId = typeof ctx.query.attemptId === 'string' ? ctx.query.attemptId : null;
  const attemptId = queryAttemptId ?? params.mockId;
  if (!attemptId) return { notFound: true };

  // Count user's writing attempts started today (UTC day for simplicity)
  const startOfDayUTC = new Date();
  startOfDayUTC.setUTCHours(0, 0, 0, 0);

  const { count: usedToday = 0 } = await supabase
    .from('exam_attempts')
    .select('*', { count: 'exact', head: true })
    .eq('user_id', user.id)
    // If you track module in metadata JSON: require { "module": "writing" }
    .contains('metadata', { module: 'writing' })
    .gte('created_at', startOfDayUTC.toISOString());

  // Load attempt
  const { data: attempt, error } = await supabase
    .from('exam_attempts')
    .select('*')
    .eq('id', attemptId)
    .maybeSingle();

  if (error || !attempt || attempt.user_id !== user.id) {
    return { notFound: true };
  }

  const metadata = (attempt.metadata as any) ?? {};
  const mockIdFromMetadata = typeof metadata.mockId === 'string' ? metadata.mockId : null;
  const fallbackMockId = queryAttemptId ? params.mockId : null;
  const mockId = mockIdFromMetadata ?? fallbackMockId;
  const promptIds = metadata.promptIds ?? {};

  const { data: promptRows } = await supabase
    .from('writing_prompts')
    .select('*')
    .in('id', [promptIds.task1, promptIds.task2].filter(Boolean));

  const task1Row = promptRows?.find((row) => row.id === promptIds.task1) ?? null;
  const task2Row = promptRows?.find((row) => row.id === promptIds.task2) ?? null;

  if (!task1Row || !task2Row) return { notFound: true };

  const prompts: WritingExamPrompts = {
    task1: mapPrompt(task1Row),
    task2: mapPrompt(task2Row),
  };

  const { data: autosaveEvent } = await supabase
    .from('exam_events')
    .select('payload, occurred_at')
    .eq('attempt_id', attemptId)
    .eq('event_type', 'autosave')
    .order('occurred_at', { ascending: false })
    .limit(1)
    .maybeSingle();

  let initialDraft: PageProps['initialDraft'] = null;

  if (autosaveEvent?.payload) {
    const payload = autosaveEvent.payload as any;
    initialDraft = {
      updatedAt: autosaveEvent.occurred_at ?? null,
      task1: payload?.tasks?.task1
        ? { essay: payload.tasks.task1.content ?? '', wordCount: payload.tasks.task1.wordCount ?? 0 }
        : undefined,
      task2: payload?.tasks?.task2
        ? { essay: payload.tasks.task2.content ?? '', wordCount: payload.tasks.task2.wordCount ?? 0 }
        : undefined,
    };
  } else {
    const { data: responseRows } = await supabase
      .from('writing_responses')
      .select('task, answer_text, word_count')
      .eq('exam_attempt_id', attemptId);

    if (responseRows && responseRows.length > 0) {
      const draft: Record<string, { essay: string; wordCount: number }> = {};
      responseRows.forEach((row) => {
        if (row.task === 'task1' || row.task === 'task2') {
          draft[row.task] = {
            essay: row.answer_text ?? '',
            wordCount: row.word_count ?? 0,
          };
        }
      });
      if (Object.keys(draft).length > 0) {
        initialDraft = {
          task1: draft.task1,
          task2: draft.task2,
          updatedAt: attempt.updated_at ?? attempt.created_at ?? null,
        };
      }
    }
  }

  return {
    props: {
      attemptId,
      durationSeconds: attempt.duration_seconds ?? 60 * 60,
      prompts,
      initialDraft: initialDraft ?? null,
      mockId,
      usedToday,
    },
  };
});

export default WritingMockWorkspacePage;




============================================================
FILE #16
PATH: lib/analytics/events.ts
============================================================
// lib/analytics/events.ts

// ---------- Types ----------
export type AnalyticsEventName =
  | 'signup'
  | 'onboarding_completed'
  | 'onboarding_start'
  | 'onboarding_step_complete'
  | 'onboarding_done'
  | 'profile_save'
  | 'studyplan_create'
  | 'studyplan_update'
  | 'saved_view'
  | 'saved_remove'
  | 'mock_started'
  | 'mock_completed'
  | 'ai_feedback_viewed'
  | 'paywall_view'
  | 'subscribe_clicked'
  | 'plan_purchased'
  | 'referral.code.create'
  | 'referral.code.redeem'
  | 'payments.intent.create'
  | 'payments.intent.success'
  | 'notification_enqueued'
  | 'delivery_sent'
  | 'delivery_failed'
  | 'exp.assign'
  | 'exp.expose'
  | 'exp.convert'
  | 'lifecycle.sent'
  | 'referral_link_created'
  | 'referral_redeemed'
  | 'partner_code_applied'
  | 'predictor_completed'
  | 'vocab_review_start'
  | 'vocab_review_finish'
  | 'grade_submitted'
  | 'speaking_attempt'
  | 'speaking_attempt_started'
  | 'speaking_attempt_scored'
  | 'writing_eval'
  | 'badge_unlocked'
  | 'challenge_started'
  | 'challenge_completed'
  | 'challenge_joined'
  | 'certificate_shared'
  | 'teacher_review_started'
  | 'teacher_review_completed'
  | 'teacher_review_scored'
  | 'writing_essay_scored'
  | 'writing.score.v2'
  | 'writing.view.band9'
  | 'writing.view.highlights'
  | 'writing.coach.entry'
  | 'writing.coach.view'
  | 'writing.coach.ask'
  | 'writing.coach.reply'
  | 'writing.coach.error'
  | 'analytics.progress.view'
  | 'analytics.writing.view'
  | 'analytics.writing.trend'
  | 'writing_attempt_started'
  | 'writing_attempt_saved'
  | 'writing_attempt_submitted'
  | 'writing_attempt_scored'
  | 'writing_attempt_metrics'
  | 'writing_redraft_created'
  | 'writing_drill_completed'
  | 'writing_readiness_passed'
  | 'writing_peer_review_submitted'
  | 'writing_band_report_generated'
  | 'writing_cross_evidence'
  | 'writing_cross_hedging'
  | 'writing_handwriting_uploaded'
  | 'xp.award.writing'
  | 'writing.results.view'
  | 'writing.results.share'
  | 'writing.results.analytics_click'
  | 'leaderboard.view.writing'
  | 'study_session_created'
  | 'study_session_started'
  | 'study_item_completed'
  | 'study_session_completed'
  | 'study_session_abandoned'
  | 'mobile.install_prompt.shown'
  | 'mobile.install_prompt.request'
  | 'mobile.install_prompt.result'
  | 'mobile.install_prompt.dismissed'
  | 'mobile.push_opt_in.shown'
  | 'mobile.push_opt_in.request'
  | 'mobile.push_opt_in.permission'
  | 'mobile.push_opt_in.dismissed'
  | 'vocab_word_viewed'
  | 'vocab_meaning_submitted'
  | 'vocab_sentence_submitted'
  | 'vocab_synonyms_submitted'
  | 'vocab_reward_shown'
  | 'vocab_share_clicked'
  | 'coach.writing.session'
  | 'coach.writing.reply'
  | 'reco_shown'
  | 'reco_accepted'
  | 'reco_skipped'
  | 'task_completed'
  | 'prompt_bookmarked'
  | 'prompt_unbookmarked'
  | 'prompt_started_mock'
  | 'prompt_started_coach'
  | 'prompt_randomized'
  | 'prompt_pack_viewed'
  | 'reading.highlight.add'
  | 'reading.note.add'
  | 'reading.flag.toggle'
  | 'reading.nav.filter'
  | 'flag.toggle'
  | 'export.pdf'
  | 'cert.view'
  | 'slo.breach'
  | 'ratelimit.block'
  | 'unsubscribe_clicked';

export type AnalyticsProps = Record<string, string | number | boolean | null | undefined>;

// ---------- Core Tracker ----------
export function track(event: AnalyticsEventName, payload: AnalyticsProps = {}): void {
  // No-op safely on SSR and in prod if no sink exists.
  if (typeof window === 'undefined') return;

  try {
    // Google gtag (if available)
    // @ts-expect-error TODO(gx): add gtag type
    window.gtag?.('event', event, payload);
  } catch {
    /* ignore */
  }

  try {
    // Generic dataLayer push (if available)
    // @ts-expect-error TODO(gx): add dataLayer type
    window.dataLayer?.push({ event, ...payload });
  } catch {
    /* ignore */
  }

  if (process.env.NODE_ENV !== 'production') {
    // eslint-disable-next-line no-console
    console.debug('[analytics]', event, payload);
  }
}





============================================================
FILE #17
PATH: pages/auth/callback.tsx
============================================================
// pages/auth/callback.tsx
'use client';

import { useEffect, useState } from 'react';
import { useRouter } from 'next/router';
import Head from 'next/head';
import { supabaseBrowser as supabase } from '@/lib/supabaseBrowser';

export default function AuthCallback() {
  const router = useRouter();
  const [err, setErr] = useState<string | null>(null);

  useEffect(() => {
    if (!router.isReady) return;

    let cancelled = false;

    const run = async () => {
      const url = new URL(window.location.href);
      const code = url.searchParams.get('code');
      const token_hash = url.searchParams.get('token_hash');
      const type = (url.searchParams.get('type') || '').toLowerCase(); // signup, magiclink, recovery, etc.
      const next = url.searchParams.get('next') || '/';

      try {
        // 1) Handle "code" (OAuth / newer magic link) first
        if (code) {
          const { data, error } = await supabase.auth.exchangeCodeForSession(code);
          if (error) throw error;

          if (data.session) {
            await supabase.auth.setSession(data.session);
          }

          // Best-effort: notify server cookies (if present in your project)
          try {
            await fetch('/api/auth/set-session', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              credentials: 'same-origin',
              body: JSON.stringify({ event: 'SIGNED_IN', session: data.session }),
            });
          } catch { /* ignore */ }

          if (!cancelled) router.replace(next.startsWith('/') ? next : '/');
          return;
        }

        // 2) Handle "token_hash" (email confirm / recovery / invite / email_change)
        if (token_hash && type) {
          const { data, error } = await supabase.auth.verifyOtp({
            type: type as any,
            token_hash,
          });
          if (error) throw error;

          if (data.session) {
            await supabase.auth.setSession(data.session);
          }

          try {
            await fetch('/api/auth/set-session', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              credentials: 'same-origin',
              body: JSON.stringify({ event: 'SIGNED_IN', session: data.session }),
            });
          } catch { /* ignore */ }

          if (!cancelled) router.replace(next.startsWith('/') ? next : '/');
          return;
        }

        // Nothing to verify â€” just go home
        if (!cancelled) router.replace('/');
      } catch (e: any) {
        if (!cancelled) setErr(e?.message || 'Verification failed.');
      }
    };

    void run();

    return () => {
      cancelled = true;
    };
  }, [router, router.isReady]);

  return (
    <>
      <Head><title>Signing you inâ€¦</title></Head>
      <div className="grid min-h-[100dvh] place-items-center">
        {err ? (
          <div className="rounded-ds-2xl border border-destructive/40 p-6 max-w-md">
            <h1 className="text-lg font-semibold text-destructive">Couldnâ€™t verify your email</h1>
            <p className="mt-2 text-muted-foreground">{err}</p>
            <button className="btn mt-4" onClick={() => router.replace('/login')}>Back to login</button>
          </div>
        ) : (
          <div className="text-center">
            <div className="h-6 w-40 animate-pulse rounded bg-border mx-auto" />
            <p className="mt-3 text-muted-foreground">Completing sign-inâ€¦</p>
          </div>
        )}
      </div>
    </>
  );
}





============================================================
FILE #18
PATH: pages/writing/mock/[mockId]/results.tsx
============================================================
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import type { GetServerSideProps } from 'next';
import Link from 'next/link';
import dynamic from 'next/dynamic';

import { Button } from '@/components/design-system/Button';
import { Container } from '@/components/design-system/Container';
import { Badge } from '@/components/design-system/Badge';
import BandDiffView from '@/components/writing/BandDiffView';
import BandProgressChart from '@/components/writing/BandProgressChart';
import WritingResultCard from '@/components/writing/WritingResultCard';
import AccessibilityHints from '@/components/writing/AccessibilityHints';
import ExportButton from '@/components/writing/ExportButton';
import ReferralCard from '@/components/account/ReferralCard';
import { UpgradeDialog } from '@/components/billing/UpgradeDialog';
import { Variant, useVariantConversion } from '@/components/exp/Variant';
import { computeWritingSummary } from '@/lib/analytics/writing';
import {
  logWritingCoachEntry,
  logWritingResultsAnalyticsClick,
  logWritingResultsShare,
  logWritingResultsView,
} from '@/lib/analytics/writing-events';
import { getServerClient } from '@/lib/supabaseServer';
import { computeCriterionDeltas, trimProgressPoints } from '@/lib/writing/progress';
import { calculateWritingXp, type WritingAchievement } from '@/lib/gamification/xp';
import type { CriterionDelta, WritingProgressPoint } from '@/types/analytics';
import type { WritingFeedback, WritingScorePayload, WritingTaskType } from '@/types/writing';
import type { PlanId } from '@/types/pricing';
import { resolveFlags } from '@/lib/flags';
import { track } from '@/lib/analytics/track';
import { evaluateQuota, nextPlanForQuota, type QuotaKey } from '@/lib/plan/quotas';
import { planAllows } from '@/lib/plan/gates';
import { KeyboardAwareSheet } from '@/components/mobile/KeyboardAwareSheet';
import { PushOptInCard } from '@/components/mobile/PushOptInCard';
import { InstallBanner } from '@/components/mobile/InstallBanner';
import { useInstallPrompt } from '@/hooks/useInstallPrompt';
import { useInstalledApp } from '@/hooks/useInstalledApp';

interface HighlightSection {
  task: WritingTaskType;
  essay: string;
  feedback: WritingFeedback;
}

interface PageProps {
  plan: PlanId;
  featureFlags: {
    writingExports: boolean;
    writingCertificates: boolean;
  };
  attemptId: string;
  results: Array<{ task: WritingTaskType; essay: string; score: WritingScorePayload }>;
  averageBand: number;
  highlight?: HighlightSection | null;
  progressPoints: WritingProgressPoint[];
  progressDeltas: CriterionDelta[];
  xp: {
    points: number;
    reason: string;
    achievements: WritingAchievement[];
    improvement: number;
    durationSeconds: number | null;
  };
  quota: { key: QuotaKey; used: number } | null;
  referralCode?: string | null;
}

const CoachDock = dynamic(() => import('@/components/writing/CoachDock'), {
  ssr: false,
  loading: () => (
    <div className="rounded-ds-xl border border-dashed border-border/60 bg-muted/20 p-4 text-sm text-muted-foreground">
      Loading coachâ€¦
    </div>
  ),
});

const quotaCopy: Record<QuotaKey, { title: string; helper: string }> = {
  dailyMocks: {
    title: 'Daily mock limit reached',
    helper: 'Upgrade to unlock more daily attempts and keep your streak going.',
  },
  aiEvaluationsPerDay: {
    title: 'AI feedback limit reached',
    helper: 'Upgrade to increase your daily writing evaluations.',
  },
  storageGB: {
    title: 'Storage limit reached',
    helper: 'Upgrade to expand your library for essays and speaking recordings.',
  },
};

const formatPlanLabel = (id: PlanId) => id.charAt(0).toUpperCase() + id.slice(1);

const quotaLimitText = (key: QuotaKey, limit: number) => {
  const isUnlimited = !Number.isFinite(limit);
  switch (key) {
    case 'dailyMocks':
      return isUnlimited ? 'unlimited daily mock tests' : `${limit} daily mock test${limit === 1 ? '' : 's'}`;
    case 'aiEvaluationsPerDay':
      return isUnlimited
        ? 'unlimited daily AI evaluations'
        : `${limit} daily AI evaluation${limit === 1 ? '' : 's'}`;
    case 'storageGB':
      return isUnlimited ? 'unlimited storage' : `${limit} GB of storage`;
    default:
      return isUnlimited ? 'unlimited usage' : `${limit}`;
  }
};

type QuotaUpgradeNoticeProps = {
  plan: PlanId;
  quota: { key: QuotaKey; used: number } | null;
  evaluation: ReturnType<typeof evaluateQuota> | null;
  onUpgrade: () => void;
};

function QuotaUpgradeNotice({ plan, quota, evaluation, onUpgrade }: QuotaUpgradeNoticeProps) {
  if (!quota || !evaluation || !evaluation.exceeded) return null;
  const copy = quotaCopy[quota.key];
  const limitText = evaluation.isUnlimited ? 'unlimited' : evaluation.limit;
  const currentPlanLabel = formatPlanLabel(plan);
  const nextPlanId = nextPlanForQuota(plan, quota.key);
  const nextPlanLimit = nextPlanId ? evaluateQuota(nextPlanId, quota.key, 0).limit : null;
  const nextPlanCopy =
    nextPlanId && nextPlanLimit !== null
      ? ` ${formatPlanLabel(nextPlanId)} unlocks ${quotaLimitText(quota.key, nextPlanLimit)}.`
      : '';

  return (
    <section className="rounded-ds-xl border border-destructive/40 bg-destructive/10 p-5">
      <div className="flex flex-col gap-4 md:flex-row md:items-center md:justify-between">
        <div>
          <h2 className="text-base font-semibold text-destructive">{copy.title}</h2>
          <p className="mt-1 text-sm text-muted-foreground">
            You have used {quota.used} of {limitText} available today on the {currentPlanLabel} plan. {copy.helper}
            {nextPlanCopy}
          </p>
        </div>
        <Button size="sm" variant="primary" onClick={onUpgrade}>
          Upgrade plan
        </Button>
      </div>
    </section>
  );
}

type ReferralVariantSlotProps = { source?: string };

function ReferralVariantSlot({ source = 'writing-results' }: ReferralVariantSlotProps) {
  const trackConversion = useVariantConversion();

  const handleCodeGenerated = useCallback(
    (code: string) => {
      void trackConversion({ action: 'referral-code', codeLength: code.length });
    },
    [trackConversion],
  );

  const handleShare = useCallback(
    (mode: 'copy' | 'share' | 'error') => {
      if (mode === 'error') return;
      void trackConversion({ action: 'referral-share', method: mode });
    },
    [trackConversion],
  );

  return (
    <ReferralCard
      className="mt-6"
      source={source}
      onCodeGenerated={handleCodeGenerated}
      onShare={handleShare}
    />
  );
}

const WritingResultsPage: React.FC<PageProps> = ({
  plan,
  featureFlags,
  attemptId,
  results,
  averageBand,
  highlight,
  progressPoints,
  progressDeltas,
  xp,
  quota,
  referralCode,
}) => {
  const [shareStatus, setShareStatus] = useState<'idle' | 'copied' | 'shared' | 'error'>('idle');
  const [upgradeOpen, setUpgradeOpen] = useState(false);
  const { isInstalled } = useInstalledApp();
  const { promptEvent, clearPrompt } = useInstallPrompt();
  const [sheetOpen, setSheetOpen] = useState(false);
  const [installDismissed, setInstallDismissed] = useState(false);
  const [pushDismissed, setPushDismissed] = useState(false);
  const [pushStatus, setPushStatus] = useState<NotificationPermission>(() => {
    if (typeof window === 'undefined' || typeof Notification === 'undefined') return 'default';
    return Notification.permission;
  });

  useEffect(() => {
    if (typeof window === 'undefined' || typeof Notification === 'undefined') return;
    setPushStatus(Notification.permission);
  }, []);

  const supportsPush = typeof window !== 'undefined' && typeof Notification !== 'undefined';

  const shouldShowInstall = useMemo(() => {
    if (!planAllows(plan, 'writing.install.prompt')) return false;
    if (isInstalled || installDismissed) return false;
    return Boolean(promptEvent);
  }, [installDismissed, isInstalled, plan, promptEvent]);

  const shouldShowPush = useMemo(() => {
    if (!planAllows(plan, 'writing.push.optin')) return false;
    if (!supportsPush) return false;
    if (pushStatus === 'granted' || pushDismissed) return false;
    return true;
  }, [plan, pushDismissed, pushStatus, supportsPush]);

  const hasEngagementPrompts = shouldShowInstall || shouldShowPush;

  useEffect(() => {
    if (!hasEngagementPrompts) {
      setSheetOpen(false);
    }
  }, [hasEngagementPrompts]);

  const handleInstallComplete = (outcome: 'accepted' | 'dismissed') => {
    setInstallDismissed(true);
    clearPrompt();
    if (outcome === 'accepted') {
      setSheetOpen(false);
    }
  };

  const handlePushGranted = () => {
    setPushStatus('granted');
    setSheetOpen(false);
  };

  const handlePushDismiss = () => {
    setPushDismissed(true);
  };

  const quotaEvaluation = useMemo(() => {
    if (!quota) return null;
    return evaluateQuota(plan, quota.key, quota.used);
  }, [plan, quota?.key, quota?.used]);

  const paywallTrackedRef = useRef(false);
  useEffect(() => {
    if (!quota || !quotaEvaluation?.exceeded || paywallTrackedRef.current) return;
    paywallTrackedRef.current = true;
    track('paywall_view', { source: 'writing_results', quota: quota.key, plan });
  }, [plan, quota, quotaEvaluation?.exceeded]);

  useEffect(() => {
    logWritingCoachEntry({ attemptId, tasks: results.length, averageBand });
    logWritingResultsView({ attemptId, tasks: results.length, averageBand });
  }, [attemptId, results.length, averageBand]);

  const shareLabel = useMemo(() => {
    if (shareStatus === 'copied') return 'Link copied!';
    if (shareStatus === 'shared') return 'Shared â€” nice!';
    if (shareStatus === 'error') return 'Sharing unavailable';
    return 'Share results';
  }, [shareStatus]);

  const shareFeedback = useMemo(() => {
    if (shareStatus === 'copied') return 'Share link copied to clipboard';
    if (shareStatus === 'shared') return 'Shared successfully';
    if (shareStatus === 'error') return 'Sharing failed';
    return 'Ready to share';
  }, [shareStatus]);

  const handleShare = useCallback(async () => {
    const shareText = `I just logged a band ${averageBand.toFixed(1)} IELTS writing mock on GramorX!`;
    const shareUrl =
      typeof window !== 'undefined'
        ? `${window.location.origin}/writing/mock/${attemptId}/results`
        : 'https://gramorx.com/writing/mock';

    try {
      if (typeof navigator !== 'undefined' && navigator.share) {
        await navigator.share({
          title: 'GramorX Writing Results',
          text: shareText,
          url: shareUrl,
        });
        setShareStatus('shared');
        logWritingResultsShare({ attemptId, method: 'web-share', status: 'shared' });
        return;
      }

      if (typeof navigator !== 'undefined' && navigator.clipboard) {
        await navigator.clipboard.writeText(shareUrl);
        setShareStatus('copied');
        logWritingResultsShare({ attemptId, method: 'clipboard', status: 'copied' });
        return;
      }

      throw new Error('Sharing not supported');
    } catch (error) {
      console.warn('[writing/results] share failed', error);
      setShareStatus('error');
      logWritingResultsShare({ attemptId, method: 'fallback', status: 'error' });
    }
  }, [attemptId, averageBand]);

  const handleAnalyticsClick = useCallback(() => {
    logWritingResultsAnalyticsClick({ attemptId });
  }, [attemptId]);

  const openUpgrade = useCallback(() => setUpgradeOpen(true), []);
  const closeUpgrade = useCallback(() => setUpgradeOpen(false), []);

  const referralVariant = (
    <Variant
      experiment="writing_results_referral"
      context={{ plan, attemptId, quota: quota?.key ?? null }}
      fallback={null}
      variants={{
        control: null,
        referral: <ReferralVariantSlot source="writing-results" />,
      }}
    />
  );

  return (
    <Container className="py-12">
      {quota ? (
        <UpgradeDialog
          open={upgradeOpen}
          onClose={closeUpgrade}
          plan={plan}
          quota={quota}
          referralCode={referralCode ?? undefined}
          source="writing-results"
        />
      ) : null}
      <div className="mx-auto flex max-w-4xl flex-col gap-8">
        <header className="flex flex-col gap-3">
          <h1 className="text-3xl font-semibold text-foreground">Mock writing results</h1>
          <p className="text-sm text-muted-foreground">Attempt ID: {attemptId}</p>
          <div className="flex flex-wrap items-center gap-3 text-sm text-muted-foreground">
            <span className="rounded-full border border-border px-3 py-1 font-medium text-foreground">
              Average band {averageBand.toFixed(1)}
            </span>
            <Badge variant="success" size="sm">
              +{xp.points} XP
            </Badge>
            <Link href={`/writing/mock/${attemptId}/review`}>
              <Button size="sm" variant="secondary">
                Detailed review
              </Button>
            </Link>
          </div>
          <div className="flex flex-wrap items-center gap-3">
            <Button size="sm" variant="primary" onClick={handleShare} aria-describedby="share-status">
              {shareLabel}
            </Button>
            <span id="share-status" className="sr-only" aria-live="polite">
              {shareFeedback}
            </span>
            {featureFlags.writingExports ? (
              <ExportButton attemptId={attemptId} />
            ) : null}
            {featureFlags.writingCertificates ? (
              <Button
                size="sm"
                variant="outline"
                onClick={() => {
                  track('cert.view', { attemptId, plan });
                  window.open(`/cert/writing/${attemptId}`, '_blank');
                }}
              >
                Certificate
              </Button>
            ) : null}
            <Link href="/analytics/writing" onClick={handleAnalyticsClick} className="inline-flex">
              <Button size="sm" variant="secondary">
                Open analytics
              </Button>
            </Link>
          </div>
        </header>

        {hasEngagementPrompts ? (
          <div className="hidden gap-4 md:grid md:grid-cols-2">
            {shouldShowInstall ? (
              <InstallBanner promptEvent={promptEvent} onComplete={handleInstallComplete} onDismiss={handleInstallComplete} />
            ) : null}
            {shouldShowPush ? (
              <PushOptInCard onGranted={handlePushGranted} onDismiss={handlePushDismiss} />
            ) : null}
          </div>
        ) : null}

        {hasEngagementPrompts ? (
          <div className="flex justify-center md:hidden">
            <Button size="lg" variant="secondary" onClick={() => setSheetOpen(true)}>
              Stay connected
            </Button>
          </div>
        ) : null}

        {xp.achievements.length > 0 ? (
          <section className="rounded-ds-xl border border-border/60 bg-muted/20 p-5">
            <div className="flex flex-wrap items-center justify-between gap-3">
              <h2 className="text-base font-semibold text-foreground">Achievements unlocked</h2>
              <Badge variant="success" size="sm">
                +{xp.points} XP total
              </Badge>
            </div>
            <div className="mt-4 grid gap-3 md:grid-cols-2">
              {xp.achievements.map((achievement) => (
                <div
                  key={`${achievement.id}-${achievement.label}`}
                  className="rounded-lg border border-border/50 bg-background/80 p-4 shadow-sm"
                >
                  <div className="flex items-baseline justify-between gap-2">
                    <p className="text-sm font-medium text-foreground">{achievement.label}</p>
                    <span className="text-sm font-semibold text-primary">+{achievement.points} XP</span>
                  </div>
                  {achievement.description ? (
                    <p className="mt-1 text-xs text-muted-foreground">{achievement.description}</p>
                  ) : null}
                </div>
              ))}
            </div>
          </section>
        ) : null}

        <AccessibilityHints />

        {results.length === 0 ? (
          <p className="text-sm text-muted-foreground">Scores are still processing. Refresh this page in a few seconds.</p>
        ) : (
          results.map((result) => (
            <WritingResultCard key={result.task} task={result.task} result={result.score} essay={result.essay} />
          ))
        )}

        {highlight ? (
          <BandDiffView essay={highlight.essay} feedback={highlight.feedback} />
        ) : (
          <div className="rounded-ds-xl border border-border/60 bg-muted/30 p-6 text-sm text-muted-foreground">
            Detailed highlights will appear once AI feedback is ready.
          </div>
        )}

        <BandProgressChart points={progressPoints} deltas={progressDeltas} />

        <QuotaUpgradeNotice plan={plan} quota={quota} evaluation={quotaEvaluation} onUpgrade={openUpgrade} />

        {referralVariant}

        <section className="space-y-4">
          <h2 className="text-lg font-semibold text-foreground">Need a next step?</h2>
          <p className="text-sm text-muted-foreground">
            Chat with the AI writing coach to plan rewrites, upgrade paragraphs, or build lexical drills using this attempt.
          </p>
          <CoachDock attemptId={attemptId} />
        </section>
      </div>

      <KeyboardAwareSheet
        open={sheetOpen && hasEngagementPrompts}
        title="Stay connected"
        description="Install the app or enable notifications to follow your progress on the go."
        onClose={() => setSheetOpen(false)}
      >
        {shouldShowInstall ? (
          <InstallBanner promptEvent={promptEvent} onComplete={handleInstallComplete} onDismiss={handleInstallComplete} />
        ) : null}
        {shouldShowPush ? (
          <PushOptInCard onGranted={handlePushGranted} onDismiss={handlePushDismiss} />
        ) : null}
      </KeyboardAwareSheet>
    </Container>
  );
};

export const getServerSideProps: GetServerSideProps<PageProps> = async (ctx) => {
  const supabase = getServerClient(ctx.req as any, ctx.res as any);
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return {
      redirect: {
        destination: '/welcome',
        permanent: false,
      },
    };
  }

  const { mockId: attemptId } = ctx.params as { mockId: string };

  const { data: attempt, error } = await supabase
    .from('exam_attempts')
    .select('*')
    .eq('id', attemptId)
    .maybeSingle();

  if (error || !attempt || attempt.user_id !== user.id) {
    return { notFound: true };
  }

  const { data: profileRow } = await supabase
    .from('profiles')
    .select('plan, role')
    .eq('id', user.id)
    .maybeSingle();

  const plan = (profileRow?.plan as PlanId | undefined) ?? 'free';
  const role = (profileRow?.role as string | null) ?? null;

  const todayStart = new Date();
  todayStart.setUTCHours(0, 0, 0, 0);
  const todayIso = todayStart.toISOString();

  const [{ count: dailyMocksCount }, { count: aiEvaluationsCount }] = await Promise.all([
    supabase
      .from('exam_attempts')
      .select('id', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .eq('exam_type', 'writing')
      .gte('started_at', todayIso),
    supabase
      .from('writing_responses')
      .select('id', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .gte('created_at', todayIso),
  ]);

  const quotaCandidates: Array<{ key: QuotaKey; used: number }> = [
    { key: 'dailyMocks', used: dailyMocksCount ?? 0 },
    { key: 'aiEvaluationsPerDay', used: aiEvaluationsCount ?? 0 },
    { key: 'storageGB', used: 0 },
  ];

  const quotaHit =
    quotaCandidates.find((candidate) => evaluateQuota(plan, candidate.key, candidate.used).exceeded) ?? null;

  const flagSnapshot = await resolveFlags({ plan, role, userId: user.id });

  const { data: responses } = await supabase
    .from('writing_responses')
    .select('id, task, answer_text, word_count, overall_band, band_scores, feedback, duration_seconds, evaluation_version, submitted_at, created_at')
    .eq('exam_attempt_id', attemptId);

  const responseIds = (responses ?? []).map((row) => row.id).filter(Boolean);
  const { data: feedbackRows } = responseIds.length
    ? await supabase
        .from('writing_feedback')
        .select('attempt_id, band9_rewrite, errors, blocks')
        .in('attempt_id', responseIds as string[])
    : { data: [] };

  const scores = (responses ?? [])
    .filter((row) => row.task === 'task1' || row.task === 'task2')
    .map((row) => ({
      task: row.task as WritingTaskType,
      essay: row.answer_text ?? '',
      score: {
        version: (row.evaluation_version as string) ?? 'baseline-v1',
        overallBand: row.overall_band ?? 0,
        bandScores: (row.band_scores as any) ?? {
          task_response: 0,
          coherence_and_cohesion: 0,
          lexical_resource: 0,
          grammatical_range: 0,
        },
        feedback:
          (row.feedback as any) ?? {
            summary: 'No feedback recorded yet.',
            strengths: [],
            improvements: [],
            perCriterion: {
              task_response: { band: 0, feedback: '' },
              coherence_and_cohesion: { band: 0, feedback: '' },
              lexical_resource: { band: 0, feedback: '' },
              grammatical_range: { band: 0, feedback: '' },
            },
          },
        wordCount: row.word_count ?? 0,
        durationSeconds: row.duration_seconds ?? undefined,
        tokensUsed: undefined,
      } satisfies WritingScorePayload,
      id: row.id as string,
    }));

  const summary = computeWritingSummary(
    scores.map((entry) => ({
      id: `${attemptId}-${entry.task}`,
      attemptId,
      examAttemptId: attemptId,
      promptId: undefined,
      task: entry.task,
      answerText: entry.essay,
      wordCount: entry.score.wordCount,
      overallBand: entry.score.overallBand,
      bandScores: entry.score.bandScores,
      feedback: entry.score.feedback,
      durationSeconds: entry.score.durationSeconds,
      evaluationVersion: entry.score.version,
      tokensUsed: entry.score.tokensUsed,
      createdAt: attempt.created_at,
      submittedAt: attempt.submitted_at ?? attempt.updated_at ?? attempt.created_at,
      metadata: null,
    })),
  );

  const progress = await loadProgress(supabase, user.id, attemptId);

  const sortedPoints = [...progress.points].sort(
    (a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime(),
  );
  const currentPoint = sortedPoints.find((point) => point.attemptId === attemptId) ?? null;
  const previousPoint = sortedPoints.filter((point) => point.attemptId !== attemptId).pop() ?? null;

  const xpSummary = calculateWritingXp({
    currentOverall: currentPoint?.overallBand ?? summary.averageBand ?? 0,
    previousOverall: previousPoint?.overallBand ?? null,
    submittedAt: attempt.submitted_at ?? attempt.updated_at ?? attempt.created_at ?? null,
    startedAt: attempt.started_at ?? attempt.created_at ?? null,
    durationSeconds: attempt.duration_seconds ?? null,
  });

  const referralCode = typeof ctx.query.code === 'string' ? ctx.query.code : null;

  return {
    props: {
      plan,
      featureFlags: {
        writingExports: Boolean(flagSnapshot.writingExports),
        writingCertificates: Boolean(flagSnapshot.writingCertificates),
      },
      attemptId,
      results: scores.map(({ id: _id, ...rest }) => rest),
      averageBand: summary.averageBand || 0,
      highlight:
        scores.length > 0
          ? (() => {
              const primary = scores.find((entry) => entry.task === 'task2') ?? scores[0];
              const feedbackRow = feedbackRows?.find((row) => row.attempt_id === primary.id);
              const combinedFeedback: WritingFeedback = {
                ...primary.score.feedback,
                band9Rewrite: feedbackRow?.band9_rewrite ?? primary.score.feedback.band9Rewrite,
                errors: (feedbackRow?.errors as WritingFeedback['errors']) ?? primary.score.feedback.errors,
                blocks: (feedbackRow?.blocks as WritingFeedback['blocks']) ?? primary.score.feedback.blocks,
              };
              return {
                task: primary.task,
                essay: primary.essay,
                feedback: combinedFeedback,
              } satisfies HighlightSection;
            })()
          : null,
      progressPoints: progress.points,
      progressDeltas: progress.deltas,
      xp: {
        points: xpSummary.points,
        reason: xpSummary.reason,
        achievements: xpSummary.achievements,
        improvement: xpSummary.improvement,
        durationSeconds: xpSummary.effectiveDuration,
      },
      quota: quotaHit,
      referralCode,
    },
  };
};

async function loadProgress(
  supabase: ReturnType<typeof getServerClient>,
  userId: string,
  currentAttemptId: string,
) {
  const { data: rows } = await supabase
    .from('writing_responses')
    .select('exam_attempt_id, overall_band, band_scores, submitted_at, created_at')
    .eq('user_id', userId)
    .order('submitted_at', { ascending: false })
    .limit(10);

  const attempts = new Map<string, { total: number; count: number; createdAt: string } & WritingProgressPoint>();

  for (const row of rows ?? []) {
    const examId = row.exam_attempt_id as string | null;
    if (!examId) continue;
    const point =
      attempts.get(examId) ?? {
        attemptId: examId,
        createdAt: row.submitted_at ?? row.created_at ?? new Date().toISOString(),
        overallBand: 0,
        bandScores: {
          task_response: 0,
          coherence_and_cohesion: 0,
          lexical_resource: 0,
          grammatical_range: 0,
        },
        total: 0,
        count: 0,
      };
    point.total += Number(row.overall_band ?? 0);
    point.count += 1;
    const bands = (row.band_scores as Record<string, number> | null) ?? {};
    point.bandScores.task_response += Number(bands.task_response ?? 0);
    point.bandScores.coherence_and_cohesion += Number(bands.coherence_and_cohesion ?? 0);
    point.bandScores.lexical_resource += Number(bands.lexical_resource ?? 0);
    point.bandScores.grammatical_range += Number(bands.grammatical_range ?? 0);
    attempts.set(examId, point);
  }

  const rawPoints: WritingProgressPoint[] = Array.from(attempts.values()).map((point) => {
    const divisor = point.count === 0 ? 1 : point.count;
    return {
      attemptId: point.attemptId,
      createdAt: point.createdAt,
      overallBand: Number((point.total / divisor).toFixed(1)),
      bandScores: {
        task_response: Number((point.bandScores.task_response / divisor).toFixed(1)),
        coherence_and_cohesion: Number((point.bandScores.coherence_and_cohesion / divisor).toFixed(1)),
        lexical_resource: Number((point.bandScores.lexical_resource / divisor).toFixed(1)),
        grammatical_range: Number((point.bandScores.grammatical_range / divisor).toFixed(1)),
      },
    };
  });

  const trimmed = trimProgressPoints(rawPoints, 3);
  const deltas = computeCriterionDeltas(trimmed);

  if (!trimmed.find((point) => point.attemptId === currentAttemptId)) {
    const current = rawPoints.find((point) => point.attemptId === currentAttemptId);
    if (current) {
      trimmed.push(current);
    }
  }

  return { points: trimProgressPoints(trimmed, 3), deltas };
}

export default WritingResultsPage;





============================================================
FILE #19
PATH: pages/api/writing/score/run.ts
============================================================
import type { NextApiRequest, NextApiResponse } from 'next';
import { z } from 'zod';

import { getClientIp, getRequestId } from '@/lib/api/requestContext';
import { trackor } from '@/lib/analytics/trackor.server';
import { createRequestLogger } from '@/lib/obs/logger';
import { rateLimit } from '@/lib/rateLimit';
import { getServerClient } from '@/lib/supabaseServer';
import { FeedbackJson, ScoresJson } from '@/lib/writing/schemas';
import { queueNotificationEvent, getNotificationContact } from '@/lib/notify';
import { getBaseUrl } from '@/lib/url';

const Body = z.object({
  attemptId: z.string().uuid(),
  scores: ScoresJson,
  feedback: FeedbackJson.optional(),
});

type Data = { ok: true } | { error: string; details?: unknown };

export default async function handler(req: NextApiRequest, res: NextApiResponse<Data>) {
  if (req.method !== 'POST') {
    res.setHeader('Allow', 'POST');
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const requestId = getRequestId(req);
  const clientIp = getClientIp(req);
  const logger = createRequestLogger('api/writing/score/run', { requestId, clientIp });

  if (!(await rateLimit(req, res))) {
    logger.warn('rate limit triggered on scoring');
    return;
  }

  const parsed = Body.safeParse(req.body);
  if (!parsed.success) {
    logger.warn('invalid scoring payload', { issues: parsed.error.flatten() });
    return res.status(400).json({ error: 'Invalid body', details: parsed.error.flatten() });
  }

  const supabase = getServerClient(req, res);
  const { attemptId, scores, feedback } = parsed.data;

  const { data: attemptRow, error: loadError } = await supabase
    .from('writing_attempts')
    .select('status, user_id')
    .eq('id', attemptId)
    .maybeSingle();

  if (loadError) {
    logger.error('failed to load attempt for scoring', { error: loadError.message, attemptId });
    return res.status(500).json({ error: loadError.message });
  }

  if (!attemptRow) {
    logger.warn('attempt not found for scoring', { attemptId });
    return res.status(404).json({ error: 'Attempt not found' });
  }

  if (attemptRow.status === 'scored') {
    logger.info('scoring skipped because attempt already scored', { attemptId });
    return res.status(200).json({ ok: true });
  }

  const { error } = await supabase
    .from('writing_attempts')
    .update({
      status: 'scored',
      overall_band: scores.overall,
      scores_json: scores,
      feedback_json: feedback ?? null,
    })
    .eq('id', attemptId)
    .eq('status', 'submitted');

  if (error) {
    logger.error('failed to persist scoring payload', { error: error.message, attemptId });
    return res.status(500).json({ error: error.message });
  }

  logger.info('attempt scored', { attemptId, overall: scores.overall });
  await trackor.log('writing_attempt_scored', {
    attempt_id: attemptId,
    user_id: attemptRow.user_id ?? null,
    overall_band: scores.overall,
    request_id: requestId,
    ip: clientIp,
  });

  if (attemptRow.user_id) {
    const contact = await getNotificationContact(attemptRow.user_id);
    if (contact.email) {
      const baseUrl = getBaseUrl();
      const payload: Record<string, unknown> = {
        module: 'Writing',
        band: scores.overall,
        deep_link: `${baseUrl}/writing/results/${attemptId}`,
        user_email: contact.email,
      };
      if (contact.phone) {
        payload.user_phone = contact.phone;
      }

      const result = await queueNotificationEvent({
        event_key: 'score_ready',
        user_id: attemptRow.user_id,
        payload,
        channels: ['email'],
        idempotency_key: `writing_score:${attemptId}`,
      });

      if (!result.ok && result.reason !== 'duplicate') {
        logger.error('failed to enqueue score notification', {
          attemptId,
          userId: attemptRow.user_id,
          error: result.message,
        });
      }
    } else {
      logger.warn('skipping score notification because email is missing', {
        attemptId,
        userId: attemptRow.user_id,
      });
    }
  }

  return res.status(200).json({ ok: true });
}





============================================================
FILE #20
PATH: components/navigation/constants.tsx
============================================================
// File: components/navigation/constants.tsx
import type { IconName } from '@/components/design-system/Icon';
import { Icon as DSIcon } from '@/components/design-system/Icon';
import type * as React from 'react';
import { flags } from '@/lib/flags';

// Keep consumer compatibility: expose a React component under `Icon`
type IconComponent = React.FC<React.SVGProps<SVGSVGElement>>;
const withName = (name: IconName): IconComponent => {
  const NamedIcon = (props) => <DSIcon name={name} {...props} />;
  NamedIcon.displayName = `Icon(${name})`;
  return NamedIcon;
};

export type ModuleLink = {
  label: string;
  href: string;
  desc?: string;
  /** DS Icon component wrapper so existing callers can do <Item.Icon /> */
  Icon?: IconComponent;
  badge?: string;
  tone?: 'purple' | 'blue' | 'orange' | 'green';
  kbd?: string;
};

export const MODULE_LINKS: ModuleLink[] = [
  { label: 'Listening', href: '/listening', desc: 'Audio comprehension drills', Icon: withName('Headphones'), badge: 'AI', tone: 'blue',   kbd: 'L' },
  { label: 'Reading',   href: '/reading',   desc: 'Short passages & skimming', Icon: withName('BookOpen'),                        tone: 'purple', kbd: 'R' },
  { label: 'Writing',   href: '/writing',   desc: 'Prompts, structure & style', Icon: withName('PenSquare'),                      tone: 'orange', kbd: 'W' },
  { label: 'Speaking',  href: '/speaking',  desc: 'Pronunciation & fluency',   Icon: withName('MicVocal'),                        tone: 'green',  kbd: 'S' },
];

export const NAV: ReadonlyArray<{ href: string; label: string }> = [
  { href: '/predictor', label: 'Band Predictor' },
  { href: '/pricing',   label: 'Pricing' },
];

const baseUserMenuLinks: { id: string; href: string; label: string }[] = [
  { id: 'account',   href: '/account',           label: 'Account' },
  { id: 'saved',     href: '/saved',             label: 'Saved items' },
  { id: 'settings',  href: '/settings',          label: 'Settings' },
  { id: 'billing',   href: '/account/billing',   label: 'Billing' },
  { id: 'referrals', href: '/account/referrals', label: 'Referrals' },
];

if (flags.enabled('notifications')) {
  baseUserMenuLinks.splice(3, 0, { id: 'notifications', href: '/notifications', label: 'Notifications' });
}

export const USER_MENU_LINKS: ReadonlyArray<{ id: string; href: string; label: string }> = baseUserMenuLinks;




============================================================
FILE #21
PATH: components/notifications/NotificationPreferencesPanel.tsx
============================================================
'use client';

import { useCallback, useEffect, useMemo, useState } from 'react';

import { Button } from '@/components/design-system/Button';
import { Input } from '@/components/design-system/Input';
import { Toggle } from '@/components/design-system/Toggle';
import { useToast } from '@/components/design-system/Toaster';
import {
  NotificationPreferencesSchema,
  type NotificationPreferences,
  type UpdateNotificationPreferences,
} from '@/lib/schemas/notifications';

function isE164(value: string) {
  return /^\+[1-9]\d{1,14}$/.test(value);
}

type OtpStage = 'idle' | 'sending' | 'code' | 'verifying' | 'verified';

export function NotificationPreferencesPanel() {
  const toast = useToast();
  const [loading, setLoading] = useState(true);
  const [prefs, setPrefs] = useState<NotificationPreferences | null>(null);
  const [emailSaving, setEmailSaving] = useState(false);
  const [whatsappSaving, setWhatsappSaving] = useState(false);
  const [phoneInput, setPhoneInput] = useState('');
  const [otpCode, setOtpCode] = useState('');
  const [otpStage, setOtpStage] = useState<OtpStage>('idle');
  const [otpError, setOtpError] = useState<string | null>(null);

  const fetchPreferences = useCallback(async () => {
    try {
      setLoading(true);
      const res = await fetch('/api/notifications/preferences');
      const json = await res.json();
      if (!res.ok) {
        throw new Error(json?.error ?? 'Failed to load preferences');
      }
      const parsed = NotificationPreferencesSchema.parse(json.preferences);
      setPrefs(parsed);
      if (parsed.phone) {
        setPhoneInput(parsed.phone);
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Failed to load preferences';
      toast.error(message);
    } finally {
      setLoading(false);
    }
  }, [toast]);

  useEffect(() => {
    void fetchPreferences();
  }, [fetchPreferences]);

  const updatePreferences = useCallback(
    async (payload: Partial<UpdateNotificationPreferences>) => {
      const res = await fetch('/api/notifications/preferences', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      const json = await res.json();
      if (!res.ok) {
        throw new Error(json?.error ?? 'Failed to update preferences');
      }
      const parsed = NotificationPreferencesSchema.parse(json.preferences);
      setPrefs(parsed);
      return parsed;
    },
    [],
  );

  const handleEmailToggle = useCallback(
    async (checked: boolean) => {
      setEmailSaving(true);
      try {
        const next = await updatePreferences({ emailOptIn: checked });
        toast.success(checked ? 'Email updates enabled' : 'Email updates disabled');
        setPrefs(next);
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Could not update email preference';
        toast.error(message);
      } finally {
        setEmailSaving(false);
      }
    },
    [toast, updatePreferences],
  );

  const handleWhatsAppToggle = useCallback(
    async (checked: boolean) => {
      if (!prefs) return;
      if (checked && !prefs.phoneVerified) {
        setOtpError('Verify your WhatsApp number to enable task reminders.');
        return;
      }
      setWhatsappSaving(true);
      try {
        const next = await updatePreferences({ whatsappOptIn: checked });
        toast.success(checked ? 'WhatsApp tasks enabled' : 'WhatsApp tasks disabled');
        setPrefs(next);
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Could not update WhatsApp preference';
        toast.error(message);
      } finally {
        setWhatsappSaving(false);
      }
    },
    [prefs, toast, updatePreferences],
  );

  const requestOtp = useCallback(async () => {
    if (!phoneInput) {
      setOtpError('Enter a WhatsApp number in E.164 format.');
      return;
    }
    if (!isE164(phoneInput)) {
      setOtpError('Use the E.164 format (+923001234567).');
      return;
    }

    setOtpError(null);
    setOtpStage('sending');
    try {
      const res = await fetch('/api/send-otp', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ phone: phoneInput, channel: 'whatsapp' }),
      });
      const json = await res.json();
      if (!res.ok || !json?.ok) {
        throw new Error(json?.error ?? 'Unable to send code');
      }
      setOtpStage('code');
      toast.success('We sent a verification code to your WhatsApp.');
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Unable to send code';
      setOtpStage('idle');
      setOtpError(message);
    }
  }, [phoneInput, toast]);

  const verifyOtp = useCallback(
    async (event: React.FormEvent<HTMLFormElement>) => {
      event.preventDefault();
      if (!isE164(phoneInput)) {
        setOtpError('Use the E.164 format (+923001234567).');
        return;
      }
      if (!otpCode) {
        setOtpError('Enter the verification code.');
        return;
      }

      setOtpStage('verifying');
      setOtpError(null);
      try {
        const res = await fetch('/api/check-otp', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ phone: phoneInput, code: otpCode }),
        });
        const json = await res.json();
        if (!res.ok || !json?.ok) {
          throw new Error(json?.error ?? 'Invalid verification code');
        }

        const next = await updatePreferences({
          phone: phoneInput,
          phoneVerified: true,
          whatsappOptIn: true,
          sendTest: true,
        });
        setPrefs(next);
        setOtpStage('verified');
        setOtpCode('');
        toast.success('WhatsApp verified. Look for a test task shortly!');
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Verification failed';
        setOtpStage('code');
        setOtpError(message);
      }
    },
    [otpCode, phoneInput, toast, updatePreferences],
  );

  useEffect(() => {
    if (prefs?.phone && phoneInput === '' && otpStage === 'idle') {
      setPhoneInput(prefs.phone);
    }
  }, [otpStage, phoneInput, prefs?.phone]);

  const whatsappDisabled = useMemo(() => loading || whatsappSaving, [loading, whatsappSaving]);

  return (
    <div className="rounded-ds-xl border border-border/60 bg-surface p-5 shadow-xs">
      <div className="space-y-1">
        <h2 className="font-slab text-h4">Preferences</h2>
        <p className="text-small text-mutedText">Choose how GramorX reaches you with reminders and updates.</p>
      </div>

      {loading ? (
        <div className="mt-6 space-y-4">
          <div className="h-6 w-40 animate-pulse rounded-md bg-muted/60" aria-hidden />
          <div className="h-32 animate-pulse rounded-ds-xl bg-muted/40" aria-hidden />
        </div>
      ) : prefs ? (
        <div className="mt-6 space-y-6">
          <Toggle
            checked={prefs.emailOptIn}
            onChange={(checked) => void handleEmailToggle(checked)}
            label="Email updates"
            hint={prefs.email ? `Weâ€™ll use ${prefs.email}` : 'Add an email in your profile to receive updates.'}
            disabled={emailSaving}
          />

          <div className="rounded-ds-xl border border-border/60 bg-background/60 p-4 dark:bg-dark/40">
            <div className="flex flex-col gap-3 sm:flex-row sm:items-start sm:justify-between">
              <div className="space-y-1">
                <p className="font-medium">WhatsApp task nudges</p>
                <p className="text-small text-mutedText">
                  Verify your WhatsApp number to get daily study tasks and reminders.
                </p>
              </div>
              <Toggle
                checked={prefs.whatsappOptIn && prefs.phoneVerified}
                onChange={(checked) => void handleWhatsAppToggle(checked)}
                disabled={whatsappDisabled || !prefs.phoneVerified}
              />
            </div>

            <div className="mt-4 space-y-4">
              <Input
                label="WhatsApp number"
                placeholder="+923001234567"
                value={phoneInput}
                onChange={(event) => setPhoneInput(event.target.value)}
                disabled={otpStage === 'sending' || otpStage === 'verifying'}
                error={otpError ?? undefined}
              />

              {otpStage !== 'verified' && (
                <div className="flex flex-col gap-3 sm:flex-row sm:items-center">
                  <Button
                    type="button"
                    variant="primary"
                    className="rounded-ds-xl"
                    onClick={() => void requestOtp()}
                    disabled={otpStage === 'sending' || otpStage === 'verifying'}
                  >
                    {otpStage === 'sending' ? 'Sendingâ€¦' : 'Send verification code'}
                  </Button>
                  {prefs.phoneVerified ? (
                    <span className="text-small text-success">Number verified</span>
                  ) : (
                    <span className="text-small text-mutedText">
                      Weâ€™ll send a 6-digit code via WhatsApp. Standard messaging rates apply.
                    </span>
                  )}
                </div>
              )}

              {(otpStage === 'code' || otpStage === 'verifying') && (
                <form onSubmit={verifyOtp} className="grid gap-3 sm:grid-cols-[1fr_auto] sm:items-end">
                  <Input
                    label="Verification code"
                    placeholder="123456"
                    value={otpCode}
                    onChange={(event) => setOtpCode(event.target.value)}
                    disabled={otpStage === 'verifying'}
                  />
                  <Button
                    type="submit"
                    variant="primary"
                    className="rounded-ds-xl"
                    disabled={otpStage === 'verifying'}
                  >
                    {otpStage === 'verifying' ? 'Verifyingâ€¦' : 'Verify & enable'}
                  </Button>
                </form>
              )}

              {otpStage === 'verified' && (
                <p className="text-small text-success">WhatsApp verified. Tasks are now enabled.</p>
              )}
            </div>
          </div>
        </div>
      ) : (
        <p className="mt-6 text-small text-mutedText">We couldnâ€™t load your preferences right now.</p>
      )}
    </div>
  );
}

export default NotificationPreferencesPanel;





============================================================
FILE #22
PATH: components/notifications/NotificationProvider.tsx
============================================================
import React, { createContext, useCallback, useContext, useEffect, useState } from 'react';
import { supabase } from '@/lib/supabaseClient';
import { useToast } from '@/components/design-system/Toaster';
import type { AuthChangeEvent, Session } from '@supabase/supabase-js';

export type Notification = {
  id: string;
  message: string;
  url?: string | null;
  read: boolean;
  created_at: string;
};

type Ctx = {
  notifications: Notification[];
  unread: number;
  markRead: (id: string) => Promise<void>;
};

const NotificationCtx = createContext<Ctx | null>(null);

export function NotificationProvider({ children }: { children: React.ReactNode }) {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [hasSession, setHasSession] = useState(false);
  const toast = useToast();

  useEffect(() => {
    let cancelled = false;

    (async () => {
      const {
        data: { session },
      } = await supabase.auth.getSession();
      if (!cancelled) setHasSession(!!session);
    })();

    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange((_event: AuthChangeEvent, session: Session | null) => {
      setHasSession(!!session);
      if (!session) setNotifications([]);
    });

    return () => {
      subscription.unsubscribe();
      cancelled = true;
    };
  }, []);

  useEffect(() => {
    if (!hasSession) return;
    let active = true;

    const fetchNotifications = async () => {
      try {
        const { data: { session } } = await supabase.auth.getSession();
        if (!session) {
          console.warn('No session for fetching notifications');
          return;
        }
        const res = await fetch('/api/notifications', {
          headers: { Authorization: `Bearer ${session.access_token}` },
        });
        if (!res.ok) throw new Error(`HTTP error: ${res.status}`);
        const data = await res.json();
        if (!Array.isArray(data.notifications)) throw new Error('Invalid response format');
        if (active) setNotifications(data.notifications);
      } catch (error) {
        console.error('Fetch notifications error:', error);
        toast.error('Failed to load notifications');
      }
    };

    fetchNotifications();

    return () => {
      active = false;
    };
  }, [hasSession, toast]);

  useEffect(() => {
    if (!hasSession) return;

    const channel = supabase
      .channel('notifications')
      .on(
        'postgres_changes',
        { event: 'INSERT', schema: 'public', table: 'notifications' },
        (payload: { new: Notification }) => {
          const n = payload.new;
          setNotifications(prev => [n, ...prev]);
          toast.info(n.message);
        }
      )
      .subscribe((status) => {
        if (status === 'SUBSCRIPTION_ERROR') {
          toast.error('Error subscribing to notifications');
        }
      });

    return () => {
      supabase.removeChannel(channel);
    };
  }, [hasSession, toast]);

  const markRead = useCallback(async (id: string) => {
    setNotifications((prev) => prev.map((n) => (n.id === id ? { ...n, read: true } : n)));
    try {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) {
        console.warn('No session for marking notification read');
        return;
      }
      await fetch(`/api/notifications/${id}`, {
        method: 'PATCH',
        headers: { Authorization: `Bearer ${session.access_token}` },
      });
    } catch {
      /* noop */
    }
  }, []);

  const unread = notifications.filter((n) => !n.read).length;

  const value = { notifications, unread, markRead };

  return <NotificationCtx.Provider value={value}>{children}</NotificationCtx.Provider>;
}

export function useNotifications() {
  const ctx = useContext(NotificationCtx);
  if (!ctx) throw new Error('useNotifications must be used within <NotificationProvider>');
  return ctx;
}




============================================================
FILE #23
PATH: components/navigation/MobileNav.tsx
============================================================
// File: components/navigation/MobileNav.tsx
'use client';

import React, { useState, useMemo, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Link from 'next/link';
import { createPortal } from 'react-dom';
import { usePathname } from 'next/navigation';

import { Container } from '@/components/design-system/Container';
import { NavLink } from '@/components/design-system/NavLink';
import { NotificationBell } from '@/components/design-system/NotificationBell';
import { Button } from '@/components/design-system/Button';
import { Badge } from '@/components/design-system/Badge';
import { StreakChip } from '@/components/user/StreakChip';
import { IconOnlyThemeToggle } from './IconOnlyThemeToggle';
import { navigationSchema } from '@/config/navigation';
import { filterNavItems, filterNavSections } from '@/lib/navigation/utils';
import type { SubscriptionTier } from '@/lib/navigation/types';
import { Icon } from '@/components/design-system/Icon';
import type { ModuleLink } from './constants';
import { MODULE_LINKS } from './constants';

const toneClassMap: Record<NonNullable<ModuleLink['tone']>, string> = {
  blue: 'bg-muted dark:bg-muted-dark text-primary dark:text-primary-dark ring-1 ring-border dark:ring-border-dark group-hover:bg-primary dark:group-hover:bg-primary-dark group-hover:text-primary-foreground dark:group-hover:text-primary-foreground-dark',
  purple:
    'bg-muted dark:bg-muted-dark text-primary dark:text-primary-dark ring-1 ring-border dark:ring-border-dark group-hover:bg-primary dark:group-hover:bg-primary-dark group-hover:text-primary-foreground dark:group-hover:text-primary-foreground-dark',
  orange:
    'bg-muted dark:bg-muted-dark text-accent-warm dark:text-accent-warm-dark ring-1 ring-border dark:ring-border-dark group-hover:bg-accent-warm dark:group-hover:bg-accent-warm-dark group-hover:text-accent-warm-foreground dark:group-hover:text-accent-warm-foreground-dark',
  green:
    'bg-muted dark:bg-muted-dark text-success dark:text-success-dark ring-1 ring-border dark:ring-border-dark group-hover:bg-success dark:group-hover:bg-success-dark group-hover:text-success-foreground dark:group-hover:text-success-foreground-dark',
};

const getToneClass = (tone?: ModuleLink['tone']) =>
  tone
    ? toneClassMap[tone]
    : 'bg-muted dark:bg-muted-dark text-primary dark:text-primary-dark ring-1 ring-border dark:ring-border-dark group-hover:bg-primary dark:group-hover:bg-primary-dark group-hover:text-primary-foreground dark:group-hover:text-primary-foreground-dark';

interface UserInfo {
  id: string | null;
  email: string | null;
  name: string | null;
  avatarUrl: string | null;
}

type MobileNavProps = Omit<React.HTMLAttributes<HTMLDivElement>, 'role'> & {
  user: UserInfo | null;
  role: string | null;
  ready: boolean;
  streak?: number | null;
  mobileOpen: boolean;
  setMobileOpen: (open: boolean) => void;
  mobileModulesOpen: boolean;
  setMobileModulesOpen: (open: boolean) => void;
  signOut: () => Promise<void> | void;
  showAdmin?: boolean;
  hasPremiumAccess?: boolean;
  premiumRooms?: string[];
  onClearPremiumAccess?: () => void;
  subscriptionTier: SubscriptionTier;
};

export function MobileNav({
  user,
  role,
  ready,
  streak = null,
  mobileOpen,
  setMobileOpen,
  mobileModulesOpen,
  setMobileModulesOpen,
  signOut,
  showAdmin = true,
  hasPremiumAccess = false,
  premiumRooms = [],
  onClearPremiumAccess,
  subscriptionTier,
  className,
  ...rest
}: MobileNavProps) {
  const pathname = usePathname();
  const [mobileAiToolsOpen, setMobileAiToolsOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [activeSection, setActiveSection] = useState('');

  const canSeePartners = role === 'partner' || role === 'admin';
  const canSeeAdmin = role === 'admin' && showAdmin;
  const isTeacher = role === 'teacher';

  const closeMenu = React.useCallback(() => {
    setMobileOpen(false);
    setMobileModulesOpen(false);
    setMobileAiToolsOpen(false);
    setActiveSection('');
  }, [setMobileOpen, setMobileModulesOpen]);

  const navigationCtx = useMemo(
    () => ({ isAuthenticated: Boolean(user?.id), tier: subscriptionTier }),
    [user?.id, subscriptionTier]
  );

  const mainNavItems = useMemo(() => {
    if (isTeacher) return [];
    return filterNavItems(navigationSchema.header.main, navigationCtx);
  }, [navigationCtx, isTeacher]);

  const practiceNavItem = useMemo(
    () => mainNavItems.find((item) => item.id === 'practice'),
    [mainNavItems]
  );

  const mainNavWithoutPractice = useMemo(
    () => mainNavItems.filter((item) => item.id !== 'practice'),
    [mainNavItems]
  );

  const aiToolItems = useMemo(() => {
    if (isTeacher) return [];
    return filterNavItems(navigationSchema.header.aiTools, navigationCtx);
  }, [navigationCtx, isTeacher]);

  const profileMenu = useMemo(() => {
    if (isTeacher) {
      return [{ id: 'account', label: 'Profile', href: '/account' }];
    }
    return filterNavItems(navigationSchema.header.profile, navigationCtx);
  }, [isTeacher, navigationCtx]);

  const sidebarSections = useMemo(
    () => filterNavSections(navigationSchema.sidebar, navigationCtx),
    [navigationCtx]
  );

  const headerCtaConfig = navigationSchema.header.cta ?? {};
  const headerCta = user?.id ? headerCtaConfig.authed : headerCtaConfig.guest;
  const headerOptional = navigationSchema.header.optional ?? {};

  useEffect(() => {
    if (!mobileOpen) {
      setMobileModulesOpen(false);
      setMobileAiToolsOpen(false);
      setActiveSection('');
    }
  }, [mobileOpen, setMobileAiToolsOpen, setMobileModulesOpen]);

  // Auto-close on route change
  useEffect(() => {
    if (mobileOpen) closeMenu();
  }, [pathname, closeMenu]); // eslint-disable-line react-hooks/exhaustive-deps

  // Body scroll lock while open
  useEffect(() => {
    if (!mobileOpen) return;
    const prev = document.body.style.overflow;
    document.body.style.overflow = 'hidden';
    return () => {
      document.body.style.overflow = prev;
    };
  }, [mobileOpen]);

  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault();
    if (!searchQuery.trim()) return;
    setSearchQuery('');
    closeMenu();
  };

  const handleClearPremium = () => {
    onClearPremiumAccess?.();
    closeMenu();
  };

  const toggleSection = (section: string) => {
    const next = activeSection === section ? '' : section;
    setActiveSection(next);

    if (section === 'practice') {
      setMobileModulesOpen(next === 'practice');
    }
    if (section === 'aiTools') {
      setMobileAiToolsOpen(next === 'aiTools');
    }
  };

  const overlay = mobileOpen ? (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      transition={{ duration: 0.2 }}
      className="fixed inset-0 z-40 bg-background/80 dark:bg-background-dark/80 backdrop-blur-sm"
      onClick={closeMenu}
      aria-hidden="true"
    />
  ) : null;

  const panel = mobileOpen ? (
    <motion.div
      initial={{ x: '100%' }}
      animate={{ x: 0 }}
      exit={{ x: '100%' }}
      transition={{ duration: 0.3, ease: 'easeInOut' }}
      className="fixed right-0 top-0 z-50 h-full w-full max-w-sm bg-card dark:bg-card-dark shadow-2xl"
      role="dialog"
      aria-modal="true"
      aria-label="Mobile navigation"
      {...rest}
    >
      <div className="flex h-full flex-col">
        <div className="flex items-center justify-between border-b border-border dark:border-border-dark p-4">
          <motion.button
            onClick={closeMenu}
            whileTap={{ scale: 0.95 }}
            className="inline-flex h-10 w-10 items-center justify-center rounded-full hover:bg-muted dark:hover:bg-muted-dark transition-colors"
            aria-label="Close menu"
          >
            <Icon name="X" size={20} />
          </motion.button>
          {typeof streak === 'number' && streak > 0 && (
            <StreakChip value={streak} href="/profile/streak" className="shrink-0" />
          )}
        </div>

        <nav className="flex-1 overflow-y-auto p-4" aria-label="Mobile navigation">
          {/* Search */}
          <form onSubmit={handleSearch} className="mb-6">
            <div className="relative">
              <Icon
                name="Search"
                size={18}
                className="absolute left-3 top-1/2 -translate-y-1/2 text-muted-foreground dark:text-muted-foreground-dark"
                aria-hidden="true"
              />
              <input
                type="search"
                placeholder="Search..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="w-full rounded-xl border border-border dark:border-border-dark bg-surface-muted dark:bg-surface-muted-dark px-10 py-3 text-sm placeholder:text-muted-foreground dark:placeholder:text-muted-foreground-dark focus:outline-none focus:ring-2 focus:ring-primary dark:focus:ring-primary-dark"
              />
            </div>
          </form>

          {/* Main Nav */}
          <ul className="space-y-1 mb-6">
            {mainNavWithoutPractice.map((item) => (
              <li key={item.id}>
                <NavLink
                  href={item.href}
                  className="flex items-center gap-3 rounded-xl px-3 py-3 hover:bg-muted dark:hover:bg-muted-dark transition-colors"
                  onClick={closeMenu}
                >
                  <Icon name={item.icon ?? 'Circle'} size={18} />
                  <span className="font-medium">{item.label}</span>
                </NavLink>
              </li>
            ))}

            {/* Practice Section */}
            {practiceNavItem && (
              <li>
                <button
                  onClick={() => toggleSection('practice')}
                  className={`flex w-full items-center justify-between rounded-xl px-3 py-3 hover:bg-muted dark:hover:bg-muted-dark transition-colors ${
                    mobileModulesOpen ? 'bg-primary/10 dark:bg-primary-dark/10' : ''
                  }`}
                >
                  <div className="flex items-center gap-3">
                    <Icon name="Layers" size={18} />
                    <span className="font-medium">{practiceNavItem.label}</span>
                  </div>
                  <Icon
                    name={mobileModulesOpen ? 'ChevronUp' : 'ChevronDown'}
                    size={18}
                    className="opacity-70"
                  />
                </button>
                <AnimatePresence>
                  {mobileModulesOpen && (
                    <motion.ul
                      initial={{ height: 0, opacity: 0 }}
                      animate={{ height: 'auto', opacity: 1 }}
                      exit={{ height: 0, opacity: 0 }}
                      transition={{ duration: 0.2 }}
                      className="ml-6 mt-2 space-y-1 overflow-hidden"
                    >
                      {MODULE_LINKS.map(({ label: moduleLabel, desc, Icon: ModuleIcon, tone }) => (
                        <li key={moduleLabel}>
                          <Link
                            href={`/practice/${moduleLabel.toLowerCase()}`}
                            onClick={closeMenu}
                            className="group flex items-start gap-3 rounded-lg p-3 text-sm transition"
                          >
                            <span
                              className={`mt-0.5 flex h-8 w-8 items-center justify-center rounded-lg ring-2 transition ${getToneClass(
                                tone
                              )}`}
                            >
                              {ModuleIcon ? <ModuleIcon className="h-4 w-4" /> : null}
                            </span>
                            <div className="min-w-0 flex-1">
                              <span className="block font-medium">{moduleLabel}</span>
                              {desc && (
                                <span className="text-xs text-muted-foreground dark:text-muted-foreground-dark">
                                  {desc}
                                </span>
                              )}
                            </div>
                          </Link>
                        </li>
                      ))}
                    </motion.ul>
                  )}
                </AnimatePresence>
              </li>
            )}

            {/* AI Tools Section */}
            {aiToolItems.length > 0 && (
              <li>
                <button
                  onClick={() => toggleSection('aiTools')}
                  className={`flex w-full items-center justify-between rounded-xl px-3 py-3 hover:bg-muted dark:hover:bg-muted-dark transition-colors ${
                    mobileAiToolsOpen ? 'bg-primary/10 dark:bg-primary-dark/10' : ''
                  }`}
                >
                  <div className="flex items-center gap-3">
                    <Icon name="Sparkles" size={18} />
                    <span className="font-medium">AI Tools</span>
                  </div>
                  <Icon
                    name={mobileAiToolsOpen ? 'ChevronUp' : 'ChevronDown'}
                    size={18}
                    className="opacity-70"
                  />
                </button>
                <AnimatePresence>
                  {mobileAiToolsOpen && (
                    <motion.ul
                      initial={{ height: 0, opacity: 0 }}
                      animate={{ height: 'auto', opacity: 1 }}
                      exit={{ height: 0, opacity: 0 }}
                      transition={{ duration: 0.2 }}
                      className="ml-6 mt-2 space-y-1 overflow-hidden"
                    >
                      {aiToolItems.map((item) => (
                        <li key={item.id}>
                          <NavLink
                            href={item.href}
                            className="flex items-center gap-3 rounded-xl px-3 py-2.5 hover:bg-muted dark:hover:bg-muted-dark transition-colors text-sm"
                            onClick={closeMenu}
                          >
                            <span>{item.label}</span>
                            {item.badge && (
                              <Badge variant="secondary" size="sm" className="ml-auto">
                                {item.badge}
                              </Badge>
                            )}
                          </NavLink>
                        </li>
                      ))}
                    </motion.ul>
                  )}
                </AnimatePresence>
              </li>
            )}

            {/* Partners & Admin */}
            {canSeePartners && (
              <li>
                <NavLink
                  href="/partners"
                  className="flex items-center gap-3 rounded-xl px-3 py-3 hover:bg-muted dark:hover:bg-muted-dark transition-colors"
                  onClick={closeMenu}
                >
                  <Icon name="Handshake" size={18} />
                  <span className="font-medium">Partners</span>
                </NavLink>
              </li>
            )}
            {canSeeAdmin && (
              <li>
                <NavLink
                  href="/admin/partners"
                  className="flex items-center gap-3 rounded-xl px-3 py-3 hover:bg-muted dark:hover:bg-muted-dark transition-colors"
                  onClick={closeMenu}
                >
                  <Icon name="Settings" size={18} />
                  <span className="font-medium">Admin</span>
                </NavLink>
              </li>
            )}
          </ul>

          {/* Sidebar Sections */}
          <div className="mt-8 space-y-6">
            {sidebarSections.map((section) => (
              <div key={section.id}>
                <div className="mb-3 flex items-center gap-2 text-xs font-semibold uppercase tracking-wide text-muted-foreground dark:text-muted-foreground-dark px-1">
                  {section.icon && <Icon name={section.icon} className="h-3.5 w-3.5" />}
                  <span>{section.label}</span>
                </div>
                <ul className="space-y-1">
                  {section.items.map((item) => (
                    <li key={item.id}>
                      <NavLink
                        href={item.href}
                        className="flex items-center gap-3 rounded-xl px-3 py-2.5 hover:bg-muted dark:hover:bg-muted-dark transition-colors text-sm"
                        onClick={closeMenu}
                      >
                        <span>{item.label}</span>
                      </NavLink>
                    </li>
                  ))}
                </ul>
              </div>
            ))}
          </div>

          {/* Account Section */}
          {profileMenu.length > 0 && user?.id && (
            <div className="mt-8 pt-6 border-t border-border dark:border-border-dark">
              <div className="mb-3 flex items-center gap-2 text-xs font-semibold uppercase tracking-wide text-muted-foreground dark:text-muted-foreground-dark px-1">
                <Icon name="User" className="h-3.5 w-3.5" />
                <span>Account</span>
              </div>
              <ul className="space-y-1">
                {profileMenu.map((item) => (
                  <li key={item.id}>
                    <NavLink
                      href={item.href}
                      className="flex items-center gap-3 rounded-xl px-3 py-2.5 hover:bg-muted dark:hover:bg-muted-dark transition-colors text-sm"
                      onClick={closeMenu}
                    >
                      <span>{item.label}</span>
                    </NavLink>
                  </li>
                ))}
                <li>
                  <button
                    onClick={() => {
                      closeMenu();
                      void signOut?.();
                    }}
                    className="flex w-full items-center gap-3 rounded-xl px-3 py-2.5 text-left text-sm font-medium text-destructive dark:text-destructive-dark hover:bg-destructive/10 dark:hover:bg-destructive-dark/10 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-border dark:focus-visible:ring-border-dark focus-visible:ring-offset-2 focus-visible:ring-offset-background"
                  >
                    <Icon name="LogOut" size={16} />
                    <span>Sign out</span>
                  </button>
                </li>
              </ul>
            </div>
          )}

          {/* Auth Section */}
          {!user?.id && ready && (
            <div className="mt-8 space-y-3">
              <Button
                asChild
                fullWidth
                variant="primary"
                className="rounded-xl font-semibold py-3.5"
              >
                <Link href="/login" onClick={closeMenu}>
                  Sign in
                </Link>
              </Button>
              <Button
                asChild
                fullWidth
                variant="outline"
                className="rounded-xl font-semibold py-3.5"
              >
                <Link href="/signup" onClick={closeMenu}>
                  Create account
                </Link>
              </Button>
            </div>
          )}

          {!ready && (
            <div className="mt-6 space-y-2">
              <div className="h-12 w-full animate-pulse rounded-xl bg-muted dark:bg-muted-dark" />
              <div className="h-12 w-full animate-pulse rounded-xl bg-muted dark:bg-muted-dark" />
            </div>
          )}

          {/* Premium summary (optional bottom section) */}
          {hasPremiumAccess && premiumRooms.length > 0 && (
            <div className="mt-8 pt-4 border-t border-border dark:border-border-dark">
              <div className="mb-2 flex items-center justify-between text-xs text-muted-foreground dark:text-muted-foreground-dark">
                <span>Premium access</span>
                <button
                  type="button"
                  onClick={handleClearPremium}
                  className="text-[11px] font-medium text-destructive dark:text-destructive-dark hover:underline"
                >
                  Clear
                </button>
              </div>
              <div className="max-h-20 overflow-y-auto text-xs text-muted-foreground dark:text-muted-foreground-dark space-y-1">
                {premiumRooms.slice(0, 4).map((room, idx) => (
                  <div key={idx} className="truncate">
                    â€¢ {room}
                  </div>
                ))}
                {premiumRooms.length > 4 && (
                  <div>+{premiumRooms.length - 4} more</div>
                )}
              </div>
            </div>
          )}
        </nav>
      </div>
    </motion.div>
  ) : null;

  return (
    <>
      <div className={className} {...rest}>
        <div className="flex items-center gap-2 md:hidden">
          {headerOptional.notifications && <NotificationBell />}
          {headerOptional.themeToggle && <IconOnlyThemeToggle />}
          <motion.button
            aria-label="Toggle menu"
            aria-expanded={mobileOpen}
            onClick={() => setMobileOpen(!mobileOpen)}
            whileTap={{ scale: 0.95 }}
            className="inline-flex h-10 w-10 items-center justify-center rounded-lg hover:bg-muted dark:hover:bg-muted-dark transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-border dark:focus-visible:ring-border-dark focus-visible:ring-offset-2 focus-visible:ring-offset-background"
          >
            {mobileOpen ? <Icon name="X" size={20} /> : <Icon name="Menu" size={20} />}
          </motion.button>
        </div>
      </div>

      {typeof document !== 'undefined'
        ? createPortal(
            <>
              {overlay}
              {panel}
            </>,
            document.body
          )
        : null}
    </>
  );
}

MobileNav.displayName = 'MobileNav';
export default MobileNav;





============================================================
FILE #24
PATH: components/navigation/DesktopNav.tsx
============================================================
// components/navigation/DesktopNav.tsx
'use client';

import React from 'react';
import Link from 'next/link';
import type { User as SupabaseUser } from '@supabase/supabase-js';

import { Button } from '@/components/design-system/Button';
import { Badge } from '@/components/design-system/Badge';
import Icon from '@/components/design-system/Icon';
import { NavLink } from '@/components/design-system/NavLink';
import { UserMenu } from '@/components/design-system/UserMenu';
import { NotificationBell } from '@/components/design-system/NotificationBell';
import { StreakChip } from '@/components/user/StreakChip';
import { IconOnlyThemeToggle } from './IconOnlyThemeToggle';
import ModuleMenu from './ModuleMenu';

import { navigationSchema } from '@/config/navigation';
import { filterNavItems } from '@/lib/navigation/utils';
import type { SubscriptionTier } from '@/lib/navigation/types';
import { cn } from '@/lib/utils';
import { AnimatePresence, motion } from 'framer-motion';

type DesktopNavProps = {
  user: SupabaseUser | null;
  role: string;
  ready: boolean;
  streak?: number | null;
  openModules: boolean;
  setOpenModules: (open: boolean) => void;
  modulesRef: React.RefObject<HTMLLIElement>;
  signOut: () => Promise<void> | void;
  showAdmin?: boolean;
  className?: string;
  hasPremiumAccess: boolean;
  premiumRooms: string[];
  onClearPremiumAccess: () => void;
  subscriptionTier: SubscriptionTier;
};

type NavContext = {
  isAuthenticated: boolean;
  tier: SubscriptionTier;
};

export const DesktopNav: React.FC<DesktopNavProps> = ({
  user,
  role,
  ready,
  streak,
  openModules,
  setOpenModules,
  modulesRef,
  signOut,
  showAdmin = true,
  className,
  hasPremiumAccess,
  premiumRooms,
  onClearPremiumAccess,
  subscriptionTier,
}) => {
  const uid = user?.id ?? null;
  const isTeacher = role === 'teacher';
  const canSeePartners = role === 'partner' || role === 'admin';
  const canSeeAdmin = role === 'admin' && showAdmin;
  const isAuthenticated = Boolean(uid);

  const navCtx: NavContext = React.useMemo(
    () => ({ isAuthenticated, tier: subscriptionTier }),
    [isAuthenticated, subscriptionTier]
  );

  const navItemClass =
    'nav-pill text-small font-medium text-foreground/80 dark:text-foreground-dark/80 hover:text-foreground dark:hover:text-foreground-dark focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-focus dark:focus-visible:ring-focus-dark focus-visible:ring-offset-2 focus-visible:ring-offset-background';

  // Profile menu entries for user dropdown
  const profileMenu = React.useMemo(() => {
    if (isTeacher) {
      return [{ id: 'account', label: 'Profile', href: '/account' }];
    }
    return filterNavItems(navigationSchema.header.profile, navCtx);
  }, [isTeacher, navCtx]);

  // Main header nav items
  const mainNavItems = React.useMemo(() => {
    if (isTeacher) return [];
    const items = filterNavItems(navigationSchema.header.main, navCtx);
    // If authed, hide duplicate "Home"
    return items.filter((item) => !(item.id === 'home' && uid));
  }, [navCtx, isTeacher, uid]);

  const aiToolItems = React.useMemo(() => {
    if (isTeacher) return [];
    return filterNavItems(navigationSchema.header.aiTools, navCtx);
  }, [navCtx, isTeacher]);

  const headerCtaConfig = navigationSchema.header.cta ?? {};
  const headerCta = uid ? headerCtaConfig.authed : headerCtaConfig.guest;
  const headerOptional = navigationSchema.header.optional ?? {};

  // AI tools dropdown state
  const [openAiTools, setOpenAiTools] = React.useState(false);
  const aiMenuRef = React.useRef<HTMLDivElement | null>(null);
  const aiButtonRef = React.useRef<HTMLButtonElement | null>(null);
  const aiToolsRef = React.useRef<HTMLLIElement | null>(null);

  // Focus on first item when AI tools opens
  React.useEffect(() => {
    if (!openAiTools) return;
    const firstLink = aiMenuRef.current?.querySelector<HTMLAnchorElement>('a,button');
    firstLink?.focus();
  }, [openAiTools]);

  // Close AI tools on outside click / Esc
  React.useEffect(() => {
    if (!openAiTools) return;

    const onClick = (event: MouseEvent) => {
      const target = event.target as Node;
      if (!aiToolsRef.current?.contains(target)) {
        setOpenAiTools(false);
      }
    };

    const onKey = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        setOpenAiTools(false);
        aiButtonRef.current?.focus();
      }
    };

    document.addEventListener('mousedown', onClick);
    document.addEventListener('keydown', onKey);
    return () => {
      document.removeEventListener('mousedown', onClick);
      document.removeEventListener('keydown', onKey);
    };
  }, [openAiTools]);

  // Only one menu open at a time
  React.useEffect(() => {
    if (openModules) setOpenAiTools(false);
  }, [openModules]);

  const isPremiumTier = subscriptionTier && subscriptionTier !== 'free';

  return (
    <nav
      className={cn(
        'flex items-center justify-between gap-4 text-sm',
        className
      )}
      aria-label="Primary"
    >
      <div className="flex items-center gap-4">
        {/* LEFT: main nav */}
        <ul className="relative flex items-center gap-2">
          {/* Dashboard shortcut for authenticated learners */}
          {uid && !isTeacher && (
            <li>
              <NavLink href="/dashboard" className={navItemClass} label="Dashboard" />
            </li>
          )}

          {/* Teacher entry */}
          {isTeacher && uid && (
            <li>
              <NavLink href="/teacher" className={navItemClass} label="Teacher" />
            </li>
          )}

          {/* Main items; "practice" becomes ModuleMenu */}
          {!isTeacher &&
            mainNavItems.map((item) =>
              item.id === 'practice' ? (
                <ModuleMenu
                  key={item.id}
                  open={openModules}
                  setOpen={setOpenModules}
                  modulesRef={modulesRef}
                />
              ) : (
                <li key={item.id}>
                  <NavLink href={item.href} className={navItemClass} label={item.label} />
                </li>
              )
            )}

          {/* AI Tools dropdown */}
          {!isTeacher && aiToolItems.length > 0 && (
            <li ref={aiToolsRef}>
              <motion.button
                ref={aiButtonRef}
                type="button"
                onClick={() => setOpenAiTools((v) => !v)}
                whileHover={{ scale: 1.02 }}
                className={cn(navItemClass, openAiTools && 'is-active')}
              >
                <Icon name="Sparkles" size={16} className="mr-1" />
                AI Tools
                <svg
                  className="ml-1 h-3.5 w-3.5 opacity-80"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  aria-hidden="true"
                >
                  <path d={openAiTools ? 'M6 15l6-6 6 6' : 'M6 9l6 6 6-6'} />
                </svg>
              </motion.button>

              <AnimatePresence>
                {openAiTools && (
                  <motion.div
                    id="ai-tools-menu"
                    ref={aiMenuRef}
                    initial={{ opacity: 0, y: -10 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: -10 }}
                    transition={{ duration: 0.15 }}
                    className="absolute right-0 top-full z-50 mt-3 w-64 rounded-xl border border-border dark:border-border-dark bg-card dark:bg-card-dark p-3 shadow-lg"
                    role="menu"
                  >
                    <ul className="space-y-1">
                      {aiToolItems.map((item) => (
                        <li key={item.id}>
                          <Link
                            href={item.href}
                            className="flex items-start gap-2 rounded-lg px-3 py-2 text-left text-small hover:bg-surface-muted dark:hover:bg-surface-muted-dark focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-focus dark:focus-visible:ring-focus-dark"
                            onClick={() => setOpenAiTools(false)}
                            role="menuitem"
                          >
                            <span className="font-medium">{item.label}</span>
                            {item.badge && (
                              <span className="ml-auto inline-flex items-center rounded-full bg-surface-muted dark:bg-surface-muted-dark px-2 text-[10px] font-semibold uppercase tracking-wider text-foreground-muted dark:text-foreground-muted-dark">
                                {item.badge}
                              </span>
                            )}
                          </Link>
                        </li>
                      ))}
                    </ul>
                  </motion.div>
                )}
              </AnimatePresence>
            </li>
          )}

          {/* Partners / Admin links */}
          {canSeePartners && (
            <li>
              <NavLink href="/partners" className={navItemClass} label="Partners" />
            </li>
          )}
          {canSeeAdmin && (
            <li>
              <NavLink href="/admin/partners" className={navItemClass} label="Admin" />
            </li>
          )}

          {/* Premium badge (hover card / indicator) */}
          {(hasPremiumAccess || isPremiumTier) && (
            <li className="relative group">
              <Badge
                variant="accent"
                size="sm"
                className="cursor-default inline-flex items-center gap-1"
              >
                <Icon name="Rocket" size={14} />
                <span>{subscriptionTier === 'free' ? 'Premium' : subscriptionTier}</span>
              </Badge>

              {hasPremiumAccess && (
                <div className="absolute top-full right-0 z-50 mt-2 hidden w-64 group-hover:block">
                  <div className="rounded-xl border border-border dark:border-border-dark bg-card dark:bg-card-dark p-3 shadow-lg">
                    <div className="mb-1 text-xs font-medium text-success dark:text-success-dark">
                      Premium Access Active
                    </div>
                    <div className="mb-2 text-xs text-foreground-muted dark:text-foreground-muted-dark">
                      Access to {premiumRooms.length} room{premiumRooms.length !== 1 ? 's' : ''}
                    </div>

                    {premiumRooms.length > 0 && (
                      <div className="max-h-24 overflow-y-auto text-xs text-foreground-muted dark:text-foreground-muted-dark">
                        {premiumRooms.slice(0, 3).map((room, idx) => (
                          <div key={idx} className="truncate">
                            â€¢ {room}
                          </div>
                        ))}
                        {premiumRooms.length > 3 && (
                          <div className="text-xs">+{premiumRooms.length - 3} more</div>
                        )}
                      </div>
                    )}

                    {onClearPremiumAccess && (
                      <button
                        type="button"
                        onClick={onClearPremiumAccess}
                        className="mt-2 text-xs text-destructive dark:text-destructive-dark hover:opacity-80 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-focus dark:focus-visible:ring-focus-dark rounded"
                      >
                        Clear All Access
                      </button>
                    )}
                  </div>
                </div>
              )}
            </li>
          )}

          {/* Header CTA */}
          {headerCta && (
            <li className="hidden lg:block">
              <Button
                href={headerCta.href}
                variant="primary"
                size="sm"
                className="shadow-sm rounded-full"
              >
                {headerCta.label}
              </Button>
            </li>
          )}
        </ul>
      </div>

      {/* RIGHT CLUSTER: streak, notifications, theme, user */}
      <div className="flex items-center gap-3">
        {/* Streak chip: always show when ready + logged in */}
        {ready && uid && (
          <StreakChip
            value={streak ?? 0}
            href="/profile/streak"
            className="shrink-0"
          />
        )}

        {/* Notification bell */}
        {headerOptional.notifications && <NotificationBell />}

        {/* Theme toggle */}
        {headerOptional.themeToggle && <IconOnlyThemeToggle />}

        {/* User menu / Sign-in */}
        <div className="ml-1">
          {ready ? (
            uid ? (
              <UserMenu
                userId={uid}
                email={user?.email ?? undefined}
                name={
                  (user?.user_metadata as any)?.full_name ??
                  (user?.user_metadata as any)?.name ??
                  undefined
                }
                role={role ?? undefined}
                avatarUrl={
                  (user?.user_metadata as any)?.avatar_url ??
                  (user?.user_metadata as any)?.avatar ??
                  undefined
                }
                onSignOut={async () => {
                  await signOut?.();
                }}
                isAdmin={role === 'admin'}
                items={profileMenu.map((link) => ({
                  id: link.id,
                  label: link.label,
                  href: link.href,
                }))}
              />
            ) : (
              <Button
                href="/login"
                variant="outline"
                size="sm"
                className="w-full sm:w-auto rounded-full"
              >
                Sign in
              </Button>
            )
          ) : (
            <div className="h-9 w-24 animate-pulse rounded-full bg-surface-muted dark:bg-surface-muted-dark" />
          )}
        </div>
      </div>
    </nav>
  );
};

export default DesktopNav;





============================================================
FILE #25
PATH: pages/api/cron/notifications-dispatch.ts
============================================================
import type { NextApiRequest, NextApiResponse } from 'next';

import { dispatchPending } from '@/lib/notify';

function authorised(req: NextApiRequest): boolean {
  const secret = process.env.NOTIFICATIONS_CRON_SECRET ?? null;
  if (!secret) {
    return process.env.NODE_ENV !== 'production';
  }

  const header = req.headers['x-cron-secret'];
  if (!header) return false;
  if (Array.isArray(header)) {
    return header.some((value) => value === secret);
  }
  return header === secret;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    res.setHeader('Allow', 'POST');
    return res.status(405).end('Method Not Allowed');
  }

  if (!authorised(req)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  return dispatchPending(req, res);
}





============================================================
FILE #26
PATH: lib/onboarding/notifications.ts
============================================================
import type { NextApiRequest, NextApiResponse } from 'next';
import { getServerClient } from '@/lib/supabaseServer';
import {
  NotificationsBody,
  NotificationChannelEnum,
} from '@/lib/onboarding/schema';

type Data =
  | { ok: true }
  | { ok: false; error: string; details?: unknown };

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ ok: false, error: 'Method not allowed' });
  }

  const parse = NotificationsBody.safeParse(req.body);
  if (!parse.success) {
    return res.status(400).json({
      ok: false,
      error: 'Invalid body',
      details: parse.error.flatten(),
    });
  }

  const { channels, preferredTime } = parse.data;

  // Extra safety: make sure channels are unique
  const uniqueChannels = Array.from(new Set(channels)).map((c) =>
    NotificationChannelEnum.parse(c)
  );

  const supabase = getServerClient(req, res);
  const {
    data: { user },
    error: userError,
  } = await supabase.auth.getUser();

  if (userError) {
    return res
      .status(500)
      .json({ ok: false, error: `Auth error: ${userError.message}` });
  }

  if (!user) {
    return res.status(401).json({ ok: false, error: 'Unauthorized' });
  }

  const updatePayload: Record<string, unknown> = {
    notification_channels: uniqueChannels,
    onboarding_completed_at: new Date().toISOString(),
  };

  if (preferredTime) {
    updatePayload.notification_time = preferredTime;
  }

  const { error } = await supabase
    .from('profiles')
    .update(updatePayload)
    .eq('id', user.id);

  if (error) {
    return res
      .status(500)
      .json({ ok: false, error: `DB error: ${error.message}` });
  }

  return res.status(200).json({ ok: true });
}





============================================================
FILE #27
PATH: pages/legal/privacy.tsx
============================================================
import Head from 'next/head';
import Link from 'next/link';
import type { ReactNode } from 'react';

import { Container } from '@/components/design-system/Container';
import { Card } from '@/components/design-system/Card';
import { Button } from '@/components/design-system/Button';

const UPDATED_ON = 'May 28, 2024';

const SECTIONS: Array<{
  id: string;
  title: string;
  content: ReactNode;
}> = [
  {
    id: 'scope',
    title: '1. Scope',
    content: (
      <p className="text-body text-muted-foreground">
        This Privacy Notice explains how GramorX (&ldquo;we&rdquo;, &ldquo;us&rdquo;) collects, uses, stores, and shares
        personal information when you access any web, mobile, or API experience branded as IELTS Prep with
        AI. It applies to learners, guardians, educators, institutions, and visitors worldwide.
      </p>
    ),
  },
  {
    id: 'data-we-collect',
    title: '2. Information We Collect',
    content: (
      <>
        <p className="text-body text-muted-foreground">
          We collect the minimum information required to deliver the product, operate securely, and comply with
          the law. Depending on how you use GramorX we may process:
        </p>
        <ul className="mt-3 list-disc space-y-2 pl-6 text-body text-muted-foreground">
          <li>
            <strong>Account details</strong> such as name, email, phone number, language preference, role, and goal band.
          </li>
          <li>
            <strong>Learning records</strong> including practice attempts, scores, feedback, streaks, and coaching notes.
          </li>
          <li>
            <strong>Content uploads</strong> you provide, such as essays, speaking recordings, documents, and support tickets.
          </li>
          <li>
            <strong>Payment data</strong> processed by our billing providers (card type, country, transaction history).
          </li>
          <li>
            <strong>Technical data</strong> like device identifiers, browser type, session telemetry, and cookies to protect the
            service and measure performance.
          </li>
        </ul>
      </>
    ),
  },
  {
    id: 'how-we-use-data',
    title: '3. How We Use Information',
    content: (
      <>
        <p className="text-body text-muted-foreground">
          Information is processed to deliver and improve the service, including to:
        </p>
        <ul className="mt-3 list-disc space-y-2 pl-6 text-body text-muted-foreground">
          <li>Authenticate users, maintain accounts, and personalize study plans.</li>
          <li>Score attempts, surface analytics, and power AI feedback features.</li>
          <li>Provide support, safety notifications, marketing opt-ins, and transactional updates.</li>
          <li>Monitor availability, prevent fraud or abuse, and enforce legal or policy requirements.</li>
          <li>Generate de-identified analytics that guide product, curriculum, and infrastructure investments.</li>
        </ul>
      </>
    ),
  },
  {
    id: 'legal-bases',
    title: '4. Legal Bases',
    content: (
      <p className="text-body text-muted-foreground">
        We rely on contract performance, legitimate interests in securing and improving the platform, compliance
        with legal obligations, and (where required) your consent. We will request explicit consent before
        sending promotional email or SMS in jurisdictions that require it.
      </p>
    ),
  },
  {
    id: 'sharing',
    title: '5. Sharing &amp; Processors',
    content: (
      <>
        <p className="text-body text-muted-foreground">
          We do not sell personal information. Access is limited to vetted employees, contractors, and service
          providers bound by confidentiality obligations. Key processors include authentication, file storage,
          analytics, messaging, and payment vendors. Institutions that sponsor seats may receive aggregated
          progress reports according to their agreement.
        </p>
        <p className="mt-3 text-body text-muted-foreground">
          We may disclose information if required by law or to protect users, the public, or GramorX from harm.
        </p>
      </>
    ),
  },
  {
    id: 'cookies',
    title: '6. Cookies &amp; Tracking',
    content: (
      <p className="text-body text-muted-foreground">
        Cookies and similar technologies keep you signed in, remember preferences, and help us understand which
        features are working. You can manage cookies through your browser settings. Some functionality (such as
        secure session handling) requires essential cookies and may not operate if disabled.
      </p>
    ),
  },
  {
    id: 'international',
    title: '7. International Transfers',
    content: (
      <p className="text-body text-muted-foreground">
        We operate globally using cloud infrastructure primarily located in the United States and European Union.
        When information is transferred across borders we implement safeguards such as Standard Contractual
        Clauses or comparable mechanisms and limit access to personnel with a legitimate need.
      </p>
    ),
  },
  {
    id: 'retention',
    title: '8. Retention &amp; Deletion',
    content: (
      <>
        <p className="text-body text-muted-foreground">
          Personal information is retained for as long as your account is active and for a reasonable period
          afterward to comply with legal, accounting, or audit requirements. You can request deletion at any time
          via the in-product request or by emailing privacy@gramorx.com. Learn more on our{' '}
          <Link href="/data-deletion" className="underline">
            Data Deletion
          </Link>{' '}
          page.
        </p>
        <p className="mt-3 text-body text-muted-foreground">
          Backup systems roll off within 90 days. Aggregated or de-identified insights that no longer identify an
          individual may be retained indefinitely.
        </p>
      </>
    ),
  },
  {
    id: 'childrens-privacy',
    title: "9. Children's Privacy",
    content: (
      <p className="text-body text-muted-foreground">
        GramorX is intended for learners 13 years of age or older (or the minimum age in your jurisdiction). We do
        not knowingly collect personal information from children below this threshold. Parents or guardians who
        believe a child has provided information should contact us so we can investigate and delete the data.
      </p>
    ),
  },
  {
    id: 'your-rights',
    title: '10. Your Rights',
    content: (
      <>
        <p className="text-body text-muted-foreground">
          Subject to regional laws, you may have the right to access, correct, delete, restrict, or object to the
          processing of your data, as well as the right to portability and to withdraw consent. We respond to
          verified requests within applicable timeframes.
        </p>
        <div className="mt-4 flex flex-wrap gap-3">
          <Link href="/support?topic=privacy">
            <Button variant="primary" size="sm" className="rounded-ds">
              Submit a request
            </Button>
          </Link>
          <a href="mailto:privacy@gramorx.com" className="inline-block">
            <Button variant="secondary" size="sm" className="rounded-ds">
              privacy@gramorx.com
            </Button>
          </a>
        </div>
      </>
    ),
  },
  {
    id: 'changes',
    title: '11. Updates',
    content: (
      <p className="text-body text-muted-foreground">
        We will update this notice when practices change or when required by law. Material changes will be
        communicated through the product or by email, and the &ldquo;Last updated&rdquo; date below will reflect the
        current version.
      </p>
    ),
  },
  {
    id: 'contact',
    title: '12. Contact',
    content: (
      <p className="text-body text-muted-foreground">
        Questions or concerns about privacy can be directed to privacy@gramorx.com. If you believe we have not
        addressed an issue, you may contact your local data protection authority.
      </p>
    ),
  },
];

export default function PrivacyPage() {
  return (
    <>
      <Head>
        <title>Privacy Notice â€¢ GramorX</title>
        <meta
          name="description"
          content="Learn how GramorX collects, uses, and protects personal information for IELTS Prep with AI users."
        />
      </Head>

      <section className="bg-lightBg py-24 dark:bg-gradient-to-br dark:from-dark/80 dark:to-darker/90">
        <Container>
          <header className="mb-12 space-y-4">
            <p className="text-caption uppercase tracking-[0.18em] text-muted-foreground">Legal Â· Privacy</p>
            <h1 className="font-slab text-display text-gradient-primary">Privacy Notice</h1>
            <p className="max-w-2xl text-body text-muted-foreground">
              Transparency and control are core to the learning experience. This page outlines what data we collect,
              why we process it, and how you can exercise your rights wherever you are located.
            </p>
            <p className="text-small text-muted-foreground">Last updated: {UPDATED_ON}</p>
          </header>

          <Card className="mb-10 rounded-ds-2xl p-6">
            <h2 className="font-slab text-h4">Contents</h2>
            <nav className="mt-4 grid gap-2 sm:grid-cols-2 lg:grid-cols-3">
              {SECTIONS.map((section) => (
                <a
                  key={section.id}
                  href={`#${section.id}`}
                  className="rounded-ds border border-lightBorder p-3 text-small transition-colors hover:bg-purpleVibe/10 dark:border-white/10 dark:hover:bg-white/5"
                >
                  {section.title}
                </a>
              ))}
            </nav>
          </Card>

          <div className="space-y-8">
            {SECTIONS.map((section) => (
              <Card key={section.id} id={section.id} className="rounded-ds-2xl p-6 scroll-mt-28">
                <h2 className="font-slab text-h3">{section.title}</h2>
                <div className="mt-3 space-y-3">{section.content}</div>
              </Card>
            ))}
          </div>
        </Container>
      </section>
    </>
  );
}





============================================================
FILE #28
PATH: pages/api/cron/notifications-study-reminder.ts
============================================================
import type { NextApiRequest, NextApiResponse } from 'next';
import { DateTime } from 'luxon';

import { queueNotificationEvent } from '@/lib/notify';
import { supabaseService } from '@/lib/supabaseServer';
import type { Database } from '@/types/supabase';
import { getBaseUrl } from '@/lib/url';

const MAX_BATCH = Number(process.env.NOTIFICATIONS_STUDY_REMINDER_LIMIT ?? '200');

function authorised(req: NextApiRequest): boolean {
  const secret = process.env.NOTIFICATIONS_CRON_SECRET ?? null;
  if (!secret) {
    return process.env.NODE_ENV !== 'production';
  }

  const header = req.headers['x-cron-secret'];
  if (!header) return false;
  if (Array.isArray(header)) {
    return header.some((value) => value === secret);
  }
  return header === secret;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    res.setHeader('Allow', 'POST');
    return res.status(405).end('Method Not Allowed');
  }

  if (!authorised(req)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const client = supabaseService<Database>();
  const limit = Number.isFinite(MAX_BATCH) && MAX_BATCH > 0 ? Math.min(MAX_BATCH, 500) : 200;

  const { data: plans, error: plansError } = await client
    .from('study_plans')
    .select('user_id')
    .order('updated_at', { ascending: false })
    .limit(limit);

  if (plansError) {
    return res.status(500).json({ error: plansError.message });
  }

  const userIds = Array.from(
    new Set((plans ?? []).map((plan) => (plan.user_id as string | null)?.trim()).filter(Boolean)),
  ) as string[];

  if (userIds.length === 0) {
    return res.status(200).json({
      ok: true,
      summary: { scanned: 0, enqueued: 0, duplicates: 0, skipped: 0 },
    });
  }

  const [{ data: optInRows, error: optInError }, { data: profileRows, error: profileError }] = await Promise.all([
    client
      .from('notifications_opt_in')
      .select('user_id, email_opt_in, wa_opt_in, channels')
      .in('user_id', userIds),
    client
      .from('profiles')
      .select('user_id, email, phone')
      .in('user_id', userIds),
  ]);

  if (optInError) {
    return res.status(500).json({ error: optInError.message });
  }
  if (profileError) {
    return res.status(500).json({ error: profileError.message });
  }

  const optInMap = new Map<
    string,
    { email_opt_in?: boolean | null; wa_opt_in?: boolean | null; channels?: string[] | null }
  >();
  for (const row of optInRows ?? []) {
    const id = (row.user_id as string | null) ?? null;
    if (id) {
      optInMap.set(id, {
        email_opt_in: row.email_opt_in as boolean | null | undefined,
        wa_opt_in: row.wa_opt_in as boolean | null | undefined,
        channels: Array.isArray(row.channels) ? (row.channels as string[]) : null,
      });
    }
  }

  const profileMap = new Map<string, { email: string | null; phone: string | null }>();
  for (const row of profileRows ?? []) {
    const id = (row.user_id as string | null) ?? null;
    if (!id) continue;
    const email = typeof row.email === 'string' ? row.email.trim() : '';
    const phone = typeof row.phone === 'string' ? row.phone.trim() : '';
    profileMap.set(id, {
      email: email.length > 0 ? email : null,
      phone: phone.length > 0 ? phone : null,
    });
  }

  const baseUrl = getBaseUrl();
  const today = DateTime.utc().toISODate();

  let enqueued = 0;
  let duplicates = 0;
  let skipped = 0;

  for (const userId of userIds) {
    const opt = optInMap.get(userId);
    const rawChannels = new Set(opt?.channels ?? []);
    const emailFlag = opt?.email_opt_in;
    const waFlag = opt?.wa_opt_in;
    const emailEnabled =
      emailFlag === undefined || emailFlag === null ? rawChannels.has('email') || !opt : Boolean(emailFlag);
    const whatsappEnabled =
      waFlag === undefined || waFlag === null ? rawChannels.has('whatsapp') : Boolean(waFlag);

    if (!emailEnabled && !whatsappEnabled) {
      skipped += 1;
      continue;
    }

    const profile = profileMap.get(userId) ?? { email: null, phone: null };
    const requestedChannels: Array<'email' | 'whatsapp'> = [];
    if (emailEnabled && profile.email) requestedChannels.push('email');
    if (whatsappEnabled && profile.phone) requestedChannels.push('whatsapp');

    if (requestedChannels.length === 0) {
      skipped += 1;
      continue;
    }

    const payload: Record<string, unknown> = {
      module: 'Study Plan',
      deep_link: `${baseUrl}/study-plan`,
    };
    if (profile.email) payload.user_email = profile.email;
    if (profile.phone) payload.user_phone = profile.phone;

    const result = await queueNotificationEvent({
      event_key: 'study_reminder',
      user_id: userId,
      payload,
      channels: requestedChannels,
      idempotency_key: `study_reminder:${userId}:${today}`,
    });

    if (result.ok) {
      enqueued += 1;
    } else if (result.reason === 'duplicate') {
      duplicates += 1;
    } else {
      skipped += 1;
    }
  }

  return res.status(200).json({
    ok: true,
    summary: {
      scanned: userIds.length,
      enqueued,
      duplicates,
      skipped,
    },
  });
}





============================================================
FILE #29
PATH: pages/legal/terms.tsx
============================================================
import Head from 'next/head';
import Link from 'next/link';
import type { ReactNode } from 'react';

import { Container } from '@/components/design-system/Container';
import { Card } from '@/components/design-system/Card';
import { Button } from '@/components/design-system/Button';

const EFFECTIVE_DATE = 'May 28, 2024';

const SECTIONS: Array<{
  id: string;
  title: string;
  content: ReactNode;
}> = [
  {
    id: 'acceptance',
    title: '1. Acceptance of Terms',
    content: (
      <p className="text-body text-muted-foreground">
        By accessing or using GramorX you agree to these Terms, the Privacy Notice, and any policies referenced
        here. If you are accepting on behalf of an organization, you represent that you have authority to bind
        that organization. If you do not agree, you may not use the service.
      </p>
    ),
  },
  {
    id: 'service',
    title: '2. Service Overview',
    content: (
      <p className="text-body text-muted-foreground">
        GramorX provides IELTS preparation tools, content, and analytics across web and mobile apps. We may
        enhance, modify, or discontinue features with notice where practical. Certain capabilities may be offered
        as beta or preview features and are provided as-is.
      </p>
    ),
  },
  {
    id: 'eligibility',
    title: '3. Eligibility &amp; Registration',
    content: (
      <ul className="list-disc space-y-2 pl-6 text-body text-muted-foreground">
        <li>You must be at least 13 years old or the minimum age required in your jurisdiction.</li>
        <li>Provide accurate registration details and keep them current.</li>
        <li>Institutional or guardian-managed accounts must ensure appropriate consent is in place.</li>
      </ul>
    ),
  },
  {
    id: 'account-security',
    title: '4. Account Security',
    content: (
      <p className="text-body text-muted-foreground">
        You are responsible for safeguarding login credentials and for activities that occur under your account.
        Notify us immediately at security@gramorx.com if you suspect unauthorized access. We may suspend accounts
        to protect you, other users, or the platform.
      </p>
    ),
  },
  {
    id: 'acceptable-use',
    title: '5. Acceptable Use',
    content: (
      <>
        <p className="text-body text-muted-foreground">
          You agree not to misuse the service. Prohibited activities include:
        </p>
        <ul className="mt-3 list-disc space-y-2 pl-6 text-body text-muted-foreground">
          <li>Cheating, plagiarism, or using GramorX to violate exam policies.</li>
          <li>Reverse engineering, automated scraping, or attempts to access non-public areas.</li>
          <li>Uploading unlawful, defamatory, or infringing content.</li>
          <li>Harassing other users or interfering with platform security.</li>
        </ul>
      </>
    ),
  },
  {
    id: 'user-content',
    title: '6. User Content &amp; License',
    content: (
      <p className="text-body text-muted-foreground">
        You retain ownership of content you upload. You grant GramorX a worldwide, non-exclusive license to host,
        process, adapt, and display that content solely to operate, secure, and improve the service. You are
        responsible for ensuring you have rights to the material you submit.
      </p>
    ),
  },
  {
    id: 'ai-features',
    title: '7. AI Guidance',
    content: (
      <p className="text-body text-muted-foreground">
        AI-generated scores and recommendations are predictive guidance, not official IELTS scoring. You should
        review suggestions critically and combine them with human instruction. We may use de-identified insights
        derived from your usage to improve models while protecting your privacy.
      </p>
    ),
  },
  {
    id: 'fees',
    title: '8. Plans, Fees &amp; Billing',
    content: (
      <>
        <p className="text-body text-muted-foreground">
          Paid plans, credit packs, or institutional contracts may apply. You agree to pay listed prices and
          applicable taxes. Unless stated otherwise, subscriptions renew automatically until cancelled.
        </p>
        <p className="mt-3 text-body text-muted-foreground">
          If a payment fails we may suspend access to paid functionality. Billing support is available through the
          in-product help desk or by contacting finance@gramorx.com.
        </p>
      </>
    ),
  },
  {
    id: 'cancellations',
    title: '9. Cancellations &amp; Refunds',
    content: (
      <p className="text-body text-muted-foreground">
        You can cancel a subscription at any time to stop future charges. Refund eligibility follows local law and
        any specific promises stated at purchase. Where refunds are not required, we may issue goodwill credits at
        our discretion.
      </p>
    ),
  },
  {
    id: 'privacy',
    title: '10. Privacy',
    content: (
      <p className="text-body text-muted-foreground">
        Our use of personal information is described in the{' '}
        <Link href="/legal/privacy" className="underline">
          Privacy Notice
        </Link>
        . We process data to deliver the service, meet legal obligations, and keep the platform secure.
      </p>
    ),
  },
  {
    id: 'third-parties',
    title: '11. Third-Party Services',
    content: (
      <p className="text-body text-muted-foreground">
        Certain features rely on third-party providers (for example: authentication, file storage, payments,
        communications). Their terms may apply when you interact with them. GramorX is not responsible for third
        parties that it does not control.
      </p>
    ),
  },
  {
    id: 'intellectual-property',
    title: '12. Intellectual Property',
    content: (
      <p className="text-body text-muted-foreground">
        The GramorX platform, trademarks, and content we supply are owned by GramorX or its licensors. Except as
        permitted by these Terms, you may not copy, modify, or create derivative works from our materials without
        prior written consent.
      </p>
    ),
  },
  {
    id: 'disclaimers',
    title: '13. Disclaimers',
    content: (
      <p className="text-body text-muted-foreground">
        The service is provided &ldquo;as is&rdquo; without warranties of any kind, whether express, implied, or
        statutory. We do not guarantee exam outcomes, uninterrupted availability, or error-free operation.
      </p>
    ),
  },
  {
    id: 'liability',
    title: '14. Limitation of Liability',
    content: (
      <p className="text-body text-muted-foreground">
        To the fullest extent permitted by law, GramorX will not be liable for indirect, incidental, or
        consequential damages, loss of profits, or data loss. Our aggregate liability for claims arising out of
        these Terms will not exceed the fees paid by you in the three months preceding the claim.
      </p>
    ),
  },
  {
    id: 'indemnity',
    title: '15. Indemnification',
    content: (
      <p className="text-body text-muted-foreground">
        You agree to indemnify and hold GramorX, its affiliates, and personnel harmless from claims, damages, or
        expenses arising from your misuse of the service or violation of these Terms or applicable laws.
      </p>
    ),
  },
  {
    id: 'termination',
    title: '16. Suspension &amp; Termination',
    content: (
      <p className="text-body text-muted-foreground">
        You may stop using the service at any time. We may suspend or terminate access for breach, non-payment,
        unlawful activity, or risk to users. Sections that by their nature should survive termination (including
        ownership, disclaimers, and limitations) will continue in effect.
      </p>
    ),
  },
  {
    id: 'law',
    title: '17. Governing Law &amp; Dispute Resolution',
    content: (
      <p className="text-body text-muted-foreground">
        These Terms are governed by the laws of the State of Delaware, USA, without regard to conflict-of-law
        principles. Disputes will be resolved exclusively in the state or federal courts located in Wilmington,
        Delaware, unless your local law requires otherwise.
      </p>
    ),
  },
  {
    id: 'changes',
    title: '18. Changes to Terms',
    content: (
      <p className="text-body text-muted-foreground">
        We may update these Terms when we launch new features or when legal requirements change. We will provide
        notice of material updates through the product or by email. Continued use of the service after the notice
        takes effect constitutes acceptance of the revised Terms.
      </p>
    ),
  },
  {
    id: 'contact',
    title: '19. Contact',
    content: (
      <>
        <p className="text-body text-muted-foreground">
          Questions about these Terms can be directed to legal@gramorx.com. Billing or account support is available
          via the help desk.
        </p>
        <div className="mt-4 flex flex-wrap gap-3">
          <Link href="/support?topic=billing">
            <Button variant="primary" size="sm" className="rounded-ds">
              Contact support
            </Button>
          </Link>
          <a href="mailto:legal@gramorx.com" className="inline-block">
            <Button variant="secondary" size="sm" className="rounded-ds">
              legal@gramorx.com
            </Button>
          </a>
        </div>
      </>
    ),
  },
];

export default function TermsPage() {
  return (
    <>
      <Head>
        <title>Terms of Service â€¢ GramorX</title>
        <meta
          name="description"
          content="Review the Terms of Service that govern access to GramorX IELTS Prep with AI."
        />
      </Head>

      <section className="bg-lightBg py-24 dark:bg-gradient-to-br dark:from-dark/80 dark:to-darker/90">
        <Container>
          <header className="mb-12 space-y-4">
            <p className="text-caption uppercase tracking-[0.18em] text-muted-foreground">Legal Â· Terms</p>
            <h1 className="font-slab text-display text-gradient-primary">Terms of Service</h1>
            <p className="max-w-2xl text-body text-muted-foreground">
              These Terms set the rules for using GramorX. They describe your responsibilities, how subscriptions
              and credits work, and what to expect from our AI-powered learning tools.
            </p>
            <p className="text-small text-muted-foreground">Effective date: {EFFECTIVE_DATE}</p>
          </header>

          <Card className="mb-10 rounded-ds-2xl p-6">
            <h2 className="font-slab text-h4">Contents</h2>
            <nav className="mt-4 grid gap-2 sm:grid-cols-2 lg:grid-cols-3">
              {SECTIONS.map((section) => (
                <a
                  key={section.id}
                  href={`#${section.id}`}
                  className="rounded-ds border border-lightBorder p-3 text-small transition-colors hover:bg-purpleVibe/10 dark:border-white/10 dark:hover:bg-white/5"
                >
                  {section.title}
                </a>
              ))}
            </nav>
          </Card>

          <div className="space-y-8">
            {SECTIONS.map((section) => (
              <Card key={section.id} id={section.id} className="rounded-ds-2xl p-6 scroll-mt-28">
                <h2 className="font-slab text-h3">{section.title}</h2>
                <div className="mt-3 space-y-3">{section.content}</div>
              </Card>
            ))}
          </div>
        </Container>
      </section>
    </>
  );
}





============================================================
FILE #30
PATH: lib/onboarding/schema.ts
============================================================
import { z } from 'zod';

const supportedLanguageCodes = ['en', 'ur'] as const;

export const languageOptions = [
  { value: 'en', label: 'English' },
  { value: 'ur', label: 'Ø§Ø±Ø¯Ùˆ' },
] as const;

const LanguageEnum = z.enum(supportedLanguageCodes);
const StudyDayEnum = z.enum(['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'] as const);
const PhoneSchema = z.union([z.string().min(6).max(32), z.literal('')]);
const ExamTimeframeEnum = z.enum(
  ['0-30', '30-60', '60-90', '90-plus', 'not-booked'] as const,
);

export const NotificationChannelEnum = z.enum(
  ['email', 'whatsapp', 'in-app'] as const,
);
export type NotificationChannel = z.infer<typeof NotificationChannelEnum>;

export const ExamDateBody = z.object({
  timeframe: ExamTimeframeEnum,
  examDate: z.string().optional().nullable(),
});
export type ExamDateBodyInput = z.infer<typeof ExamDateBody>;

export const LanguageBody = z.object({
  language: LanguageEnum,
});
export type LanguageBodyInput = z.infer<typeof LanguageBody>;

export const NotificationsBody = z.object({
  channels: z.array(NotificationChannelEnum).min(1),
  preferredTime: z.string().optional().nullable(),
});
export type NotificationsBodyInput = z.infer<typeof NotificationsBody>;

export const StudyRhythmBody = z.object({
  rhythm: z.enum(['daily', '5days', 'weekends', 'flexible', 'intensive'] as const),
});
export type StudyRhythmBodyInput = z.infer<typeof StudyRhythmBody>;

export const TargetBandBody = z.object({
  targetBand: z.enum(['5.5', '6.0', '6.5', '7.0', '7.5+'] as const),
});
export type TargetBandBodyInput = z.infer<typeof TargetBandBody>;

export const onboardingStateSchema = z.object({
  preferredLanguage: LanguageEnum.nullable(),
  goalBand: z.number().min(4).max(9).nullable(),
  examDate: z.string().nullable(),
  studyDays: z.array(StudyDayEnum).min(1).nullable(),
  studyMinutesPerDay: z.number().int().min(10).max(360).nullable(),
  whatsappOptIn: z.boolean().nullable(),
  phone: PhoneSchema.nullable(),
  onboardingStep: z.number().int().min(0),
  onboardingComplete: z.boolean(),
});

export type OnboardingState = z.infer<typeof onboardingStateSchema>;

const StepOneSchema = z.object({
  step: z.literal(1),
  data: z.object({
    preferredLanguage: LanguageEnum,
  }),
});

const StepTwoSchema = z.object({
  step: z.literal(2),
  data: z.object({
    goalBand: z.number().min(4).max(9),
  }),
});

const StepThreeSchema = z.object({
  step: z.literal(3),
  data: z.object({
    examDate: z.union([z.string(), z.null()]).optional().nullable(),
  }),
});

const StepFourSchema = z.object({
  step: z.literal(4),
  data: z.object({
    studyDays: z.array(StudyDayEnum).min(1),
    minutesPerDay: z.number().int().min(10).max(360),
  }),
});

const StepFiveSchema = z.object({
  step: z.literal(5),
  data: z.object({
    whatsappOptIn: z.boolean(),
    phone: z.string().trim().optional().nullable(),
  }),
});

export const onboardingStepPayloadSchema = z.discriminatedUnion('step', [
  StepOneSchema,
  StepTwoSchema,
  StepThreeSchema,
  StepFourSchema,
  StepFiveSchema,
]);

export type OnboardingStepPayload = z.infer<typeof onboardingStepPayloadSchema>;

export const TOTAL_ONBOARDING_STEPS = 5;

export const languageOptionsEnum = LanguageEnum;
export const studyDayOptionsEnum = StudyDayEnum;





============================================================
FILE #31
PATH: pages/settings/notifications.tsx
============================================================
import * as React from 'react';
import Head from 'next/head';
import Link from 'next/link';
import { useRouter } from 'next/router';

import { Container } from '@/components/design-system/Container';
import { Toggle } from '@/components/design-system/Toggle';
import { Input } from '@/components/design-system/Input';
import { Select } from '@/components/design-system/Select';
import { Button } from '@/components/design-system/Button';
import { Alert } from '@/components/design-system/Alert';
import Skeleton from '@/components/design-system/Skeleton';
import { track } from '@/lib/analytics/track';

interface ChannelState {
  email: boolean;
  whatsapp: boolean;
}

interface FormState {
  channels: ChannelState;
  quietHoursStart: string | null;
  quietHoursEnd: string | null;
  timezone: string;
}

interface ContactState {
  email: string | null;
  phone: string | null;
  phoneVerified: boolean;
}

interface ServerPreferences {
  channels: Record<'email' | 'whatsapp', boolean>;
  quietHoursStart: string | null;
  quietHoursEnd: string | null;
  timezone: string;
  email: string | null;
  emailOptIn: boolean;
  whatsappOptIn: boolean;
  smsOptIn: boolean;
  phone: string | null;
  phoneVerified: boolean;
}

interface PreferencesResponse {
  preferences: ServerPreferences;
}

type Status = 'idle' | 'saving' | 'saved' | 'error';

function toTimeInput(value: string | null): string | null {
  if (!value) return null;
  const parts = value.split(':');
  if (parts.length >= 2) {
    return `${parts[0].padStart(2, '0')}:${parts[1].padStart(2, '0')}`;
  }
  return null;
}

function normalizePayload(preferences: ServerPreferences): { form: FormState; contact: ContactState } {
  return {
    form: {
      channels: {
        email: Boolean(preferences.channels.email),
        whatsapp: Boolean(preferences.channels.whatsapp),
      },
      quietHoursStart: toTimeInput(preferences.quietHoursStart),
      quietHoursEnd: toTimeInput(preferences.quietHoursEnd),
      timezone: preferences.timezone || 'UTC',
    },
    contact: {
      email: preferences.email,
      phone: preferences.phone,
      phoneVerified: Boolean(preferences.phoneVerified),
    },
  };
}

export default function NotificationsSettingsPage() {
  const router = useRouter();
  const [form, setForm] = React.useState<FormState>({
    channels: { email: true, whatsapp: false },
    quietHoursStart: null,
    quietHoursEnd: null,
    timezone: 'UTC',
  });
  const [contact, setContact] = React.useState<ContactState>({
    email: null,
    phone: null,
    phoneVerified: false,
  });
  const [loading, setLoading] = React.useState(true);
  const [status, setStatus] = React.useState<Status>('idle');
  const [error, setError] = React.useState<string | null>(null);
  const [hasLoaded, setHasLoaded] = React.useState(false);
  const statusRef = React.useRef<HTMLSpanElement | null>(null);
  const autoUnsubApplied = React.useRef(false);

  const timezoneOptions = React.useMemo(() => {
    try {
      const supported = (Intl as any).supportedValuesOf
        ? ((Intl as any).supportedValuesOf('timeZone') as string[])
        : [];
      return supported.length > 0 ? supported : ['UTC'];
    } catch {
      return ['UTC'];
    }
  }, []);

  const applyPreferences = React.useCallback((payload: ServerPreferences) => {
    const { form: mappedForm, contact: mappedContact } = normalizePayload(payload);
    setForm(mappedForm);
    setContact(mappedContact);
    setHasLoaded(true);
  }, []);

  React.useEffect(() => {
    let active = true;
    const load = async () => {
      setLoading(true);
      setError(null);
      try {
        const response = await fetch('/api/notifications/preferences', {
          method: 'GET',
          credentials: 'include',
        });

        if (!active) return;

        if (response.status === 401) {
          setError('Sign in to manage your notification preferences.');
          setLoading(false);
          return;
        }

        if (!response.ok) {
          setError('Failed to load preferences.');
          setLoading(false);
          return;
        }

        const data = (await response.json()) as PreferencesResponse;
        applyPreferences(data.preferences);
      } catch (err) {
        if (!active) return;
        setError('Failed to load preferences.');
      } finally {
        if (active) {
          setLoading(false);
        }
      }
    };

    void load();

    return () => {
      active = false;
    };
  }, [applyPreferences]);

  React.useEffect(() => {
    if (status !== 'saved') return;
    const timer = setTimeout(() => setStatus('idle'), 2000);
    return () => clearTimeout(timer);
  }, [status]);

  const persist = React.useCallback(
    async (next: FormState) => {
      setStatus('saving');
      setError(null);
      try {
        const response = await fetch('/api/notifications/preferences', {
          method: 'POST',
          credentials: 'include',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({
            channels: next.channels,
            quietHoursStart: next.quietHoursStart ?? null,
            quietHoursEnd: next.quietHoursEnd ?? null,
            timezone: next.timezone,
          }),
        });

        if (!response.ok) {
          const payload = (await response.json().catch(() => null)) as { error?: string } | null;
          setError(payload?.error ?? 'Failed to save preferences.');
          setStatus('error');
          return false;
        }

        const data = (await response.json()) as PreferencesResponse;
        applyPreferences(data.preferences);
        setStatus('saved');
        return true;
      } catch (err) {
        setError('Failed to save preferences.');
        setStatus('error');
        return false;
      }
    },
    [applyPreferences],
  );

  const handleSubmit = React.useCallback(
    async (event: React.FormEvent<HTMLFormElement>) => {
      event.preventDefault();
      await persist(form);
    },
    [form, persist],
  );

  const handleChannelChange = (key: keyof ChannelState, value: boolean) => {
    setForm((prev) => ({
      ...prev,
      channels: { ...prev.channels, [key]: value },
    }));
  };

  const handleTimeChange = (key: 'quietHoursStart' | 'quietHoursEnd', value: string) => {
    setForm((prev) => ({
      ...prev,
      [key]: value && value.trim().length > 0 ? value : null,
    }));
  };

  const handleTimezoneChange = (value: string) => {
    setForm((prev) => ({ ...prev, timezone: value }));
  };

  const handleUnsubscribe = React.useCallback(
    async (source: 'manual' | 'auto') => {
      if (source === 'manual') {
        track('unsubscribe_clicked', { location: 'settings_notifications_footer' });
      }

      if (!hasLoaded) return;

      const next: FormState = {
        ...form,
        channels: { email: false, whatsapp: false },
      };
      setForm(next);
      await persist(next);
    },
    [form, hasLoaded, persist],
  );

  React.useEffect(() => {
    if (!router.isReady || !hasLoaded || autoUnsubApplied.current) return;
    const flag = router.query.unsubscribe;
    if (flag === '1') {
      autoUnsubApplied.current = true;
      void handleUnsubscribe('auto');
      void router.replace('/settings/notifications', undefined, { shallow: true });
    }
  }, [router, hasLoaded, handleUnsubscribe]);

  const statusMessage = React.useMemo(() => {
    switch (status) {
      case 'saving':
        return 'Savingâ€¦';
      case 'saved':
        return 'Saved âœ“';
      case 'error':
        return 'Could not save changes';
      default:
        return null;
    }
  }, [status]);

  return (
    <>
      <Head>
        <title>Notifications Â· Settings Â· GramorX</title>
        <meta name="description" content="Manage how and when GramorX reaches out to you." />
      </Head>

      <div className="py-6">
        <Container>
          <header className="mb-4 flex flex-wrap items-center justify-between gap-3">
            <div>
              <h1 className="text-h2 font-bold text-foreground">Notification preferences</h1>
              <p className="text-small text-mutedText">
                Choose your channels, set quiet hours, and stay in control of reminders.
              </p>
            </div>
          </header>

          {error && (
            <Alert variant="error" appearance="soft" className="mb-4" role="alert">
              {error}
            </Alert>
          )}

          <section className="rounded-ds-2xl border border-border bg-card p-5 text-card-foreground">
            {loading && (
              <div className="space-y-3" aria-hidden>
                <Skeleton className="h-10 w-56 rounded-ds-xl" />
                <Skeleton className="h-5 w-full rounded-ds" />
                <Skeleton className="h-5 w-full rounded-ds" />
              </div>
            )}

            {!loading && (
              <form onSubmit={handleSubmit} className="space-y-6">
                <div className="space-y-4">
                  <Toggle
                    label="Email"
                    hint="Get summaries and important account updates in your inbox."
                    checked={form.channels.email}
                    onChange={(value) => handleChannelChange('email', value)}
                  />
                  <Toggle
                    label="WhatsApp"
                    hint="Receive quick nudges and reminders on WhatsApp."
                    checked={form.channels.whatsapp}
                    onChange={(value) => handleChannelChange('whatsapp', value)}
                  />
                </div>

                <div className="grid gap-4 md:grid-cols-2">
                  <Input
                    type="time"
                    label="Quiet hours start"
                    value={form.quietHoursStart ?? ''}
                    onChange={(event) => handleTimeChange('quietHoursStart', event.target.value)}
                  />
                  <Input
                    type="time"
                    label="Quiet hours end"
                    value={form.quietHoursEnd ?? ''}
                    onChange={(event) => handleTimeChange('quietHoursEnd', event.target.value)}
                  />
                  <div className="md:col-span-2">
                    <Select
                      label="Timezone"
                      value={form.timezone}
                      onChange={(event) => handleTimezoneChange(event.target.value)}
                      options={timezoneOptions.map((tz) => ({ value: tz, label: tz }))}
                    />
                  </div>
                </div>

                <div className="rounded-ds-xl border border-border bg-background p-4">
                  <h2 className="text-body font-semibold text-foreground">Delivery summary</h2>
                  <ul className="mt-2 space-y-2 text-small text-mutedText">
                    <li>
                      <span className="font-medium text-foreground">Email:</span>{' '}
                      {contact.email ? contact.email : 'Add an email in your profile to receive emails.'}
                    </li>
                    <li>
                      <span className="font-medium text-foreground">WhatsApp:</span>{' '}
                      {contact.phone ? (
                        <>
                          {contact.phone}
                          {!contact.phoneVerified && (
                            <span className="ml-2 rounded-full bg-warning/20 px-2 py-0.5 text-caption text-warning">
                              verification pending
                            </span>
                          )}
                        </>
                      ) : (
                        'Add a WhatsApp number to receive reminders.'
                      )}
                    </li>
                  </ul>
                </div>

                <div className="flex flex-wrap items-center gap-3">
                  <Button type="submit" disabled={status === 'saving'}>
                    Save preferences
                  </Button>
                  <span
                    ref={statusRef}
                    className="text-small text-mutedText"
                    role="status"
                    aria-live="polite"
                  >
                    {statusMessage}
                  </span>
                </div>
              </form>
            )}
          </section>

          <footer className="mt-6 flex flex-wrap items-center gap-3 text-small text-mutedText">
            <Link className="text-primary hover:underline" href="/legal/privacy">
              Privacy
            </Link>
            <span aria-hidden>Â·</span>
            <Link className="text-primary hover:underline" href="/legal/terms">
              Terms
            </Link>
            <span aria-hidden>Â·</span>
            <Link
              className="text-primary hover:underline"
              href="/settings/notifications?unsubscribe=1"
              onClick={(event) => {
                event.preventDefault();
                void handleUnsubscribe('manual');
              }}
            >
              Unsubscribe
            </Link>
          </footer>
        </Container>
      </div>
    </>
  );
}





============================================================
FILE #32
PATH: pages/onboarding/exam-date.tsx
============================================================
// pages/onboarding/exam-date.tsx
import type { NextPage } from 'next';
import { useRouter } from 'next/router';
import React, { useMemo, useState } from 'react';

import { Container } from '@/components/design-system/Container';
import { Button } from '@/components/design-system/Button';
import { Icon } from '@/components/design-system/Icon';
import { cn } from '@/lib/utils';

type OnboardingStepId =
  | 'language'
  | 'target-band'
  | 'exam-date'
  | 'study-rhythm'
  | 'notifications';

const ONBOARDING_STEPS: { id: OnboardingStepId; label: string }[] = [
  { id: 'language', label: 'Language' },
  { id: 'target-band', label: 'Target band' },
  { id: 'exam-date', label: 'Exam date' },
  { id: 'study-rhythm', label: 'Study rhythm' },
  { id: 'notifications', label: 'Notifications' },
];

type ExamTimeframe =
  | '0-30'
  | '30-60'
  | '60-90'
  | '90-plus'
  | 'not-booked';

interface TimeframeOption {
  id: ExamTimeframe;
  label: string;
  subtitle: string;
}

const TIMEFRAME_OPTIONS: TimeframeOption[] = [
  {
    id: '0-30',
    label: 'Within 30 days',
    subtitle: 'Very close â€” weâ€™ll focus on high-impact revision.',
  },
  {
    id: '30-60',
    label: '1â€“2 months from now',
    subtitle: 'Enough time for a structured plan and mocks.',
  },
  {
    id: '60-90',
    label: '2â€“3 months from now',
    subtitle: 'Ideal window for deep skill building.',
  },
  {
    id: '90-plus',
    label: 'More than 3 months away',
    subtitle: 'Slow and steady, with weekly consistency.',
  },
  {
    id: 'not-booked',
    label: 'I havenâ€™t booked yet',
    subtitle: 'Weâ€™ll suggest a realistic target date for you.',
  },
];

const OnboardingExamDatePage: NextPage = () => {
  const router = useRouter();
  const [timeframe, setTimeframe] = useState<ExamTimeframe>('60-90');
  const [specificDate, setSpecificDate] = useState('');
  const [submitting, setSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const nextPath = useMemo(() => {
    const { next } = router.query;
    return typeof next === 'string' ? next : '/dashboard';
  }, [router.query]);

  const currentIndex = useMemo(
    () => ONBOARDING_STEPS.findIndex((s) => s.id === 'exam-date'),
    []
  );

  function handleBack() {
    router.push({
      pathname: '/onboarding/target-band',
      query: { next: nextPath },
    });
  }

  async function handleContinue() {
    setError(null);

    if (!timeframe) {
      setError('Please choose how far away your exam is.');
      return;
    }

    // optional: simple check for date if user filled it
    if (specificDate && Number.isNaN(Date.parse(specificDate))) {
      setError('Please enter a valid exam date or clear the field.');
      return;
    }

    try {
      setSubmitting(true);

      // TODO: persist exam info to your backend / Supabase profile table.
      // Example (pseudo):
      // await fetch('/api/onboarding/exam-date', {
      //   method: 'POST',
      //   headers: { 'Content-Type': 'application/json' },
      //   body: JSON.stringify({ timeframe, specificDate: specificDate || null }),
      // });

      await router.push({
        pathname: '/onboarding/study-rhythm',
        query: { next: nextPath },
      });
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error(e);
      setError('Something went wrong while saving your exam plan.');
    } finally {
      setSubmitting(false);
    }
  }

  return (
    <main className="min-h-screen bg-background">
      <Container className="flex min-h-screen flex-col items-center justify-center py-10">
        {/* Progress rail */}
        <div className="mb-6 w-full max-w-3xl">
          <OnboardingProgress
            steps={ONBOARDING_STEPS}
            currentIndex={currentIndex}
          />
        </div>

        {/* Main card */}
        <section className="w-full max-w-3xl rounded-3xl border border-border bg-card/80 p-6 shadow-xl backdrop-blur-md sm:p-8">
          <header className="mb-6 flex flex-col gap-3 sm:flex-row sm:items-start sm:justify-between">
            <div>
              <p className="text-xs font-medium uppercase tracking-wide text-muted-foreground">
                Step {currentIndex + 1} of {ONBOARDING_STEPS.length}
              </p>
              <h1 className="mt-1 text-2xl font-semibold tracking-tight sm:text-3xl">
                When is your IELTS exam?
              </h1>
              <p className="mt-2 text-sm text-muted-foreground sm:text-base">
                We&apos;ll adjust the intensity of your study plan based on how
                close your test date is. Shorter timelines get tighter, more
                focused practice.
              </p>
            </div>

            <div className="flex shrink-0 items-center gap-2 self-start rounded-full bg-muted px-3 py-1 text-xs font-medium text-muted-foreground">
              <Icon name="calendar" className="h-3.5 w-3.5" />
              Smarter schedule, same 24 hours.
            </div>
          </header>

          {/* Timeframe grid */}
          <div className="grid gap-4 sm:grid-cols-2">
            {TIMEFRAME_OPTIONS.map((option) => (
              <TimeframeCard
                key={option.id}
                option={option}
                selected={timeframe === option.id}
                onSelect={() => setTimeframe(option.id)}
              />
            ))}
          </div>

          {/* Optional specific date */}
          <div className="mt-5 rounded-2xl border border-dashed border-border bg-muted/40 p-4">
            <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
              <div>
                <p className="text-sm font-medium">
                  Do you already know the exact date?
                </p>
                <p className="text-xs text-muted-foreground">
                  Optional, but it helps us align your milestones with the
                  calendar.
                </p>
              </div>

              <div className="mt-3 flex flex-col gap-2 sm:mt-0 sm:flex-row sm:items-center">
                <label
                  htmlFor="exam-date"
                  className="text-xs font-medium text-muted-foreground sm:text-right"
                >
                  Exam date
                </label>
                <input
                  id="exam-date"
                  type="date"
                  value={specificDate}
                  onChange={(e) => setSpecificDate(e.target.value)}
                  className="min-w-[180px] rounded-xl border border-border bg-background px-3 py-2 text-sm outline-none ring-offset-background placeholder:text-muted-foreground/70 focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2"
                />
              </div>
            </div>
          </div>

          {error && (
            <p className="mt-3 text-sm font-medium text-destructive">{error}</p>
          )}

          {/* Hint */}
          <p className="mt-4 text-xs text-muted-foreground">
            Not booked yet? No problem. Pick the option that feels closest and
            you can update the exact date anytime from{' '}
            <span className="font-medium">Settings â†’ Study plan</span>.
          </p>

          {/* Footer actions */}
          <footer className="mt-6 flex flex-col-reverse items-center justify-between gap-3 border-t border-border pt-4 sm:flex-row">
            <Button
              variant="ghost"
              size="sm"
              onClick={handleBack}
              className="text-muted-foreground"
            >
              <Icon name="arrow-left" className="mr-1.5 h-4 w-4" />
              Back
            </Button>

            <div className="flex items-center gap-3">
              <p className="hidden text-xs text-muted-foreground sm:inline">
                Next:{' '}
                <span className="font-medium">Choose your study rhythm</span>
              </p>
              <Button
                size="lg"
                onClick={handleContinue}
                disabled={submitting || !timeframe}
              >
                {submitting ? 'Savingâ€¦' : 'Continue'}
                <Icon name="arrow-right" className="ml-2 h-4 w-4" />
              </Button>
            </div>
          </footer>
        </section>
      </Container>
    </main>
  );
};

interface OnboardingProgressProps {
  steps: { id: OnboardingStepId; label: string }[];
  currentIndex: number;
}

const OnboardingProgress: React.FC<OnboardingProgressProps> = ({
  steps,
  currentIndex,
}) => {
  return (
    <div className="flex flex-col gap-2">
      <div className="flex items-center justify-between">
        {steps.map((step, index) => {
          const active = index === currentIndex;
          const completed = index < currentIndex;

          return (
            <div
              key={step.id}
              className="flex flex-1 items-center last:flex-none"
            >
              <div
                className={cn(
                  'flex h-7 w-7 items-center justify-center rounded-full border text-xs font-semibold',
                  completed &&
                    'border-primary bg-primary text-primary-foreground',
                  active &&
                    !completed &&
                    'border-primary/80 bg-primary/10 text-primary',
                  !active && !completed && 'border-border bg-muted text-muted-foreground'
                )}
              >
                {completed ? (
                  <Icon name="check" className="h-3.5 w-3.5" />
                ) : (
                  index + 1
                )}
              </div>

              {index < steps.length - 1 && (
                <div
                  className={cn(
                    'mx-1 h-px flex-1 rounded-full bg-border',
                    completed && 'bg-primary/70',
                    active && 'bg-primary/50'
                  )}
                />
              )}
            </div>
          );
        })}
      </div>

      <div className="flex justify-between text-xs text-muted-foreground">
        {steps.map((step, index) => {
          const active = index === currentIndex;
          return (
            <span
              key={step.id}
              className={cn(
                'flex-1 truncate text-center',
                active && 'font-medium text-foreground'
              )}
            >
              {step.label}
            </span>
          );
        })}
      </div>
    </div>
  );
};

interface TimeframeCardProps {
  option: TimeframeOption;
  selected: boolean;
  onSelect: () => void;
}

const TimeframeCard: React.FC<TimeframeCardProps> = ({
  option,
  selected,
  onSelect,
}) => {
  return (
    <button
      type="button"
      onClick={onSelect}
      className={cn(
        'group flex h-full flex-col justify-between rounded-2xl border p-4 text-left transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background sm:p-5',
        selected
          ? 'border-primary bg-primary/10 shadow-md'
          : 'border-border bg-muted/40 hover:border-primary/60 hover:bg-muted'
      )}
    >
      <div className="mb-2 flex items-center justify-between">
        <span className="text-base font-semibold sm:text-lg">
          {option.label}
        </span>
        <div
          className={cn(
            'flex h-5 w-5 items-center justify-center rounded-full border text-[10px] font-semibold transition-colors',
            selected
              ? 'border-primary bg-primary text-primary-foreground'
              : 'border-border bg-background text-muted-foreground group-hover:border-primary/70'
          )}
        >
          {selected ? <Icon name="check" className="h-3 w-3" /> : ''}
        </div>
      </div>
      <p className="text-xs text-muted-foreground sm:text-sm">
        {option.subtitle}
      </p>
    </button>
  );
};

export default OnboardingExamDatePage;





============================================================
FILE #33
PATH: pages/onboarding/notifications.tsx
============================================================
// pages/onboarding/notifications.tsx
import type { NextPage } from 'next';
import { useRouter } from 'next/router';
import React, { useMemo, useState } from 'react';

import { Container } from '@/components/design-system/Container';
import { Button } from '@/components/design-system/Button';
import { Icon } from '@/components/design-system/Icon';
import { cn } from '@/lib/utils';

type OnboardingStepId =
  | 'language'
  | 'target-band'
  | 'exam-date'
  | 'study-rhythm'
  | 'notifications';

const ONBOARDING_STEPS: { id: OnboardingStepId; label: string }[] = [
  { id: 'language', label: 'Language' },
  { id: 'target-band', label: 'Target band' },
  { id: 'exam-date', label: 'Exam date' },
  { id: 'study-rhythm', label: 'Study rhythm' },
  { id: 'notifications', label: 'Notifications' },
];

const STEP_ROUTES: Record<OnboardingStepId, string> = {
  language: '/onboarding',
  'target-band': '/onboarding/target-band',
  'exam-date': '/onboarding/exam-date',
  'study-rhythm': '/onboarding/study-rhythm',
  notifications: '/onboarding/notifications',
};

type ChannelId = 'email' | 'whatsapp' | 'in-app';

interface ChannelOption {
  id: ChannelId;
  label: string;
  description: string;
  badge?: string;
}

const CHANNEL_OPTIONS: ChannelOption[] = [
  {
    id: 'email',
    label: 'Email',
    description: 'Daily/weekly summaries, test reminders, and progress reports.',
    badge: 'Recommended',
  },
  {
    id: 'whatsapp',
    label: 'WhatsApp',
    description: 'Short nudges, streak alerts, and quick links to practice.',
  },
  {
    id: 'in-app',
    label: 'In-app only',
    description: 'Silent mode. See reminders only inside GramorX.',
  },
];

const OnboardingNotificationsPage: NextPage = () => {
  const router = useRouter();

  const [selectedChannels, setSelectedChannels] = useState<ChannelId[]>([
    'email',
  ]);
  const [submitting, setSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Final destination after onboarding
  const nextPath = useMemo(() => {
    const { next } = router.query;
    const raw = typeof next === 'string' ? next : '/dashboard';

    // never loop back into onboarding from final step
    if (!raw || raw.startsWith('/onboarding')) {
      return '/dashboard';
    }
    return raw;
  }, [router.query]);

  const currentIndex = useMemo(
    () => ONBOARDING_STEPS.findIndex((s) => s.id === 'notifications'),
    []
  );

  const hasChannel = selectedChannels.length > 0;

  function toggleChannel(id: ChannelId) {
    setSelectedChannels((prev) =>
      prev.includes(id) ? prev.filter((c) => c !== id) : [...prev, id]
    );
  }

  function handleStepClick(stepId: OnboardingStepId) {
    const pathname = STEP_ROUTES[stepId];
    if (!pathname) return;

    router.push({
      pathname,
      query: { next: nextPath },
    });
  }

  function handleBack() {
    router.push({
      pathname: STEP_ROUTES['study-rhythm'],
      query: { next: nextPath },
    });
  }

  async function handleFinish() {
    setError(null);

    if (!hasChannel) {
      setError('Pick at least one way for us to remind you.');
      return;
    }

    try {
      setSubmitting(true);

      const res = await fetch('/api/onboarding/complete', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          step: 5,
          channels: selectedChannels,
        }),
      });

      if (!res.ok) {
        // donâ€™t block navigation forever if server is grumpy;
        // but still show error text
        let msg = 'Failed to save onboarding.';
        try {
          const body = await res.json();
          if (body?.error) msg = body.error;
        } catch {
          // ignore JSON parse issues
        }
        setError(msg);
        return;
      }

      await router.push(nextPath || '/dashboard');
    } catch (e: any) {
      // eslint-disable-next-line no-console
      console.error(e);
      setError(
        e?.message || 'Could not save your notification settings. Try again.'
      );
    } finally {
      setSubmitting(false);
    }
  }

  return (
    <main className="min-h-screen bg-background">
      <Container className="flex min-h-screen flex-col items-center justify-center py-10">
        {/* Progress (clickable) */}
        <div className="mb-6 w-full max-w-3xl">
          <OnboardingProgress
            steps={ONBOARDING_STEPS}
            currentIndex={currentIndex}
            onStepClick={handleStepClick}
          />
        </div>

        {/* Card */}
        <section className="w-full max-w-3xl rounded-3xl border border-border bg-card/80 p-6 shadow-xl backdrop-blur-md sm:p-8">
          <header className="mb-6 flex flex-col gap-3 sm:flex-row sm:items-start sm:justify-between">
            <div>
              <p className="text-xs font-medium uppercase tracking-wide text-muted-foreground">
                Step {currentIndex + 1} of {ONBOARDING_STEPS.length}
              </p>
              <h1 className="mt-1 text-2xl font-semibold tracking-tight sm:text-3xl">
                How should we keep you on track?
              </h1>
              <p className="mt-2 text-sm text-muted-foreground sm:text-base">
                Choose where you want to receive study nudges, streak alerts,
                and mock test reminders. No spam â€” only what helps your band
                score.
              </p>
            </div>

            <div className="flex shrink-0 items-center gap-2 self-start rounded-full bg-muted px-3 py-1 text-xs font-medium text-muted-foreground">
              <Icon name="bell" className="h-3.5 w-3.5" />
              Smart reminders, not noise.
            </div>
          </header>

          {/* Channels */}
          <div className="grid gap-4 sm:grid-cols-3">
            {CHANNEL_OPTIONS.map((option) => (
              <ChannelCard
                key={option.id}
                option={option}
                selected={selectedChannels.includes(option.id)}
                onToggle={() => toggleChannel(option.id)}
              />
            ))}
          </div>

          {error && (
            <p className="mt-3 text-sm font-medium text-destructive">{error}</p>
          )}

          <p className="mt-4 text-xs text-muted-foreground sm:text-sm">
            You can fine-tune these later from{' '}
            <span className="font-medium">Settings â†’ Notifications</span>.
          </p>

          {/* Footer */}
          <footer className="mt-6 flex flex-col-reverse items-center justify-between gap-3 border-t border-border pt-4 sm:flex-row">
            <Button
              variant="ghost"
              size="sm"
              onClick={handleBack}
              className="text-muted-foreground"
            >
              <Icon name="arrow-left" className="mr-1.5 h-4 w-4" />
              Back
            </Button>

            <div className="flex items-center gap-3">
              <p className="hidden text-xs text-muted-foreground sm:inline">
                Finish and go to{' '}
                <span className="font-medium">
                  {nextPath === '/dashboard' ? 'dashboard' : nextPath}
                </span>
              </p>
              <Button
                size="lg"
                onClick={handleFinish}
                disabled={submitting || !hasChannel}
              >
                {submitting ? 'Finishingâ€¦' : 'Finish & continue'}
                <Icon name="arrow-right" className="ml-2 h-4 w-4" />
              </Button>
            </div>
          </footer>
        </section>
      </Container>
    </main>
  );
};

interface OnboardingProgressProps {
  steps: { id: OnboardingStepId; label: string }[];
  currentIndex: number;
  onStepClick?: (id: OnboardingStepId) => void;
}

const OnboardingProgress: React.FC<OnboardingProgressProps> = ({
  steps,
  currentIndex,
  onStepClick,
}) => {
  return (
    <div className="flex flex-col gap-2">
      {/* Rail */}
      <div className="flex items-center justify-between">
        {steps.map((step, index) => {
          const active = index === currentIndex;
          const completed = index < currentIndex;

          const circle = (
            <div
              className={cn(
                'flex h-7 w-7 items-center justify-center rounded-full border text-xs font-semibold',
                completed &&
                  'border-primary bg-primary text-primary-foreground',
                active &&
                  !completed &&
                  'border-primary/80 bg-primary/10 text-primary',
                !active &&
                  !completed &&
                  'border-border bg-muted text-muted-foreground'
              )}
            >
              {completed ? (
                <Icon name="check" className="h-3.5 w-3.5" />
              ) : (
                index + 1
              )}
            </div>
          );

          return (
            <div
              key={step.id}
              className="flex flex-1 items-center last:flex-none"
            >
              {onStepClick ? (
                <button
                  type="button"
                  onClick={() => onStepClick(step.id)}
                  className="flex items-center justify-center rounded-full focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background"
                >
                  {circle}
                </button>
              ) : (
                circle
              )}

              {index < steps.length - 1 && (
                <div
                  className={cn(
                    'mx-1 h-px flex-1 rounded-full bg-border',
                    completed && 'bg-primary/70',
                    active && 'bg-primary/50'
                  )}
                />
              )}
            </div>
          );
        })}
      </div>

      {/* Labels */}
      <div className="flex justify-between text-xs text-muted-foreground">
        {steps.map((step, index) => {
          const active = index === currentIndex;

          return (
            <button
              key={step.id}
              type="button"
              onClick={onStepClick ? () => onStepClick(step.id) : undefined}
              className="flex-1 focus-visible:outline-none"
            >
              <span
                className={cn(
                  'flex-1 truncate text-center',
                  active && 'font-medium text-foreground'
                )}
              >
                {step.label}
              </span>
            </button>
          );
        })}
      </div>
    </div>
  );
};

interface ChannelCardProps {
  option: ChannelOption;
  selected: boolean;
  onToggle: () => void;
}

const ChannelCard: React.FC<ChannelCardProps> = ({
  option,
  selected,
  onToggle,
}) => {
  const { label, description, badge } = option;

  return (
    <button
      type="button"
      onClick={onToggle}
      className={cn(
        'group flex h-full flex-col justify-between rounded-2xl border p-4 text-left transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background sm:p-5',
        selected
          ? 'border-primary bg-primary/10 shadow-md'
          : 'border-border bg-muted/40 hover:border-primary/60 hover:bg-muted'
      )}
    >
      <div className="mb-2 flex items-start justify-between gap-2">
        <div>
          <div className="flex items-center gap-2">
            <span className="inline-flex h-8 w-8 items-center justify-center rounded-full bg-primary/10 text-primary">
              <Icon name="bell" className="h-4 w-4" />
            </span>
            <span className="text-base font-semibold sm:text-lg">{label}</span>
          </div>
          <p className="mt-2 text-xs text-muted-foreground sm:text-sm">
            {description}
          </p>
        </div>

        <div
          className={cn(
            'flex h-5 w-5 items-center justify-center rounded-full border text-[10px] font-semibold transition-colors',
            selected
              ? 'border-primary bg-primary text-primary-foreground'
              : 'border-border bg-background text-muted-foreground group-hover:border-primary/70'
          )}
        >
          {selected ? <Icon name="check" className="h-3 w-3" /> : ''}
        </div>
      </div>

      {badge && (
        <span className="mt-3 inline-block rounded-full bg-primary/10 px-2 py-0.5 text-[10px] font-semibold text-primary">
          {badge}
        </span>
      )}
    </button>
  );
};

export default OnboardingNotificationsPage;





============================================================
FILE #34
PATH: pages/api/onboarding/index.ts
============================================================
import type { NextApiRequest, NextApiResponse } from 'next';

import { trackor } from '@/lib/analytics/trackor.server';
import { getServerClient } from '@/lib/supabaseServer';
import {
  TOTAL_ONBOARDING_STEPS,
  onboardingStateSchema,
  onboardingStepPayloadSchema,
  type OnboardingState,
  type OnboardingStepPayload,
} from '@/lib/onboarding/schema';

const SELECT_COLUMNS =
  // Alias DB "id" -> JSON "user_id" so your existing types continue to work
  'user_id:id,preferred_language,locale,goal_band,exam_date,study_days,study_minutes_per_day,whatsapp_opt_in,phone,notification_channels,onboarding_step,onboarding_complete';

type ErrorResponse = { error: string };

type ProfileRow = {
  user_id: string;
  preferred_language: string | null;
  locale: string | null;
  goal_band: number | null;
  exam_date: string | null;
  study_days: string[] | null;
  study_minutes_per_day: number | null;
  whatsapp_opt_in: boolean | null;
  phone: string | null;
  notification_channels: string[] | null;
  onboarding_step: number | null;
  onboarding_complete: boolean | null;
} | null;

const defaultState: OnboardingState = {
  preferredLanguage: null,
  goalBand: null,
  examDate: null,
  studyDays: null,
  studyMinutesPerDay: null,
  whatsappOptIn: null,
  phone: null,
  onboardingStep: 0,
  onboardingComplete: false,
};

function normalizeState(row: ProfileRow): OnboardingState {
  if (!row) return defaultState;

  const studyDays = Array.isArray(row.study_days) ? row.study_days.filter(Boolean) : [];

  return onboardingStateSchema.parse({
    preferredLanguage: row.preferred_language ?? row.locale ?? null,
    goalBand: typeof row.goal_band === 'number' ? row.goal_band : null,
    examDate: row.exam_date ?? null,
    studyDays: studyDays.length > 0 ? (studyDays as OnboardingState['studyDays']) : null,
    studyMinutesPerDay:
      typeof row.study_minutes_per_day === 'number' && row.study_minutes_per_day > 0
        ? row.study_minutes_per_day
        : null,
    whatsappOptIn: typeof row.whatsapp_opt_in === 'boolean' ? row.whatsapp_opt_in : null,
    phone: row.phone ?? null,
    onboardingStep: typeof row.onboarding_step === 'number' ? row.onboarding_step : 0,
    onboardingComplete: row.onboarding_complete === true,
  });
}

async function fetchProfileRow(
  supabase: ReturnType<typeof getServerClient>,
  userId: string,
): Promise<ProfileRow> {
  const { data, error } = await supabase
    .from('profiles')
    .select(SELECT_COLUMNS)
    .eq('id', userId) // canonical column
    .maybeSingle();

  if (error && error.code !== 'PGRST116') {
    throw new Error(error.message || 'Unable to load profile');
  }

  return (data as ProfileRow) ?? null;
}

async function upsertProfile(
  supabase: ReturnType<typeof getServerClient>,
  userId: string,
  payload: Record<string, unknown>,
): Promise<ProfileRow> {
  const { data, error } = await supabase
    .from('profiles')
    // IMPORTANT: never set user_id (generated); write id instead
    .upsert({ id: userId, ...payload }, { onConflict: 'id' })
    .select(SELECT_COLUMNS)
    .eq('id', userId)
    .maybeSingle();

  if (error) {
    throw new Error(error.message || 'Unable to save onboarding progress');
  }

  return (data as ProfileRow) ?? null;
}

async function handleGet(
  req: NextApiRequest,
  res: NextApiResponse<OnboardingState | ErrorResponse>,
) {
  const supabase = getServerClient(req, res);
  const { data: auth, error } = await supabase.auth.getUser();
  if (error || !auth.user) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const row = await fetchProfileRow(supabase, auth.user.id);
    return res.status(200).json(normalizeState(row));
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to load onboarding state';
    return res.status(500).json({ error: message });
  }
}

async function handlePost(
  req: NextApiRequest,
  res: NextApiResponse<OnboardingState | ErrorResponse>,
) {
  const supabase = getServerClient(req, res);
  const { data: auth, error } = await supabase.auth.getUser();
  if (error || !auth.user) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const parseResult = onboardingStepPayloadSchema.safeParse(req.body);
  if (!parseResult.success) {
    const detail = parseResult.error.issues.map((issue) => issue.message).join(', ');
    return res.status(400).json({ error: detail || 'Invalid payload' });
  }

  const payload = parseResult.data;

  try {
    const currentRow = await fetchProfileRow(supabase, auth.user.id);
    const currentState = normalizeState(currentRow);
    const profileRow = await applyStep(
      supabase,
      auth.user.id,
      payload,
      currentState,
      currentRow,
    );
    return res.status(200).json(normalizeState(profileRow));
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Failed to save onboarding step';
    return res.status(500).json({ error: message });
  }
}

async function applyStep(
  supabase: ReturnType<typeof getServerClient>,
  userId: string,
  payload: OnboardingStepPayload,
  current: OnboardingState,
  row: ProfileRow,
): Promise<ProfileRow> {
  const updates: Record<string, unknown> = {};
  let nextStep = Math.max(current.onboardingStep ?? 0, payload.step);
  let nextComplete = current.onboardingComplete;

  if (payload.step === 1) {
    updates.preferred_language = payload.data.preferredLanguage;
    updates.locale = payload.data.preferredLanguage;
  }

  if (payload.step === 2) {
    updates.goal_band = payload.data.goalBand;
  }

  if (payload.step === 3) {
    const examDate = payload.data.examDate?.trim() ? payload.data.examDate : null;
    updates.exam_date = examDate;
  }

  if (payload.step === 4) {
    updates.study_days = payload.data.studyDays;
    updates.study_minutes_per_day = payload.data.minutesPerDay;
  }

  if (payload.step === 5) {
    const phone = payload.data.phone?.trim() ? payload.data.phone.trim() : null;
    updates.whatsapp_opt_in = payload.data.whatsappOptIn;
    updates.phone = phone;

    if (current.phone && !phone) {
      updates.phone = null;
    }

    const existingChannels = Array.isArray(row?.notification_channels)
      ? new Set<string>(row?.notification_channels ?? [])
      : new Set<string>();

    if (payload.data.whatsappOptIn) {
      existingChannels.add('whatsapp');
    } else {
      existingChannels.delete('whatsapp');
    }

    updates.notification_channels = Array.from(existingChannels);

    nextStep = TOTAL_ONBOARDING_STEPS;
    nextComplete = true;
  }

  if (payload.step < TOTAL_ONBOARDING_STEPS && !current.onboardingComplete) {
    nextComplete = false;
  }

  updates.onboarding_step = nextStep;
  updates.onboarding_complete = nextComplete;

  const becameComplete = !current.onboardingComplete && nextComplete;
  const hasStarted = current.onboardingStep <= 0 && payload.step >= 1 && !current.onboardingComplete;

  const profileRow = await upsertProfile(supabase, userId, updates);

  if (hasStarted) {
    await trackor.log('onboarding_start', { user_id: userId, step: payload.step });
  }

  const trackPayload: Record<string, unknown> = { user_id: userId, step: payload.step };
  if (payload.step === 1) trackPayload.preferred_language = payload.data.preferredLanguage;
  if (payload.step === 2) trackPayload.goal_band = payload.data.goalBand;
  if (payload.step === 3) trackPayload.exam_date = updates.exam_date ?? null;
  if (payload.step === 4) {
    trackPayload.study_days = payload.data.studyDays;
    trackPayload.minutes_per_day = payload.data.minutesPerDay;
  }
  if (payload.step === 5) trackPayload.whatsapp_opt_in = payload.data.whatsappOptIn;

  await trackor.log('onboarding_step_complete', trackPayload);

  if (becameComplete) {
    await trackor.log('onboarding_done', { user_id: userId });
    await supabase.auth.updateUser({ data: { onboarding_complete: true } });
  }

  return profileRow;
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<OnboardingState | ErrorResponse>,
) {
  if (req.method === 'GET') return handleGet(req, res);
  if (req.method === 'POST') return handlePost(req, res);

  res.setHeader('Allow', 'GET,POST');
  return res.status(405).json({ error: 'Method not allowed' });
}





============================================================
FILE #35
PATH: pages/onboarding/target-band.tsx
============================================================
// pages/onboarding/target-band.tsx
import type { NextPage } from 'next';
import { useRouter } from 'next/router';
import React, { useMemo, useState } from 'react';

import { Container } from '@/components/design-system/Container';
import { Button } from '@/components/design-system/Button';
import { Icon } from '@/components/design-system/Icon';
import { cn } from '@/lib/utils';

type OnboardingStepId =
  | 'language'
  | 'target-band'
  | 'exam-date'
  | 'study-rhythm'
  | 'notifications';

const ONBOARDING_STEPS: { id: OnboardingStepId; label: string }[] = [
  { id: 'language', label: 'Language' },
  { id: 'target-band', label: 'Target band' },
  { id: 'exam-date', label: 'Exam date' },
  { id: 'study-rhythm', label: 'Study rhythm' },
  { id: 'notifications', label: 'Notifications' },
];

const STEP_ROUTES: Record<OnboardingStepId, string> = {
  language: '/onboarding',
  'target-band': '/onboarding/target-band',
  'exam-date': '/onboarding/exam-date',
  'study-rhythm': '/onboarding/study-rhythm',
  notifications: '/onboarding/notifications',
};

type TargetBand =
  | '5.5'
  | '6.0'
  | '6.5'
  | '7.0'
  | '7.5+';

interface TargetBandOption {
  id: TargetBand;
  label: string;
  subtitle: string;
  badge?: string;
}

const TARGET_OPTIONS: TargetBandOption[] = [
  {
    id: '5.5',
    label: 'Band 5.5',
    subtitle: 'Solid starter goal if youâ€™re still building basics.',
  },
  {
    id: '6.0',
    label: 'Band 6.0',
    subtitle: 'Good for foundation programs and many colleges.',
  },
  {
    id: '6.5',
    label: 'Band 6.5',
    subtitle: 'Common requirement for universities and visas.',
    badge: 'Most popular',
  },
  {
    id: '7.0',
    label: 'Band 7.0',
    subtitle: 'Competitive score for top universities and jobs.',
  },
  {
    id: '7.5+',
    label: 'Band 7.5 or above',
    subtitle: 'Ambitious target â€” weâ€™ll push you harder.',
  },
];

const OnboardingTargetBandPage: NextPage = () => {
  const router = useRouter();
  const [targetBand, setTargetBand] = useState<TargetBand | null>('6.5');
  const [submitting, setSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const nextPath = useMemo(() => {
    const { next } = router.query;
    return typeof next === 'string' ? next : '/dashboard';
  }, [router.query]);

  const currentIndex = useMemo(
    () => ONBOARDING_STEPS.findIndex((s) => s.id === 'target-band'),
    []
  );

  function handleBack() {
    router.push({
      pathname: STEP_ROUTES.language,
      query: { next: nextPath },
    });
  }

  function handleStepClick(stepId: OnboardingStepId) {
    const pathname = STEP_ROUTES[stepId];
    if (!pathname) return;

    // keep ?next= consistent
    router.push({
      pathname,
      query: { next: nextPath },
    });
  }

  async function handleContinue() {
    setError(null);

    if (!targetBand) {
      setError('Please choose a target band to continue.');
      return;
    }

    try {
      setSubmitting(true);

      // TODO: wire this to Supabase (profiles.goal_band / target_band)
      // await fetch('/api/onboarding/target-band', {
      //   method: 'POST',
      //   headers: { 'Content-Type': 'application/json' },
      //   body: JSON.stringify({ targetBand }),
      // });

      // âœ… go to next step
      await router.push({
        pathname: STEP_ROUTES['exam-date'],
        query: { next: nextPath },
      });
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error(e);
      setError('Something went wrong. Please try again.');
    } finally {
      setSubmitting(false);
    }
  }

  return (
    <main className="min-h-screen bg-background">
      <Container className="flex min-h-screen flex-col items-center justify-center py-10">
        {/* Progress rail (clickable) */}
        <div className="mb-6 w-full max-w-3xl">
          <OnboardingProgress
            steps={ONBOARDING_STEPS}
            currentIndex={currentIndex}
            onStepClick={handleStepClick}
          />
        </div>

        {/* Main card */}
        <section className="w-full max-w-3xl rounded-3xl border border-border bg-card/80 p-6 shadow-xl backdrop-blur-md sm:p-8">
          <header className="mb-6 flex flex-col gap-3 sm:flex-row sm:items-start sm:justify-between">
            <div>
              <p className="text-xs font-medium uppercase tracking-wide text-muted-foreground">
                Step {currentIndex + 1} of {ONBOARDING_STEPS.length}
              </p>
              <h1 className="mt-1 text-2xl font-semibold tracking-tight sm:text-3xl">
                What&apos;s your target band score?
              </h1>
              <p className="mt-2 text-sm text-muted-foreground sm:text-base">
                Your goal band helps us set difficulty, pick question types, and
                plan how aggressive your schedule should be.
              </p>
            </div>

            <div className="flex shrink-0 items-center gap-2 self-start rounded-full bg-muted px-3 py-1 text-xs font-medium text-muted-foreground">
              <Icon name="target" className="h-3.5 w-3.5" />
              Clear goal, clearer path.
            </div>
          </header>

          {/* Options */}
          <div className="grid gap-4 sm:grid-cols-2">
            {TARGET_OPTIONS.map((option) => (
              <TargetBandCard
                key={option.id}
                option={option}
                selected={targetBand === option.id}
                onSelect={() => setTargetBand(option.id)}
              />
            ))}
          </div>

          {error && (
            <p className="mt-3 text-sm font-medium text-destructive">{error}</p>
          )}

          {/* Hint */}
          <p className="mt-4 text-xs text-muted-foreground">
            Not 100% sure? Pick the band youâ€™d be happy with. You can always
            adjust it later from{' '}
            <span className="font-medium">Profile â†’ Goals</span>.
          </p>

          {/* Footer */}
          <footer className="mt-6 flex flex-col-reverse items-center justify-between gap-3 border-t border-border pt-4 sm:flex-row">
            <Button
              variant="ghost"
              size="sm"
              onClick={handleBack}
              className="text-muted-foreground"
            >
              <Icon name="arrow-left" className="mr-1.5 h-4 w-4" />
              Back
            </Button>

            <div className="flex items-center gap-3">
              <p className="hidden text-xs text-muted-foreground sm:inline">
                Next: <span className="font-medium">Exam date</span>
              </p>
              <Button
                size="lg"
                onClick={handleContinue}
                disabled={submitting || !targetBand}
              >
                {submitting ? 'Savingâ€¦' : 'Continue'}
                <Icon name="arrow-right" className="ml-2 h-4 w-4" />
              </Button>
            </div>
          </footer>
        </section>
      </Container>
    </main>
  );
};

interface OnboardingProgressProps {
  steps: { id: OnboardingStepId; label: string }[];
  currentIndex: number;
  onStepClick?: (id: OnboardingStepId) => void;
}

const OnboardingProgress: React.FC<OnboardingProgressProps> = ({
  steps,
  currentIndex,
  onStepClick,
}) => {
  return (
    <div className="flex flex-col gap-2">
      {/* Dots / rail */}
      <div className="flex items-center justify-between">
        {steps.map((step, index) => {
          const active = index === currentIndex;
          const completed = index < currentIndex;

          const circle = (
            <div
              className={cn(
                'flex h-7 w-7 items-center justify-center rounded-full border text-xs font-semibold',
                completed &&
                  'border-primary bg-primary text-primary-foreground',
                active &&
                  !completed &&
                  'border-primary/80 bg-primary/10 text-primary',
                !active &&
                  !completed &&
                  'border-border bg-muted text-muted-foreground'
              )}
            >
              {completed ? (
                <Icon name="check" className="h-3.5 w-3.5" />
              ) : (
                index + 1
              )}
            </div>
          );

          return (
            <div
              key={step.id}
              className="flex flex-1 items-center last:flex-none"
            >
              {onStepClick ? (
                <button
                  type="button"
                  onClick={() => onStepClick(step.id)}
                  className="flex items-center justify-center rounded-full focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background"
                >
                  {circle}
                </button>
              ) : (
                circle
              )}

              {index < steps.length - 1 && (
                <div
                  className={cn(
                    'mx-1 h-px flex-1 rounded-full bg-border',
                    completed && 'bg-primary/70',
                    active && 'bg-primary/50'
                  )}
                />
              )}
            </div>
          );
        })}
      </div>

      {/* Labels */}
      <div className="flex justify-between text-xs text-muted-foreground">
        {steps.map((step, index) => {
          const active = index === currentIndex;
          const label = (
            <span
              className={cn(
                'flex-1 truncate text-center',
                active && 'font-medium text-foreground'
              )}
            >
              {step.label}
            </span>
          );

          return (
            <button
              key={step.id}
              type="button"
              onClick={onStepClick ? () => onStepClick(step.id) : undefined}
              className="flex-1 focus-visible:outline-none"
            >
              {label}
            </button>
          );
        })}
      </div>
    </div>
  );
};

interface TargetBandCardProps {
  option: TargetBandOption;
  selected: boolean;
  onSelect: () => void;
}

const TargetBandCard: React.FC<TargetBandCardProps> = ({
  option,
  selected,
  onSelect,
}) => {
  return (
    <button
      type="button"
      onClick={onSelect}
      className={cn(
        'group flex h-full flex-col justify-between rounded-2xl border p-4 text-left transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background sm:p-5',
        selected
          ? 'border-primary bg-primary/10 shadow-md'
          : 'border-border bg-muted/40 hover:border-primary/60 hover:bg-muted'
      )}
    >
      <div className="mb-2 flex items-center justify-between gap-2">
        <div className="flex items-center gap-2">
          <span className="inline-flex h-8 w-8 items-center justify-center rounded-full bg-primary/10 text-primary">
            <Icon name="target" className="h-4 w-4" />
          </span>
          <span className="text-base font-semibold sm:text-lg">
            {option.label}
          </span>
        </div>

        <div
          className={cn(
            'flex h-5 w-5 items-center justify-center rounded-full border text-[10px] font-semibold transition-colors',
            selected
              ? 'border-primary bg-primary text-primary-foreground'
              : 'border-border bg-background text-muted-foreground group-hover:border-primary/70'
          )}
        >
          {selected ? <Icon name="check" className="h-3 w-3" /> : ''}
        </div>
      </div>

      <p className="text-xs text-muted-foreground sm:text-sm">
        {option.subtitle}
      </p>

      {option.badge && (
        <span className="mt-3 inline-block rounded-full bg-primary/10 px-2 py-0.5 text-[10px] font-semibold text-primary">
          {option.badge}
        </span>
      )}
    </button>
  );
};

export default OnboardingTargetBandPage;





============================================================
FILE #36
PATH: pages/onboarding/study-rhythm.tsx
============================================================
// pages/onboarding/study-rhythm.tsx
import type { NextPage } from 'next';
import { useRouter } from 'next/router';
import React, { useMemo, useState } from 'react';

import { Container } from '@/components/design-system/Container';
import { Button } from '@/components/design-system/Button';
import { Icon } from '@/components/design-system/Icon';
import { cn } from '@/lib/utils';

type OnboardingStepId =
  | 'language'
  | 'target-band'
  | 'exam-date'
  | 'study-rhythm'
  | 'notifications';

const ONBOARDING_STEPS: { id: OnboardingStepId; label: string }[] = [
  { id: 'language', label: 'Language' },
  { id: 'target-band', label: 'Target band' },
  { id: 'exam-date', label: 'Exam date' },
  { id: 'study-rhythm', label: 'Study rhythm' },
  { id: 'notifications', label: 'Notifications' },
];

type RhythmOption =
  | 'daily'
  | '5days'
  | 'weekends'
  | 'flexible'
  | 'intensive';

interface RhythmChoice {
  id: RhythmOption;
  label: string;
  subtitle: string;
  badge?: string;
}

const OPTIONS: RhythmChoice[] = [
  {
    id: 'daily',
    label: 'Daily study',
    subtitle: 'Short sessions every day â†’ fastest improvement.',
    badge: 'Recommended',
  },
  {
    id: '5days',
    label: '5 days a week',
    subtitle: 'Weekdays only. Balanced routine for professionals.',
  },
  {
    id: 'weekends',
    label: 'Weekends only',
    subtitle: 'Longer sessions on Saturday & Sunday.',
  },
  {
    id: 'flexible',
    label: 'Flexible schedule',
    subtitle: 'You pick your own days each week.',
  },
  {
    id: 'intensive',
    label: 'Intensive mode',
    subtitle: '2â€“3 hours daily. Best for < 30 days exams.',
  },
];

const OnboardingStudyRhythmPage: NextPage = () => {
  const router = useRouter();
  const [selected, setSelected] = useState<RhythmOption>('daily');
  const [submitting, setSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const nextPath = useMemo(() => {
    const { next } = router.query;
    return typeof next === 'string' ? next : '/dashboard';
  }, [router.query]);

  const currentIndex = useMemo(
    () => ONBOARDING_STEPS.findIndex((s) => s.id === 'study-rhythm'),
    []
  );

  function handleBack() {
    router.push({
      pathname: '/onboarding/exam-date',
      query: { next: nextPath },
    });
  }

  async function handleContinue() {
    setError(null);

    try {
      setSubmitting(true);

      // TODO: save to DB
      // await fetch('/api/onboarding/study-rhythm', { ... })

      await router.push({
        pathname: '/onboarding/notifications',
        query: { next: nextPath },
      });
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error(e);
      setError('Could not save your rhythm. Try again.');
    } finally {
      setSubmitting(false);
    }
  }

  return (
    <main className="min-h-screen bg-background">
      <Container className="flex min-h-screen flex-col items-center justify-center py-10">
        {/* Progress */}
        <div className="mb-6 w-full max-w-3xl">
          <OnboardingProgress
            steps={ONBOARDING_STEPS}
            currentIndex={currentIndex}
          />
        </div>

        {/* Card */}
        <section className="w-full max-w-3xl rounded-3xl border border-border bg-card/80 p-6 shadow-xl backdrop-blur-md sm:p-8">
          <header className="mb-6 flex flex-col gap-3 sm:flex-row sm:items-start sm:justify-between">
            <div>
              <p className="text-xs font-medium uppercase tracking-wide text-muted-foreground">
                Step {currentIndex + 1} of {ONBOARDING_STEPS.length}
              </p>
              <h1 className="mt-1 text-2xl font-semibold tracking-tight sm:text-3xl">
                How do you prefer to study?
              </h1>
              <p className="mt-2 text-sm text-muted-foreground sm:text-base">
                Your rhythm helps us shape daily tasks, reminders, rest days,
                and mock-test scheduling. You can update it anytime.
              </p>
            </div>

            <div className="flex shrink-0 items-center gap-2 self-start rounded-full bg-muted px-3 py-1 text-xs font-medium text-muted-foreground">
              <Icon name="alarm-clock" className="h-3.5 w-3.5" />
              Consistency beats intensity.
            </div>
          </header>

          {/* Option grid */}
          <div className="grid gap-4 sm:grid-cols-2">
            {OPTIONS.map((option) => (
              <RhythmCard
                key={option.id}
                option={option}
                selected={selected === option.id}
                onSelect={() => setSelected(option.id)}
              />
            ))}
          </div>

          {error && (
            <p className="mt-3 text-sm font-medium text-destructive">{error}</p>
          )}

          <p className="mt-4 text-xs text-muted-foreground">
            Donâ€™t worry â€” your study plan adapts automatically as your exam date
            gets closer.
          </p>

          {/* Footer actions */}
          <footer className="mt-6 flex flex-col-reverse items-center justify-between gap-3 border-t border-border pt-4 sm:flex-row">
            <Button
              variant="ghost"
              size="sm"
              onClick={handleBack}
              className="text-muted-foreground"
            >
              <Icon name="arrow-left" className="mr-1.5 h-4 w-4" />
              Back
            </Button>

            <div className="flex items-center gap-3">
              <p className="hidden text-xs text-muted-foreground sm:inline">
                Next: <span className="font-medium">Notifications</span>
              </p>
              <Button
                size="lg"
                onClick={handleContinue}
                disabled={submitting || !selected}
              >
                {submitting ? 'Savingâ€¦' : 'Continue'}
                <Icon name="arrow-right" className="ml-2 h-4 w-4" />
              </Button>
            </div>
          </footer>
        </section>
      </Container>
    </main>
  );
};

/* --- Progress Component --- */
const OnboardingProgress: React.FC<{
  steps: { id: OnboardingStepId; label: string }[];
  currentIndex: number;
}> = ({ steps, currentIndex }) => {
  return (
    <div className="flex flex-col gap-2">
      <div className="flex items-center justify-between">
        {steps.map((step, index) => {
          const active = index === currentIndex;
          const completed = index < currentIndex;

          return (
            <div
              key={step.id}
              className="flex flex-1 items-center last:flex-none"
            >
              <div
                className={cn(
                  'flex h-7 w-7 items-center justify-center rounded-full border text-xs font-semibold',
                  completed &&
                    'border-primary bg-primary text-primary-foreground',
                  active &&
                    !completed &&
                    'border-primary/80 bg-primary/10 text-primary',
                  !active && !completed && 'border-border bg-muted text-muted-foreground'
                )}
              >
                {completed ? (
                  <Icon name="check" className="h-3.5 w-3.5" />
                ) : (
                  index + 1
                )}
              </div>

              {index < steps.length - 1 && (
                <div
                  className={cn(
                    'mx-1 h-px flex-1 rounded-full bg-border',
                    completed && 'bg-primary/70',
                    active && 'bg-primary/50'
                  )}
                />
              )}
            </div>
          );
        })}
      </div>

      <div className="flex justify-between text-xs text-muted-foreground">
        {steps.map((step, index) => (
          <span
            key={step.id}
            className={cn(
              'flex-1 truncate text-center',
              index === currentIndex && 'font-medium text-foreground'
            )}
          >
            {step.label}
          </span>
        ))}
      </div>
    </div>
  );
};

/* --- Rhythm Card --- */
const RhythmCard: React.FC<{
  option: RhythmChoice;
  selected: boolean;
  onSelect: () => void;
}> = ({ option, selected, onSelect }) => {
  return (
    <button
      type="button"
      onClick={onSelect}
      className={cn(
        'group flex h-full flex-col justify-between rounded-2xl border p-4 text-left transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background sm:p-5',
        selected
          ? 'border-primary bg-primary/10 shadow-md'
          : 'border-border bg-muted/40 hover:border-primary/60 hover:bg-muted'
      )}
    >
      <div className="mb-2 flex items-center justify-between">
        <span className="text-base font-semibold sm:text-lg">
          {option.label}
        </span>

        <div
          className={cn(
            'flex h-5 w-5 items-center justify-center rounded-full border text-[10px] font-semibold transition-colors',
            selected
              ? 'border-primary bg-primary text-primary-foreground'
              : 'border-border bg-background text-muted-foreground group-hover:border-primary/70'
          )}
        >
          {selected ? <Icon name="check" className="h-3 w-3" /> : ''}
        </div>
      </div>

      <p className="text-xs text-muted-foreground sm:text-sm">
        {option.subtitle}
      </p>

      {option.badge && (
        <span className="mt-3 inline-block rounded-full bg-primary/10 px-2 py-0.5 text-[10px] font-semibold text-primary">
          {option.badge}
        </span>
      )}
    </button>
  );
};

export default OnboardingStudyRhythmPage;





============================================================
FILE #37
PATH: pages/api/onboarding/complete.ts
============================================================
// pages/api/onboarding/complete.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { z } from 'zod';

import { getServerClient } from '@/lib/supabaseServer';

const Body = z.object({
  step: z
    .union([
      z.number().int(),
      z.string().transform((v) => {
        const n = Number.parseInt(v, 10);
        return Number.isNaN(n) ? 5 : n;
      }),
    ])
    .optional(),
  channels: z
    .array(z.enum(['email', 'whatsapp', 'in-app']))
    .min(1)
    .optional(),
});

function normalizeBody(req: NextApiRequest): unknown {
  const raw = req.body;
  if (typeof raw === 'string') {
    try {
      return JSON.parse(raw);
    } catch {
      return {};
    }
  }

  if (raw instanceof Buffer) {
    try {
      return JSON.parse(raw.toString('utf8'));
    } catch {
      return {};
    }
  }

  if (raw == null) return {};
  return raw;
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const body = normalizeBody(req);
  const parse = Body.safeParse(body);

  let step = 5;
  let channels: ('email' | 'whatsapp' | 'in-app')[] | undefined;

  if (parse.success) {
    step = parse.data.step ?? 5;
    channels = parse.data.channels;
  } else {
    console.warn(
      'onboarding/complete: body validation failed',
      parse.error.flatten()
    );
  }

  const supabase = getServerClient(req, res);
  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser();

  if (authError) {
    console.error('onboarding/complete auth error:', authError);
  }

  if (!user) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const patch: Record<string, any> = {
    onboarding_step: step,
    onboarding_complete: true,
    draft: false,
  };

  if (channels && channels.length > 0) {
    patch.notification_channels = channels;
  }

  const { error: updateError } = await supabase
    .from('profiles')
    .update(patch)
    .eq('user_id', user.id);

  if (updateError) {
    console.error('onboarding/complete update error:', updateError);
    return res.status(500).json({ error: 'Failed to update profile' });
  }

  return res.status(200).json({ ok: true });
}





============================================================
FILE #38
PATH: pages/account/billing.tsx
============================================================
// pages/account/billing.tsx
import * as React from 'react';
import Head from 'next/head';
import Link from 'next/link';
import { useRouter } from 'next/router';
import type { GetServerSideProps } from 'next';

import { getServerClient } from '@/lib/supabaseServer';

import { Alert } from '@/components/design-system/Alert';
import { Badge } from '@/components/design-system/Badge';
import { Button } from '@/components/design-system/Button';
import { Card, CardContent, CardHeader } from '@/components/design-system/Card';
import { Heading } from '@/components/design-system/Heading';
import { Section } from '@/components/design-system/Section';
import { SectionLabel } from '@/components/design-system/SectionLabel';
import { Skeleton } from '@/components/design-system/Skeleton';

type Invoice = {
  id: string;
  amount: number;
  currency: string;
  createdAt: string;
  hostedInvoiceUrl?: string;
  status: 'paid' | 'open' | 'void' | 'uncollectible' | 'draft';
};

type Summary = {
  plan: 'free' | 'starter' | 'booster' | 'master';
  status:
    | 'active'
    | 'trialing'
    | 'canceled'
    | 'incomplete'
    | 'past_due'
    | 'unpaid'
    | 'paused';
  renewsAt?: string;
  trialEndsAt?: string;
};

type Due = {
  id: string;
  amount_cents: number;
  currency: string;
  created_at: string;
  status: 'due' | 'collected' | 'canceled';
  plan_key: 'starter' | 'booster' | 'master';
  cycle: 'monthly' | 'annual';
};

export const getServerSideProps: GetServerSideProps = async (ctx) => {
  const { req, res, resolvedUrl } = ctx;
  const supabase = getServerClient(req, res);
  const { data, error } = await supabase.auth.getUser();

  if (error || !data?.user) {
    return {
      redirect: {
        destination: `/login?next=${encodeURIComponent(resolvedUrl)}`,
        permanent: false,
      },
    };
  }

  return { props: {} };
};

const toTitleCase = (value: string) =>
  value
    .replace(/_/g, ' ')
    .replace(/\b\w/g, (char) => char.toUpperCase());

const getStatusVariant = (status: Summary['status']) => {
  switch (status) {
    case 'active':
      return 'success';
    case 'trialing':
      return 'info';
    case 'past_due':
    case 'incomplete':
      return 'warning';
    case 'unpaid':
      return 'danger';
    case 'paused':
      return 'secondary';
    case 'canceled':
    default:
      return 'neutral';
  }
};

const getInvoiceVariant = (status: Invoice['status']) => {
  switch (status) {
    case 'paid':
      return 'success';
    case 'open':
      return 'info';
    case 'draft':
      return 'secondary';
    case 'uncollectible':
      return 'danger';
    case 'void':
    default:
      return 'neutral';
  }
};

const getDueVariant = (status: Due['status']) => {
  switch (status) {
    case 'due':
      return 'warning';
    case 'collected':
      return 'success';
    case 'canceled':
    default:
      return 'neutral';
  }
};

// ------------------- Client component -------------------
export default function BillingPage() {
  const router = useRouter();
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<string | null>(null);
  const [summary, setSummary] = React.useState<Summary | null>(null);
  const [invoices, setInvoices] = React.useState<Invoice[]>([]);
  const [dues, setDues] = React.useState<Due[]>([]);
  const [portalLoading, setPortalLoading] = React.useState(false);
  const [portalAvailable, setPortalAvailable] = React.useState(true);

  // ðŸ‘‡ new: detect vaulted flag from query (means user just saved a card)
  const justVaulted = router.query.vaulted === '1';

  const providerValue = router.query['provider'];
  const providerParam = Array.isArray(providerValue)
    ? providerValue[0] ?? null
    : typeof providerValue === 'string'
    ? providerValue
    : null;

  const statusValue = router.query['status'];
  const statusParam = Array.isArray(statusValue)
    ? statusValue[0] ?? null
    : typeof statusValue === 'string'
    ? statusValue
    : null;

  const reasonValue = router.query['reason'];
  const reasonParam = Array.isArray(reasonValue)
    ? reasonValue[0] ?? null
    : typeof reasonValue === 'string'
    ? reasonValue
    : null;

  const setupValue = router.query['setup'];
  const setupParam = Array.isArray(setupValue)
    ? setupValue[0] ?? null
    : typeof setupValue === 'string'
    ? setupValue
    : null;

  const safepayStatus = providerParam === 'safepay' ? statusParam : null;
  const safepayReason = providerParam === 'safepay' ? reasonParam : null;
  const showSafepaySetup = providerParam === 'safepay' && (setupParam === '1' || setupParam === 'true');
  const showSafepayPending = safepayStatus === 'pending';
  const showSafepayCancelled = safepayStatus === 'cancelled' || safepayStatus === 'canceled';
  const showSafepayFailed = safepayStatus === 'failed';
  const showSafepayError = safepayStatus === 'error';

  const dateFormatter = React.useMemo(
    () => new Intl.DateTimeFormat(undefined, { dateStyle: 'medium' }),
    []
  );
  const dateTimeFormatter = React.useMemo(
    () =>
      new Intl.DateTimeFormat(undefined, {
        dateStyle: 'medium',
        timeStyle: 'short',
      }),
    []
  );
  const currencyFormatter = React.useCallback(
    (amount: number, currency: string) =>
      new Intl.NumberFormat(undefined, {
        style: 'currency',
        currency,
      }).format(amount),
    []
  );

  const formatDate = React.useCallback(
    (value?: string | null) =>
      value ? dateFormatter.format(new Date(value)) : null,
    [dateFormatter]
  );
  const formatDateTime = React.useCallback(
    (value: string) => dateTimeFormatter.format(new Date(value)),
    [dateTimeFormatter]
  );

  React.useEffect(() => {
    (async () => {
      try {
        setLoading(true);
        setError(null);
        const r = await fetch('/api/billing/summary', { credentials: 'include' });
        const j = await r.json();
        if (!j.ok) throw new Error(j.error || 'Failed to load subscription');
        setSummary(j.summary as Summary);
        setInvoices((j.invoices ?? []) as Invoice[]);
        setDues((j.dues ?? []) as Due[]);
        setPortalAvailable(!j.needsStripeSetup);
      } catch (e) {
        setError((e as Error).message || 'Failed to load subscription');
      } finally {
        setLoading(false);
      }
    })();
  }, []);

  async function openPortal() {
    try {
      setPortalLoading(true);
      const r = await fetch('/api/billing/create-portal-session', {
        method: 'POST',
        credentials: 'include',
      });
      const j = await r.json();
      if (!r.ok || !j.url) throw new Error(j.error || 'Failed to open portal');
      window.location.href = j.url as string;
    } catch (e) {
      setError((e as Error).message);
      setPortalLoading(false);
    }
  }

  const renderPlanMeta = () => {
    const renews = formatDate(summary?.renewsAt);
    const trialEnds = formatDate(summary?.trialEndsAt);
    if (!renews && !trialEnds) return null;
    return (
      <p className="text-small text-muted-foreground">
        {renews && <span>Renews {renews}</span>}
        {renews && trialEnds && <span aria-hidden="true"> Â· </span>}
        {trialEnds && <span>Trial ends {trialEnds}</span>}
      </p>
    );
  };

  return (
    <>
      <Head>
        <title>Billing Â· GramorX</title>
        <meta
          name="description"
          content="Manage your subscription, invoices, and pending dues."
        />
      </Head>

      <Section
        className="bg-lightBg dark:bg-gradient-to-br dark:from-dark/80 dark:to-darker/90"
        Container
        containerClassName="max-w-5xl space-y-8"
      >
        <header className="space-y-2">
          <Heading as="h1" size="lg" className="text-foreground">
            Billing
          </Heading>
          <p className="text-small text-muted-foreground">
            Manage your plan, invoices, and local payment activity.
          </p>
        </header>

        {showSafepaySetup && (
          <Alert variant="warning" appearance="soft" title="Safepay requires configuration" role="alert">
            <p className="mt-2 text-small text-muted-foreground">
              Safepay is running in developer mode. Add your Safepay public and secret keys to enable the live checkout
              experience.
            </p>
            <p className="mt-2 text-caption text-muted-foreground">
              Update <code>SAFEPAY_PUBLIC_KEY</code> and <code>SAFEPAY_SECRET_KEY</code> in your environment, then restart
              the app.
            </p>
          </Alert>
        )}

        {showSafepayPending && (
          <Alert variant="info" appearance="soft" title="Safepay payment pending" role="status">
            <p className="mt-2 text-small text-muted-foreground">
              We have not received confirmation from Safepay yet. You will get an email once the payment completes.
            </p>
          </Alert>
        )}

        {showSafepayCancelled && (
          <Alert variant="warning" appearance="soft" title="Safepay checkout cancelled" role="alert">
            <p className="mt-2 text-small text-muted-foreground">
              Your Safepay session was cancelled before payment was completed. Start a new checkout to try again.
            </p>
          </Alert>
        )}

        {showSafepayFailed && (
          <Alert variant="error" appearance="soft" title="Safepay payment failed" role="alert">
            <p className="mt-2 text-small text-muted-foreground">
              {safepayReason
                ? safepayReason
                : 'Safepay reported that the payment could not be completed. Try again or choose another method.'}
            </p>
          </Alert>
        )}

        {showSafepayError && (
          <Alert variant="error" appearance="soft" title="Safepay verification error" role="alert">
            <p className="mt-2 text-small text-muted-foreground">
              We could not verify the Safepay callback. If you completed the payment, contact support with your receipt.
            </p>
          </Alert>
        )}

        {loading && (
          <Card padding="lg" insetBorder aria-busy="true">
            <div className="space-y-3">
              <Skeleton className="h-6 w-1/3 rounded-ds-xl" />
              <Skeleton className="h-10 w-full rounded-ds-xl" />
              <Skeleton className="h-10 w-5/6 rounded-ds-xl" />
            </div>
          </Card>
        )}

        {!loading && error && (
          <Alert variant="error" appearance="soft" title="Couldnâ€™t load billing" role="alert">
            <p className="mt-2 text-small text-muted-foreground">{error}</p>
            <div className="mt-3">
              <Button asChild variant="link" size="sm">
                <Link href="/pricing">Go to pricing</Link>
              </Button>
            </div>
          </Alert>
        )}

        {!loading && !error && summary && (
          <div className="space-y-6">
            <Card as="section" padding="none" insetBorder aria-labelledby="current-plan-heading">
              <CardHeader className="flex flex-col gap-4 sm:flex-row sm:items-start sm:justify-between">
                <div className="space-y-2">
                  <SectionLabel>Current plan</SectionLabel>
                  <div className="flex flex-wrap items-center gap-2">
                    <Heading as="h2" size="sm" id="current-plan-heading" className="capitalize text-foreground">
                      {toTitleCase(summary.plan)}
                    </Heading>
                    <Badge variant={getStatusVariant(summary.status)}>{toTitleCase(summary.status)}</Badge>
                  </div>
                  {renderPlanMeta()}
                </div>

                {portalAvailable ? (
                  <Button onClick={openPortal} loading={portalLoading} size="lg">
                    {portalLoading ? 'Openingâ€¦' : 'Manage billing'}
                  </Button>
                ) : (
                  <Button asChild variant="outline" size="lg">
                    <Link href="/pricing">Change plan</Link>
                  </Button>
                )}
              </CardHeader>

              {(justVaulted || !portalAvailable) && (
                <CardContent className="space-y-3 pt-0">
                  {!portalAvailable && (
                    <Alert variant="info" appearance="soft" title="Billing portal unavailable">
                      <p className="mt-1 text-small text-muted-foreground">
                        The hosted Stripe portal is temporarily offline. Email{' '}
                        <a className="underline" href="mailto:support@gramorx.com">
                          support@gramorx.com
                        </a>{' '}
                        to update or cancel your subscription.
                      </p>
                    </Alert>
                  )}

                  {justVaulted && (
                    <Alert variant="warning" appearance="soft" title="Card saved â€” payment due later">
                      <p className="mt-1 text-small text-muted-foreground">
                        Payments are temporarily unavailable. If you recently subscribed, your card was{' '}
                        <span className="font-medium">not charged</span> and the amount is marked as{' '}
                        <span className="font-medium">due</span>. Weâ€™ll notify you before retrying payment.
                      </p>
                    </Alert>
                  )}
                </CardContent>
              )}
            </Card>

            {dues.length > 0 && (
              <Card as="section" padding="none" insetBorder aria-labelledby="pending-dues">
                <CardHeader className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
                  <div>
                    <SectionLabel>Local payments</SectionLabel>
                    <Heading as="h2" size="xs" id="pending-dues" className="text-foreground">
                      Pending dues
                    </Heading>
                  </div>
                  <Button asChild size="sm">
                    <Link
                      href={{
                        pathname: '/checkout/save-card',
                        query: { plan: summary.plan, cycle: 'monthly', due: '1' },
                      }}
                    >
                      Pay with card
                    </Link>
                  </Button>
                </CardHeader>
                <CardContent>
                  <ul className="space-y-3">
                    {dues.map((d) => (
                      <li key={d.id} className="rounded-ds-xl border border-border/60 bg-surface p-4">
                        <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
                          <div className="space-y-2">
                            <Badge variant={getDueVariant(d.status)}>{toTitleCase(d.status)}</Badge>
                            <div className="text-small text-muted-foreground">
                              {toTitleCase(d.plan_key)} Â· {toTitleCase(d.cycle)}
                            </div>
                            <div className="text-caption text-muted-foreground">{formatDateTime(d.created_at)}</div>
                          </div>
                          <div className="text-right space-y-1">
                            <p className="text-h4 font-semibold text-foreground">
                              {currencyFormatter(d.amount_cents / 100, d.currency)}
                            </p>
                            <p className="text-caption text-muted-foreground">Not charged yet</p>
                          </div>
                        </div>
                      </li>
                    ))}
                  </ul>
                </CardContent>
              </Card>
            )}

            <Card as="section" padding="none" insetBorder aria-labelledby="invoices-heading">
              <CardHeader>
                <div>
                  <SectionLabel>History</SectionLabel>
                  <Heading as="h2" size="xs" id="invoices-heading" className="text-foreground">
                    Invoices
                  </Heading>
                </div>
              </CardHeader>
              <CardContent>
                {invoices.length === 0 ? (
                  <p className="text-small text-muted-foreground">No invoices yet.</p>
                ) : (
                  <ul className="space-y-3">
                    {invoices.map((inv) => (
                      <li key={inv.id} className="rounded-ds-xl border border-border/60 bg-surface p-4">
                        <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
                          <div className="space-y-2">
                            <Badge variant={getInvoiceVariant(inv.status)}>{toTitleCase(inv.status)}</Badge>
                            <p className="text-caption text-muted-foreground">{formatDateTime(inv.createdAt)}</p>
                          </div>
                          <div className="text-right space-y-2">
                            <p className="text-h4 font-semibold text-foreground">
                              {currencyFormatter(inv.amount / 100, inv.currency)}
                            </p>
                            {inv.hostedInvoiceUrl ? (
                              <Button asChild variant="link" size="sm">
                                <a href={inv.hostedInvoiceUrl} target="_blank" rel="noreferrer">
                                  View invoice
                                </a>
                              </Button>
                            ) : (
                              <span className="text-caption text-muted-foreground">No PDF</span>
                            )}
                          </div>
                        </div>
                      </li>
                    ))}
                  </ul>
                )}
              </CardContent>
            </Card>
          </div>
        )}

        {!loading && !error && !summary && (
          <Alert variant="info" appearance="soft" title="No subscription data">
            We couldnâ€™t find an active subscription yet. Start a plan from the pricing page when youâ€™re ready.
          </Alert>
        )}
      </Section>
    </>
  );
}





============================================================
FILE #39
PATH: pages/onboarding/index.tsx
============================================================
// pages/onboarding/index.tsx
import type { NextPage } from 'next';
import { useRouter } from 'next/router';
import React, { useMemo, useState } from 'react';

import { Container } from '@/components/design-system/Container';
import { Button } from '@/components/design-system/Button';
import { Icon } from '@/components/design-system/Icon';
import { cn } from '@/lib/utils';

type OnboardingStepId =
  | 'language'
  | 'target-band'
  | 'exam-date'
  | 'study-rhythm'
  | 'notifications';

const ONBOARDING_STEPS: { id: OnboardingStepId; label: string }[] = [
  { id: 'language', label: 'Language' },
  { id: 'target-band', label: 'Target band' },
  { id: 'exam-date', label: 'Exam date' },
  { id: 'study-rhythm', label: 'Study rhythm' },
  { id: 'notifications', label: 'Notifications' },
];

type LanguageCode = 'en' | 'ur';

const OnboardingLanguagePage: NextPage = () => {
  const router = useRouter();
  const [language, setLanguage] = useState<LanguageCode | null>('en');
  const [submitting, setSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const nextPath = useMemo(() => {
    const { next } = router.query;
    // we keep whatever you passed in ?next=, but fall back to dashboard after flow
    return typeof next === 'string' ? next : '/dashboard';
  }, [router.query]);

  const currentIndex = useMemo(
    () => ONBOARDING_STEPS.findIndex((s) => s.id === 'language'),
    []
  );

  async function handleContinue() {
    setError(null);

    if (!language) {
      setError('Please pick a language to continue.');
      return;
    }

    try {
      setSubmitting(true);

      // TODO: wire this up to your actual API / Supabase call.
      // Example (pseudo):
      // await fetch('/api/onboarding/language', {
      //   method: 'POST',
      //   headers: { 'Content-Type': 'application/json' },
      //   body: JSON.stringify({ language }),
      // });

      // For now, just move to the next onboarding step route.
      await router.push({
        pathname: '/onboarding/target-band',
        query: { next: nextPath },
      });
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error(e);
      setError('Something went wrong. Please try again.');
    } finally {
      setSubmitting(false);
    }
  }

  function handleBack() {
    // First step: go back to login/signup if someone hits Back
    router.back();
  }

  return (
    <main className="min-h-screen bg-background">
      <Container className="flex min-h-screen flex-col items-center justify-center py-10">
        {/* Progress rail */}
        <div className="mb-6 w-full max-w-3xl">
          <OnboardingProgress
            steps={ONBOARDING_STEPS}
            currentIndex={currentIndex}
          />
        </div>

        {/* Main card */}
        <section className="w-full max-w-3xl rounded-3xl border border-border bg-card/80 p-6 shadow-xl backdrop-blur-md sm:p-8">
          <header className="mb-6 flex items-start justify-between gap-4">
            <div>
              <p className="text-xs font-medium uppercase tracking-wide text-muted-foreground">
                Step {currentIndex + 1} of {ONBOARDING_STEPS.length}
              </p>
              <h1 className="mt-1 text-2xl font-semibold tracking-tight sm:text-3xl">
                Pick your learning language
              </h1>
              <p className="mt-2 text-sm text-muted-foreground sm:text-base">
                We&apos;ll translate nudges, reminders, and key instructions so
                the platform feels natural to you. You can change this later
                from <span className="font-medium">Settings â†’ Preferences</span>.
              </p>
            </div>

            <div className="hidden shrink-0 items-center gap-2 rounded-full bg-muted px-3 py-1 text-xs font-medium text-muted-foreground sm:flex">
              <Icon name="zap" className="h-3.5 w-3.5" />
              Smart setup Â· under 1 minute
            </div>
          </header>

          {/* Choices */}
          <div className="grid gap-4 sm:grid-cols-2">
            <LanguageChoice
              code="en"
              label="English"
              description="Interface, reminders, and lessons in English."
              selected={language === 'en'}
              onSelect={() => setLanguage('en')}
            />
            <LanguageChoice
              code="ur"
              label="Ø§Ø±Ø¯Ùˆ + English mix"
              description="Interface in Urdu with IELTS practice mostly kept bilingual."
              selected={language === 'ur'}
              onSelect={() => setLanguage('ur')}
            />
          </div>

          {error && (
            <p className="mt-3 text-sm font-medium text-destructive">{error}</p>
          )}

          {/* Keyboard hint */}
          <p className="mt-4 text-xs text-muted-foreground">
            Tip: Use <span className="rounded bg-muted px-1.5 py-0.5">â†</span>{' '}
            and <span className="rounded bg-muted px-1.5 py-0.5">â†’</span>{' '}
            arrow keys to move between options, then press{' '}
            <span className="rounded bg-muted px-1.5 py-0.5">Enter</span> to
            continue.
          </p>

          {/* Footer actions */}
          <footer className="mt-6 flex flex-col-reverse items-center justify-between gap-3 border-t border-border pt-4 sm:flex-row">
            <Button
              variant="ghost"
              size="sm"
              onClick={handleBack}
              className="text-muted-foreground"
            >
              <Icon name="arrow-left" className="mr-1.5 h-4 w-4" />
              Back
            </Button>

            <div className="flex items-center gap-3">
              <p className="hidden text-xs text-muted-foreground sm:inline">
                Next: <span className="font-medium">Set your target band</span>
              </p>
              <Button
                size="lg"
                onClick={handleContinue}
                disabled={submitting || !language}
              >
                {submitting ? 'Savingâ€¦' : 'Continue'}
                <Icon name="arrow-right" className="ml-2 h-4 w-4" />
              </Button>
            </div>
          </footer>
        </section>
      </Container>
    </main>
  );
};

interface OnboardingProgressProps {
  steps: { id: OnboardingStepId; label: string }[];
  currentIndex: number;
}

const OnboardingProgress: React.FC<OnboardingProgressProps> = ({
  steps,
  currentIndex,
}) => {
  return (
    <div className="flex flex-col gap-2">
      <div className="flex items-center justify-between">
        {steps.map((step, index) => {
          const active = index === currentIndex;
          const completed = index < currentIndex;

          return (
            <div
              key={step.id}
              className="flex flex-1 items-center last:flex-none"
            >
              <div
                className={cn(
                  'flex h-7 w-7 items-center justify-center rounded-full border text-xs font-semibold',
                  completed &&
                    'border-primary bg-primary text-primary-foreground',
                  active &&
                    !completed &&
                    'border-primary/80 bg-primary/10 text-primary',
                  !active && !completed && 'border-border bg-muted text-muted-foreground'
                )}
              >
                {completed ? (
                  <Icon name="check" className="h-3.5 w-3.5" />
                ) : (
                  index + 1
                )}
              </div>

              {index < steps.length - 1 && (
                <div
                  className={cn(
                    'mx-1 h-px flex-1 rounded-full bg-border',
                    completed && 'bg-primary/70',
                    active && 'bg-primary/50'
                  )}
                />
              )}
            </div>
          );
        })}
      </div>

      <div className="flex justify-between text-xs text-muted-foreground">
        {steps.map((step, index) => {
          const active = index === currentIndex;
          return (
            <span
              key={step.id}
              className={cn(
                'flex-1 truncate text-center',
                active && 'font-medium text-foreground'
              )}
            >
              {step.label}
            </span>
          );
        })}
      </div>
    </div>
  );
};

interface LanguageChoiceProps {
  code: LanguageCode;
  label: string;
  description: string;
  selected: boolean;
  onSelect: () => void;
}

const LanguageChoice: React.FC<LanguageChoiceProps> = ({
  label,
  description,
  selected,
  onSelect,
}) => {
  return (
    <button
      type="button"
      onClick={onSelect}
      className={cn(
        'group flex h-full flex-col rounded-2xl border p-4 text-left transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background sm:p-5',
        selected
          ? 'border-primary bg-primary/10 shadow-md'
          : 'border-border bg-muted/40 hover:border-primary/60 hover:bg-muted'
      )}
    >
      <div className="mb-2 flex items-center justify-between">
        <div className="flex items-center gap-2">
          <span className="inline-flex h-7 w-7 items-center justify-center rounded-full bg-primary/10 text-sm font-semibold text-primary">
            {label.charAt(0)}
          </span>
          <span className="text-base font-semibold sm:text-lg">{label}</span>
        </div>

        <div
          className={cn(
            'flex h-5 w-5 items-center justify-center rounded-full border text-[10px] font-semibold transition-colors',
            selected
              ? 'border-primary bg-primary text-primary-foreground'
              : 'border-border bg-background text-muted-foreground group-hover:border-primary/70'
          )}
        >
          {selected ? <Icon name="check" className="h-3 w-3" /> : ''}
        </div>
      </div>

      <p className="text-xs text-muted-foreground sm:text-sm">{description}</p>
    </button>
  );
};

export default OnboardingLanguagePage;





============================================================
FILE #40
PATH: pages/api/onboarding/notifications.ts
============================================================
import type { NextApiRequest, NextApiResponse } from 'next';
import { getServerClient } from '@/lib/supabaseServer';
import {
  NotificationsBody,
  NotificationChannelEnum,
} from '@/lib/onboarding/schema';
import { updateProfileForUser } from '@/lib/profile/update';

type Data =
  | { ok: true }
  | { ok: false; error: string; details?: unknown };

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ ok: false, error: 'Method not allowed' });
  }

  const parse = NotificationsBody.safeParse(req.body);
  if (!parse.success) {
    return res.status(400).json({
      ok: false,
      error: 'Invalid body',
      details: parse.error.flatten(),
    });
  }

  const { channels, preferredTime } = parse.data;

  const uniqueChannels = Array.from(new Set(channels)).map((c) =>
    NotificationChannelEnum.parse(c)
  );

  const supabase = getServerClient(req, res);
  const {
    data: { user },
    error: userError,
  } = await supabase.auth.getUser();

  if (userError) {
    return res
      .status(500)
      .json({ ok: false, error: `Auth error: ${userError.message}` });
  }
  if (!user) {
    return res.status(401).json({ ok: false, error: 'Unauthorized' });
  }

  const { error } = await updateProfileForUser(supabase, user.id, {
    notification_channels: uniqueChannels,
    notification_time: preferredTime ?? null,
    onboarding_completed_at: new Date().toISOString(),
  });

  if (error) {
    return res
      .status(500)
      .json({ ok: false, error: `DB error: ${error.message}` });
  }

  return res.status(200).json({ ok: true });
}





============================================================
FILE #41
PATH: pages/mock/reading/[id].tsx
============================================================
import React, { useCallback, useEffect, useId, useMemo, useRef, useState } from 'react';
import Link from 'next/link';
import { useRouter } from 'next/router';
import { Flag } from 'lucide-react';
import { readingPracticePapers } from '@/data/reading';
import {
  clearMockAttemptId,
  clearMockDraft,
  ensureMockAttemptId,
  fetchMockCheckpoint,
  loadMockDraft,
  saveMockCheckpoint,
  saveMockDraft,
} from '@/lib/mock/state';
import { useDebouncedCallback } from 'use-debounce';
import { ReadingPassage } from '@/components/exam/ReadingPassage';
import { QuestionNav, type QuestionNavFilter, type QuestionNavQuestion } from '@/components/exam/QuestionNav';
import { track } from '@/lib/analytics/track';
import { Checkbox } from '@/components/design-system/Checkbox';
import { Button } from '@/components/design-system/Button';
import { useToast } from '@/components/design-system/Toaster';
import { OfflineOnlyBanner } from '@/components/reading/OfflineOnlyBanner';
import { normalizeForPersist } from '@/lib/reading/normalize';
import { getAnswerText, isFlagged, type ReadingAnswer } from '@/lib/reading/answers';
import { mapServerNote as parseServerNote, type NoteRange } from '@/lib/reading/notes';
import { diffAnswers } from '@/lib/reading/diff';

type QType = 'tfng' | 'yynn' | 'heading' | 'match' | 'mcq' | 'gap';
type MatchOptionObject = {
  pairs?: Array<{ left: string; right: string | string[] }>;
  choices?: string[];
};
type Q = {
  id: string;
  type: QType;
  prompt?: string;
  options?: string[] | MatchOptionObject;
  answer: string;
};
type Passage = { id: string; title: string; text: string; questions: Q[] };
type ReadingPaper = { id: string; title: string; durationSec: number; passages: Passage[] };

type LayoutMode = 'split' | 'scroll';

type AnswerMap = Record<string, ReadingAnswer>;
type ReadingNote = {
  id: string;
  passageId: string;
  start: number;
  end: number;
  ranges: NoteRange[];
  color: string;
  noteText?: string | null;
};
type SelectionInput = { start: number; end: number; text: string; noteText?: string };
type DraftState = {
  answers: AnswerMap;
  passageIdx: number;
  timeLeft?: number;
  notes?: ReadingNote[];
  questionFilter?: QuestionNavFilter;
  layoutMode?: LayoutMode;
  started?: boolean;
  focusMode?: boolean;
};

const LAYOUT_PREF_KEY = 'mock:reading:layout-mode';
const FOCUS_MODE_PREF_KEY = 'mock:reading:focus-mode';
const LAYOUT_OPTIONS: Array<{
  id: LayoutMode;
  label: string;
  description: string;
  shortLabel: string;
}> = [
  {
    id: 'split',
    label: 'Split view',
    description: 'Desktop: passage left, questions right. Mobile stays single column.',
    shortLabel: 'Split',
  },
  {
    id: 'scroll',
    label: 'Scroll view',
    description: 'Single column with passage above questions on all devices.',
    shortLabel: 'Scroll',
  },
];

const ACTIVE_CHECKPOINT_INTERVAL = 10_000;
const IDLE_CHECKPOINT_INTERVAL = 60_000;
const IDLE_THRESHOLD_MS = 30_000;
const READING_SECTION_INDEX = 1;

const sampleReading: ReadingPaper = {
  id: 'sample-001',
  title: 'Reading Sample 001',
  durationSec: 3600,
  passages: [
    { id: 'P1', title: 'The Honeybee', text: 'Bees are fascinatingâ€¦', questions: [
      { id: 'q1', type: 'tfng', prompt: 'Bees can see UV light.', answer: 'True' },
      { id: 'q2', type: 'yynn', prompt: 'Honey is spicy.', answer: 'No' },
      { id: 'q3', type: 'heading', prompt: 'Choose paragraph heading', options: ['Origins','Vision','Diet'], answer: 'Vision' },
    ]},
    { id: 'P2', title: 'Ancient Roads', text: 'Roads enabled tradeâ€¦', questions: [
      { id: 'q4', type: 'match', prompt: 'Match A with B', options: ['Roman','Silk','Inca'], answer: 'Roman' },
      { id: 'q5', type: 'mcq', prompt: 'Pick one', options: ['A','B','C'], answer: 'C' },
    ]},
  ],
};

const readingPaperLookup = new Map<string, ReadingPaper>(
  readingPracticePapers.map((paper) => [paper.id, JSON.parse(JSON.stringify(paper)) as ReadingPaper]),
);

const loadPaper = async (id: string): Promise<ReadingPaper> => {
  const staticPaper = readingPaperLookup.get(id);
  if (staticPaper) {
    return JSON.parse(JSON.stringify(staticPaper)) as ReadingPaper;
  }

  try {
    const mod = await import(`@/data/reading/${id}.json`);
    return mod.default as ReadingPaper;
  } catch {
    return sampleReading;
  }
};

const Shell: React.FC<{ title: string; right?: React.ReactNode; children: React.ReactNode }> = ({ title, right, children }) => (
  <div className="min-h-[100dvh] bg-background text-foreground pb-safe">
    <div className="mx-auto w-full max-w-screen-2xl px-3 pb-12 pt-safe sm:px-6 lg:px-8 xl:px-10">
      <header className="mb-8 rounded-3xl border border-border/80 bg-background/70 px-5 py-5 shadow-lg shadow-black/5 backdrop-blur supports-[backdrop-filter]:backdrop-blur">
        <div className="flex flex-col gap-4 md:flex-row md:items-center md:justify-between">
          <h1 className="text-h3 font-semibold tracking-tight">{title}</h1>
          <div className="flex flex-wrap items-center gap-3">{right}</div>
        </div>
      </header>
      <div className="grid gap-8 md:grid-cols-[minmax(0,1.55fr)_minmax(0,0.85fr)] xl:grid-cols-[minmax(0,1.75fr)_minmax(0,0.9fr)]">
        {children}
      </div>
    </div>
  </div>
);

export default function ReadingMockPage() {
  const router = useRouter();
  const toast = useToast();
  const { id } = router.query as { id?: string };
  const [paper, setPaper] = useState<ReadingPaper | null>(null);
  const [answers, setAnswers] = useState<AnswerMap>({});
  const [passageIdx, setPassageIdx] = useState(0);
  const [timeLeft, setTimeLeft] = useState(3600);
  const [notes, setNotes] = useState<ReadingNote[]>([]);
  const [questionFilter, setQuestionFilter] = useState<QuestionNavFilter>('all');
  const [layoutMode, setLayoutMode] = useState<LayoutMode>('split');
  const [isStarted, setIsStarted] = useState(false);
  const [focusMode, setFocusMode] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [layoutHydrated, setLayoutHydrated] = useState(false);
  const [activeQuestionId, setActiveQuestionId] = useState<string | null>(null);
  const attemptRef = useRef<string>('');
  const [attemptReady, setAttemptReady] = useState(false);
  const [checkpointHydrated, setCheckpointHydrated] = useState(false);
  const [localOnly, setLocalOnly] = useState(false);
  const latestRef = useRef<{
    answers: AnswerMap;
    passageIdx: number;
    timeLeft: number;
    notes: ReadingNote[];
    questionFilter: QuestionNavFilter;
    layoutMode: LayoutMode;
    started: boolean;
    focusMode: boolean;
  }>({
    answers: {},
    passageIdx: 0,
    timeLeft: 0,
    notes: [],
    questionFilter: 'all',
    layoutMode: 'split',
    started: false,
    focusMode: false,
  });
  const currentAnswersRef = useRef<AnswerMap>({});
  const serverSyncedAnswersRef = useRef<Record<string, unknown>>({});
  const lastCheckpointMetaRef = useRef<string>('');
  const checkpointTimeoutRef = useRef<number | null>(null);
  const lastActivityRef = useRef<number>(Date.now());
  const [editingNoteId, setEditingNoteId] = useState<string | null>(null);
  const [noteEditorValue, setNoteEditorValue] = useState('');
  const noteRefs = useRef<Record<string, HTMLDivElement | null>>({});
  const questionRefs = useRef<Record<string, HTMLDivElement | null>>({});
  const [notesLoaded, setNotesLoaded] = useState(true);
  const DEFAULT_NOTE_COLOR = 'warning';

  const questionLookup = useMemo(() => {
    if (!paper) return new Map<string, { passage: Passage; passageIndex: number }>();
    const map = new Map<string, { passage: Passage; passageIndex: number }>();
    paper.passages.forEach((passage, idx) => {
      passage.questions.forEach((question) => {
        map.set(question.id, { passage, passageIndex: idx });
      });
    });
    return map;
  }, [paper]);

  useEffect(() => {
    if (!id) return;
    const attempt = ensureMockAttemptId('reading', id);
    attemptRef.current = attempt;
    setAttemptReady(true);
  }, [id]);

  useEffect(() => {
    void router.prefetch('/review/reading/demo-attempt');
  }, [router]);

  useEffect(() => {
    if (!id) return;
    (async () => {
      const p = await loadPaper(id);
      setPaper(p);
      const draft = loadMockDraft<DraftState>('reading', id);
      const storedLayout = getStoredLayoutMode();
      const storedFocus = getStoredFocusMode();
      if (draft?.data) {
        const normalizedAnswers = draft.data.answers ? normalizeAnswerMap(draft.data.answers) : undefined;
        if (normalizedAnswers) setAnswers(normalizedAnswers);
        if (typeof draft.data.passageIdx === 'number') setPassageIdx(draft.data.passageIdx);
        if (typeof draft.data.timeLeft === 'number') {
          setTimeLeft(Math.max(0, Math.min(p.durationSec, Math.round(draft.data.timeLeft))));
        } else {
          setTimeLeft(p.durationSec);
        }
        const noteList = Array.isArray(draft.data.notes)
          ? draft.data.notes
              .map((note) => mapReadingNote(note))
              .filter((note): note is ReadingNote => Boolean(note))
          : undefined;
        if (noteList && noteList.length > 0) setNotes(noteList);
        if (draft.data.questionFilter) {
          setQuestionFilter(normalizeQuestionFilter(draft.data.questionFilter));
        }
        setLayoutMode(normalizeLayoutMode(draft.data.layoutMode ?? storedLayout));
        if (typeof draft.data.focusMode === 'boolean') {
          setFocusMode(draft.data.focusMode);
        } else {
          setFocusMode(storedFocus);
        }
        const hasAnsweredFromDraft = normalizedAnswers ? hasAnyAnswered(normalizedAnswers) : false;
        const hasNotes = Boolean(noteList && noteList.length > 0);
        const startedFromDraft =
          draft.data.started === true ||
          (typeof draft.data.timeLeft === 'number' && draft.data.timeLeft < p.durationSec) ||
          hasAnsweredFromDraft ||
          hasNotes;
        setIsStarted(startedFromDraft);
      } else {
        setTimeLeft(p.durationSec);
        saveMockDraft('reading', id, {
          answers: normalizeForPersist({}),
          passageIdx: 0,
          timeLeft: p.durationSec,
          notes: [],
          questionFilter: 'all',
          layoutMode: storedLayout,
          started: false,
          focusMode: storedFocus,
        });
        setLayoutMode(storedLayout);
        setFocusMode(storedFocus);
        setIsStarted(false);
      }
      setLayoutHydrated(true);
    })();
  }, [id]);

  useEffect(() => {
    if (!paper || !attemptReady) return;
    let cancelled = false;

    (async () => {
      const checkpoint = await fetchMockCheckpoint({ attemptId: attemptRef.current, section: 'reading' });
      if (cancelled) return;
      if (checkpoint && checkpoint.mockId === paper.id) {
        const payload = (checkpoint.payload || {}) as {
          answers?: Record<string, unknown>;
          passageIdx?: number;
          timeLeft?: number;
          notes?: Array<Record<string, unknown>>;
          questionFilter?: unknown;
          layoutMode?: unknown;
          started?: unknown;
          focusMode?: unknown;
        };
        const normalizedAnswers = payload.answers ? normalizeAnswerMap(payload.answers) : undefined;
        if (normalizedAnswers) {
          setAnswers(normalizedAnswers);
          serverSyncedAnswersRef.current = normalizeForPersist(normalizedAnswers);
        }
        const nextPassageIdx =
          typeof payload.passageIdx === 'number' ? payload.passageIdx : latestRef.current.passageIdx;
        if (typeof payload.passageIdx === 'number') setPassageIdx(payload.passageIdx);
        const nextTimeLeft = (() => {
          if (typeof payload.timeLeft === 'number') {
            return Math.max(0, Math.min(paper.durationSec, Math.round(payload.timeLeft)));
          }
          const duration = typeof checkpoint.duration === 'number' ? checkpoint.duration : paper.durationSec;
          const remaining = Math.max(0, duration - checkpoint.elapsed);
          return Math.max(0, Math.min(paper.durationSec, remaining));
        })();
        setTimeLeft(nextTimeLeft);
        const normalizedNotes = Array.isArray(payload.notes)
          ? payload.notes
              .map((note) => mapReadingNote(note))
              .filter((note): note is ReadingNote => Boolean(note))
          : undefined;
        if (normalizedNotes && normalizedNotes.length > 0) setNotes(normalizedNotes);
        const nextNotes = normalizedNotes && normalizedNotes.length > 0 ? normalizedNotes : latestRef.current.notes;
        const nextQuestionFilter = payload.questionFilter
          ? normalizeQuestionFilter(payload.questionFilter)
          : latestRef.current.questionFilter;
        if (payload.questionFilter) {
          setQuestionFilter(nextQuestionFilter);
        }
        const nextLayoutMode = payload.layoutMode
          ? normalizeLayoutMode(payload.layoutMode)
          : latestRef.current.layoutMode;
        if (payload.layoutMode) {
          setLayoutMode(nextLayoutMode);
        }
        const nextFocusMode =
          typeof payload.focusMode === 'boolean' ? payload.focusMode : latestRef.current.focusMode;
        if (typeof payload.focusMode === 'boolean') {
          setFocusMode(payload.focusMode);
        }
        const hasAnswered = normalizedAnswers ? hasAnyAnswered(normalizedAnswers) : false;
        const hasNotes = Boolean(normalizedNotes && normalizedNotes.length > 0);
        const startedFromPayload =
          payload.started === true ||
          (typeof payload.timeLeft === 'number' && payload.timeLeft < paper.durationSec) ||
          hasAnswered ||
          hasNotes;
        if (startedFromPayload) {
          setIsStarted(true);
        }
        const nextStarted = startedFromPayload ? true : latestRef.current.started;
        lastCheckpointMetaRef.current = JSON.stringify({
          passageIdx: nextPassageIdx,
          timeLeft: nextTimeLeft,
          notes: nextNotes,
          questionFilter: nextQuestionFilter,
          layoutMode: nextLayoutMode,
          started: nextStarted,
          focusMode: nextFocusMode,
        });
      }
      setCheckpointHydrated(true);
    })();

    return () => {
      cancelled = true;
    };
  }, [paper, attemptReady]);

  useEffect(() => {
    if (!paper || !isStarted) return;
    const t = setInterval(() => setTimeLeft((x) => (x > 0 ? x - 1 : 0)), 1000);
    return () => clearInterval(t);
  }, [paper, isStarted]);

  const debouncedLocalDraft = useDebouncedCallback(
    (payload: DraftState) => {
      if (!id) return;
      const { answers: payloadAnswers, ...rest } = payload;
      const normalized = normalizeForPersist(payloadAnswers);
      saveMockDraft('reading', id, { ...rest, answers: normalized });
    },
    1000,
    { maxWait: 3000 }
  );

  useEffect(() => {
    latestRef.current = {
      answers,
      passageIdx,
      timeLeft,
      notes,
      questionFilter,
      layoutMode,
      started: isStarted,
      focusMode,
    };
  }, [answers, passageIdx, timeLeft, notes, questionFilter, layoutMode, isStarted, focusMode]);

  useEffect(() => {
    currentAnswersRef.current = answers;
  }, [answers]);

  useEffect(() => {
    if (!layoutHydrated) return;
    setStoredLayoutMode(layoutMode);
  }, [layoutHydrated, layoutMode]);

  useEffect(() => {
    if (!layoutHydrated) return;
    setStoredFocusMode(focusMode);
  }, [focusMode, layoutHydrated]);

  useEffect(() => {
    if (typeof document === 'undefined') return;
    const root = document.documentElement;
    const body = document.body;
    const previousRoot = root.dataset.focusMode;
    const previousBody = body?.dataset.focusMode;

    const apply = (value: boolean) => {
      const next = value ? 'true' : 'false';
      root.dataset.focusMode = next;
      if (body) {
        body.dataset.focusMode = next;
      }
    };

    apply(focusMode);

    return () => {
      if (previousRoot === undefined) {
        delete root.dataset.focusMode;
      } else {
        root.dataset.focusMode = previousRoot;
      }
      if (body) {
        if (previousBody === undefined) {
          delete body.dataset.focusMode;
        } else {
          body.dataset.focusMode = previousBody;
        }
      }
    };
  }, [focusMode]);

  useEffect(() => {
    if (!id) return;
    debouncedLocalDraft({
      answers,
      passageIdx,
      timeLeft,
      notes,
      questionFilter,
      layoutMode,
      started: isStarted,
      focusMode,
    });
    return () => {
      debouncedLocalDraft.flush();
    };
  }, [id, answers, passageIdx, timeLeft, notes, questionFilter, layoutMode, isStarted, debouncedLocalDraft]);

  const persistCheckpoint = useCallback(
    async (opts?: { completed?: boolean; force?: boolean }) => {
      if (!paper || !attemptReady || !checkpointHydrated || !attemptRef.current) return false;
      const state = latestRef.current;
      const normalizedAnswers = normalizeForPersist(state.answers);
      const previousAnswers = serverSyncedAnswersRef.current ?? {};
      const shouldForce = Boolean(opts?.force || opts?.completed);
      const answersDelta = shouldForce ? undefined : diffAnswers(previousAnswers, normalizedAnswers);
      const deltaKeys = answersDelta ? Object.keys(answersDelta) : [];
      const hasAnswerChanges = shouldForce || deltaKeys.length > 0;
      const metaPayload = JSON.stringify({
        passageIdx: state.passageIdx,
        timeLeft: state.timeLeft,
        notes: state.notes,
        questionFilter: state.questionFilter,
        layoutMode: state.layoutMode,
        started: state.started,
        focusMode: state.focusMode,
      });
      const metaChanged = shouldForce || metaPayload !== lastCheckpointMetaRef.current;
      if (!shouldForce && !hasAnswerChanges && !metaChanged) {
        return true;
      }
      const elapsed = Math.max(0, Math.min(paper.durationSec, paper.durationSec - state.timeLeft));
      const answersPayload: Record<string, unknown> =
        shouldForce || deltaKeys.length === 0 || !answersDelta ? normalizedAnswers : answersDelta;

      const ok = await saveMockCheckpoint({
        attemptId: attemptRef.current,
        section: 'reading',
        mockId: paper.id,
        payload: {
          paperId: paper.id,
          answers: answersPayload,
          passageIdx: state.passageIdx,
          timeLeft: state.timeLeft,
          notes: state.notes,
          questionFilter: state.questionFilter,
          layoutMode: state.layoutMode,
          started: state.started,
          focusMode: state.focusMode,
        },
        elapsed,
        duration: paper.durationSec,
        completed: opts?.completed,
        answersDelta: !shouldForce && deltaKeys.length > 0 ? answersDelta : undefined,
      });
      if (ok) {
        serverSyncedAnswersRef.current = normalizedAnswers;
        lastCheckpointMetaRef.current = metaPayload;
      }
      return ok;
    },
    [paper, attemptReady, checkpointHydrated]
  );

  const scheduleCheckpoint = useCallback(
    (opts?: { force?: boolean }) => {
      if (!paper || !attemptReady || !checkpointHydrated) {
        if (checkpointTimeoutRef.current) {
          window.clearTimeout(checkpointTimeoutRef.current);
          checkpointTimeoutRef.current = null;
        }
        return;
      }
      if (checkpointTimeoutRef.current) {
        window.clearTimeout(checkpointTimeoutRef.current);
      }
      const now = Date.now();
      const idle = now - lastActivityRef.current >= IDLE_THRESHOLD_MS;
      const delay = opts?.force ? 0 : idle ? IDLE_CHECKPOINT_INTERVAL : ACTIVE_CHECKPOINT_INTERVAL;
      checkpointTimeoutRef.current = window.setTimeout(async () => {
        checkpointTimeoutRef.current = null;
        await persistCheckpoint({ force: opts?.force });
        if (!opts?.force) {
          scheduleCheckpoint();
        }
      }, delay);
    },
    [paper, attemptReady, checkpointHydrated, persistCheckpoint]
  );

  useEffect(() => {
    if (!paper || !attemptReady || !checkpointHydrated) return;
    const handler = () => {
      debouncedLocalDraft.flush();
      void persistCheckpoint({ force: true });
    };
    window.addEventListener('beforeunload', handler);
    return () => window.removeEventListener('beforeunload', handler);
  }, [paper, attemptReady, checkpointHydrated, persistCheckpoint, debouncedLocalDraft]);

  useEffect(() => {
    if (!paper || !attemptReady || !checkpointHydrated) return;
    lastActivityRef.current = Date.now();
    scheduleCheckpoint();
    return () => {
      if (checkpointTimeoutRef.current) {
        window.clearTimeout(checkpointTimeoutRef.current);
        checkpointTimeoutRef.current = null;
      }
    };
  }, [paper, attemptReady, checkpointHydrated, scheduleCheckpoint]);

  useEffect(() => {
    if (!attemptReady || !checkpointHydrated) return;
    lastActivityRef.current = Date.now();
    scheduleCheckpoint();
  }, [
    answers,
    notes,
    questionFilter,
    layoutMode,
    focusMode,
    passageIdx,
    isStarted,
    attemptReady,
    checkpointHydrated,
    scheduleCheckpoint,
  ]);

  useEffect(() => {
    if (!attemptReady || !checkpointHydrated) return;
    const attemptId = attemptRef.current;
    if (!attemptId) {
      setNotesLoaded(true);
      return;
    }

    setNotesLoaded(false);

    let cancelled = false;
    const controller = new AbortController();

    const loadNotes = async () => {
      try {
        const params = new URLSearchParams({ attemptId });
        const res = await fetch(`/api/mock/reading/notes?${params.toString()}`, {
          signal: controller.signal,
        });
        if (!res.ok) {
          return;
        }
        const data = (await res.json()) as {
          ok: boolean;
          notes?: Array<{ id: string; passageId: string; ranges: Array<{ start: number; end: number; color?: string }>; noteText?: string | null }>;
        };
        if (!cancelled && data?.ok && Array.isArray(data.notes)) {
          const mapped = data.notes
            .map((item) => mapReadingNote(item))
            .filter((item): item is ReadingNote => Boolean(item));
          setNotes((prev) => mergeNotes(prev, mapped));
        }
      } catch (error) {
        if ((error as Error)?.name === 'AbortError') return;
      } finally {
        if (!cancelled) setNotesLoaded(true);
      }
    };

    void loadNotes();

    return () => {
      cancelled = true;
      controller.abort();
    };
  }, [attemptReady, checkpointHydrated]);

  useEffect(() => {
    if (typeof window === 'undefined') return;
    if (!paper) return;
    const onHide = () => {
      if (!paper || !checkpointHydrated || !attemptRef.current) return;
      if (typeof navigator === 'undefined' || typeof navigator.sendBeacon !== 'function') return;
      if (typeof document !== 'undefined' && document.visibilityState !== 'hidden') return;
      try {
        const state = latestRef.current;
        const normalized = normalizeForPersist(currentAnswersRef.current);
        const payload = {
          attemptId: attemptRef.current,
          sectionIndex: READING_SECTION_INDEX,
          snapshot: {
            paperId: paper.id,
            answers: normalized,
            passageIdx: state.passageIdx,
            timeLeft: state.timeLeft,
            notes: state.notes,
            questionFilter: state.questionFilter,
            layoutMode: state.layoutMode,
            started: state.started,
            focusMode: state.focusMode,
          },
          mockId: paper.id,
          elapsedSeconds: Math.max(0, Math.min(paper.durationSec, paper.durationSec - state.timeLeft)),
          durationSeconds: paper.durationSec,
          completed: Boolean(state.started && state.timeLeft === 0),
          answers: normalized,
        };
        const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
        navigator.sendBeacon('/api/mock/checkpoints', blob);
      } catch {
        // ignore beacon failures
      }
    };
    window.addEventListener('visibilitychange', onHide);
    window.addEventListener('pagehide', onHide);
    return () => {
      window.removeEventListener('visibilitychange', onHide);
      window.removeEventListener('pagehide', onHide);
    };
  }, [paper, checkpointHydrated]);
  const current = useMemo(() => (paper ? paper.passages[passageIdx] : undefined), [paper, passageIdx]);
  const currentPassageId = current?.id;
  const passageNotes = useMemo(() => {
    if (!currentPassageId) return [] as ReadingNote[];
    return notes.filter((note) => note.passageId === currentPassageId).sort((a, b) => a.start - b.start);
  }, [notes, currentPassageId]);

  const passageHighlights = useMemo(
    () =>
      passageNotes
        .flatMap((note) =>
          note.ranges.map((range, index) => ({
            id: index === 0 ? note.id : `${note.id}:${index}`,
            start: range.start,
            end: range.end,
            color: note.color,
            noteText: note.noteText,
          }))
        )
        .filter((item) => item.end > item.start)
        .sort((a, b) => a.start - b.start),
    [passageNotes]
  );

  useEffect(() => {
    setEditingNoteId(null);
    setNoteEditorValue('');
  }, [current?.id]);

  useEffect(() => {
    if (!current || !current.questions || current.questions.length === 0) {
      setActiveQuestionId(null);
      return;
    }
    setActiveQuestionId((prev) => {
      if (prev && current.questions.some((q) => q.id === prev)) {
        return prev;
      }
      return current.questions[0]?.id ?? null;
    });
  }, [current]);

  const questionItems = useMemo<QuestionNavQuestion[]>(() => {
    if (!paper) return [];
    const items: QuestionNavQuestion[] = [];
    paper.passages.forEach((passage, passageIndex) => {
      passage.questions.forEach((question) => {
        items.push({ id: question.id, index: items.length + 1, label: `P${passageIndex + 1}` });
      });
    });
    return items;
  }, [paper]);

  const questionIndexMap = useMemo(() => {
    const map = new Map<string, number>();
    questionItems.forEach((item) => {
      map.set(item.id, item.index);
    });
    return map;
  }, [questionItems]);

  const questionStats = useMemo(() => {
    let answeredTotal = 0;
    let flaggedTotal = 0;
    questionItems.forEach((item) => {
      const entry = answers[item.id];
      if (isAnsweredEntry(entry)) answeredTotal++;
      if (isFlaggedEntry(entry)) flaggedTotal++;
    });
    return {
      total: questionItems.length,
      answered: answeredTotal,
      flagged: flaggedTotal,
      unanswered: questionItems.length - answeredTotal,
    };
  }, [questionItems, answers]);

  const nextUnanswered = useMemo(
    () => questionItems.find((item) => !isAnsweredEntry(answers[item.id])),
    [questionItems, answers]
  );

  const nextFlagged = useMemo(
    () => questionItems.find((item) => isFlaggedEntry(answers[item.id])),
    [questionItems, answers]
  );

  const currentQuestionId = activeQuestionId ?? current?.questions?.[0]?.id ?? null;

  const resumeAvailable = useMemo(() => {
    if (!paper) return false;
    if (isStarted) return true;
    if (timeLeft < paper.durationSec) return true;
    const answered = questionItems.some((item) => isAnsweredEntry(answers[item.id]));
    return answered || notes.length > 0;
  }, [paper, isStarted, timeLeft, questionItems, answers, notes]);

  const createAnnotation = useCallback(
    async (payload: SelectionInput) => {
      if (!current) return;
      const textLength = current.text.length;
      const start = Math.max(0, Math.min(payload.start, textLength));
      const end = Math.max(start, Math.min(payload.end, textLength));
      if (end <= start) return;

      const existing = latestRef.current.notes.filter((note) => note.passageId === current.id);
      const overlaps = existing.some((note) =>
        note.ranges.some((range) => rangesOverlap(range.start, range.end, start, end))
      );
      if (overlaps) {
        if (typeof window !== 'undefined') {
          window.alert('Selection overlaps an existing highlight. Remove it first to re-highlight.');
        }
        return;
      }

      const localId = `local-${Date.now()}-${Math.random().toString(16).slice(2, 8)}`;
      const provisional: ReadingNote = {
        id: localId,
        passageId: current.id,
        start,
        end,
        ranges: [{ start, end }],
        color: DEFAULT_NOTE_COLOR,
        noteText: payload.noteText ?? null,
      };

      setNotes((prev) => mergeNotes(prev, [provisional]));

      if (payload.noteText && payload.noteText.trim().length > 0) {
        track('reading.note.add', {
          passageId: current.id,
          length: Math.min(1000, payload.noteText.length),
        });
        setEditingNoteId(localId);
        setNoteEditorValue(payload.noteText);
      } else {
        setEditingNoteId(null);
        setNoteEditorValue('');
      }

      track('reading.highlight.add', {
        passageId: current.id,
        withNote: Boolean(payload.noteText && payload.noteText.trim().length > 0),
      });

      const attemptId = attemptRef.current;
      if (!attemptId) return;

      try {
        const response = await fetch('/api/mock/reading/notes', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            attemptId,
            passageId: current.id,
            ranges: [{ start, end, color: DEFAULT_NOTE_COLOR }],
            noteText: payload.noteText ?? null,
          }),
        });

        if (!response.ok) throw new Error(`Failed with status ${response.status}`);

        const result = (await response.json()) as {
          ok: boolean;
          note?: { id?: string; passageId?: string; ranges?: Array<{ start?: number; end?: number; color?: string }>; noteText?: string | null };
        };

        if (result.ok && result.note) {
          const mapped = mapReadingNote(result.note);
          if (mapped) {
            setNotes((prev) => {
              const withoutTemp = prev.filter((note) => note.id !== localId);
              return mergeNotes(withoutTemp, [mapped]);
            });
            if (payload.noteText && payload.noteText.trim().length > 0) {
              setEditingNoteId(mapped.id);
              setNoteEditorValue(mapped.noteText ?? payload.noteText);
            }
          }
        }
      } catch (error) {
        // eslint-disable-next-line no-console -- surfaced in development for debugging persistence issues
        console.error('Failed to persist reading note', error);
      }
    },
    [current, DEFAULT_NOTE_COLOR]
  );

  const handleSelectionHighlight = useCallback(
    (payload: SelectionInput) => {
      void createAnnotation({ ...payload, noteText: undefined });
    },
    [createAnnotation]
  );

  const handleSelectionNote = useCallback(
    (payload: SelectionInput) => {
      void createAnnotation(payload);
    },
    [createAnnotation]
  );

  const handleHighlightFocus = useCallback(
    (noteId: string) => {
      const baseId = noteId.split(':')[0] ?? noteId;
      setEditingNoteId(baseId);
      const target = notes.find((note) => note.id === baseId);
      setNoteEditorValue(target?.noteText ?? '');
      const node = noteRefs.current[baseId];
      if (node) {
        node.scrollIntoView({ behavior: 'smooth', block: 'center' });
        if (typeof window !== 'undefined') {
          window.setTimeout(() => {
            node.focus({ preventScroll: true });
          }, 180);
        }
      }
    },
    [notes]
  );

  const handleNoteSave = useCallback(
    async (noteId: string) => {
      const trimmed = noteEditorValue.trim();
      const target = notes.find((note) => note.id === noteId);
      const previous = target?.noteText ?? null;
      const previousTrimmed = (previous ?? '').trim();
      const payloadNote = trimmed.length > 0 ? trimmed : null;

      setNotes((prev) =>
        prev.map((note) => (note.id === noteId ? { ...note, noteText: payloadNote } : note))
      );

      setEditingNoteId(null);
      setNoteEditorValue('');

      if (target && trimmed.length > 0 && previousTrimmed.length === 0) {
        track('reading.note.add', {
          passageId: target.passageId,
          length: Math.min(1000, trimmed.length),
        });
      }

      if ((previous ?? null) === payloadNote) {
        return;
      }

      const attemptId = attemptRef.current;
      if (!attemptId) return;

      try {
        const response = await fetch('/api/mock/reading/notes', {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id: noteId, noteText: payloadNote }),
        });
        if (!response.ok) throw new Error(`Failed with status ${response.status}`);
      } catch (error) {
        setNotes((prev) =>
          prev.map((note) => (note.id === noteId ? { ...note, noteText: previous } : note))
        );
        // eslint-disable-next-line no-console -- assists debugging when persistence fails locally
        console.error('Failed to update reading note', error);
      }
    },
    [noteEditorValue, notes]
  );

  const handleRemoveHighlight = useCallback(
    async (noteId: string) => {
      const previousNotes = notes;
      setNotes((prev) => prev.filter((note) => note.id !== noteId));
      if (editingNoteId === noteId) {
        setEditingNoteId(null);
        setNoteEditorValue('');
      }

      const attemptId = attemptRef.current;
      if (!attemptId) return;

      try {
        const response = await fetch('/api/mock/reading/notes', {
          method: 'DELETE',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id: noteId }),
        });
        if (!response.ok) throw new Error(`Failed with status ${response.status}`);
      } catch (error) {
        setNotes(previousNotes);
        // eslint-disable-next-line no-console -- assists debugging when persistence fails locally
        console.error('Failed to delete reading note', error);
      }
    },
    [notes, editingNoteId]
  );

  const cancelNoteEditing = useCallback(() => {
    setEditingNoteId(null);
    setNoteEditorValue('');
  }, []);

  const updateAnswerValue = useCallback((questionId: string, value: string) => {
    setAnswers((prev) => {
      const current = prev[questionId];
      const currentValue = getAnswerText(current);
      const currentFlagged = isFlagged(current);
      if (currentValue === value) return prev;
      return { ...prev, [questionId]: { value, flagged: currentFlagged } };
    });
    setActiveQuestionId(questionId);
  }, []);

  const toggleFlag = useCallback((questionId: string) => {
    let nextFlag = false;
    setAnswers((prev) => {
      const current = prev[questionId];
      const currentValue = getAnswerText(current);
      const currentFlagged = isFlagged(current);
      nextFlag = !currentFlagged;
      return { ...prev, [questionId]: { value: currentValue, flagged: nextFlag } };
    });
    setActiveQuestionId(questionId);
    track('reading.flag.toggle', { questionId, flagged: nextFlag });
  }, []);

  const applyQuestionFilter = useCallback(
    (next: QuestionNavFilter, source: 'nav' | 'toolbar') => {
      setQuestionFilter((prev) => {
        if (prev === next) return prev;
        track('reading.nav.filter', { filter: next, source });
        return next;
      });
    },
    []
  );

  const handleLayoutModeChange = useCallback((mode: LayoutMode) => {
    setLayoutMode((prev) => (prev === mode ? prev : mode));
  }, []);

  const handleFocusModeToggle = useCallback((next: boolean) => {
    setFocusMode(next);
  }, []);

  const exitFocusMode = useCallback(() => {
    setFocusMode(false);
  }, []);

  const scrollToQuestion = useCallback((questionId: string) => {
    const node = questionRefs.current[questionId];
    setActiveQuestionId(questionId);
    if (!node) return;
    node.scrollIntoView({ behavior: 'smooth', block: 'center' });
    if (typeof window !== 'undefined') {
      window.setTimeout(() => {
        const interactive = node.querySelector<HTMLElement>(
          'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
        );
        interactive?.focus({ preventScroll: true });
      }, 160);
    }
  }, []);

  const startExam = useCallback(() => {
    setIsStarted(true);
  }, []);

  const makeAttemptId = () => {
    if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
      return crypto.randomUUID();
    }
    const random = Math.random().toString(16).slice(2, 10);
    return `attempt-${Date.now()}-${random}`;
  };

  const submit = async () => {
    if (!paper || !id || isSubmitting) return;
    setIsSubmitting(true);

    const normalizedAnswers = normalizeForPersist(answers);
    const durationSec = Math.max(0, Math.round(paper.durationSec - timeLeft));
    const requestAttemptId = makeAttemptId();
    let attemptId = requestAttemptId;
    let fallbackAttemptId = '';

    try {
      const response = await fetch('/api/mock/reading/mark', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          attemptId: requestAttemptId,
          mockId: paper.id,
          answers: normalizedAnswers,
          durationSec,
        }),
      });
      if (!response.ok) {
        const message = await response.text().catch(() => '');
        throw new Error(message || `Failed with status ${response.status}`);
      }
      const payload = (await response.json()) as { attemptId?: string };
      if (payload?.attemptId) {
        attemptId = payload.attemptId;
      }
      setLocalOnly(false);
    } catch (error) {
      fallbackAttemptId = `local-${Date.now()}`;
      attemptId = fallbackAttemptId;
      if (process.env.NODE_ENV !== 'production') {
        // eslint-disable-next-line no-console -- surfaced in development to aid debugging failures
        console.warn('[reading] Failed to persist attempt remotely, falling back to local storage.', error);
      }
      toast.error('Saved locally only. Weâ€™ll sync when youâ€™re back online.');
      setLocalOnly(true);
      try {
        localStorage.setItem(`read:attempt-res:${attemptId}`, JSON.stringify({ paper, answers: normalizedAnswers }));
      } catch {
        // ignore local storage failures so the flow can continue
      }
    } finally {
      if (!attemptId) {
        attemptId = fallbackAttemptId || requestAttemptId;
      }
      if (attemptRef.current) {
        await persistCheckpoint({ completed: true, force: true });
        if (checkpointTimeoutRef.current) {
          window.clearTimeout(checkpointTimeoutRef.current);
          checkpointTimeoutRef.current = null;
        }
        clearMockAttemptId('reading', paper.id);
      }
      clearMockDraft('reading', id);
      const targetUrl = `/review/reading/${id}?attempt=${encodeURIComponent(attemptId)}`;
      try {
        await router.replace(targetUrl);
      } catch (error) {
        if (process.env.NODE_ENV !== 'production') {
          // eslint-disable-next-line no-console -- surfaced in development to aid debugging navigation issues
          console.error('[reading] Failed to navigate to review screen after submission.', error);
        }
        setIsSubmitting(false);
      }
    }
  };

  if (!paper || !current) return <Shell title="Loading..."><div className="rounded-2xl border border-border p-4">Loading paperâ€¦</div></Shell>;

  const percent =
    questionStats.total > 0 ? Math.round((questionStats.answered / questionStats.total) * 100) : 0;

  const quickFilters: Array<{ id: QuestionNavFilter; label: string; count: number }> = [
    { id: 'all', label: 'All', count: questionStats.total },
    { id: 'unanswered', label: 'Unanswered', count: questionStats.unanswered },
    { id: 'flagged', label: 'Flagged', count: questionStats.flagged },
  ];

  const layoutIsSplit = layoutMode === 'split';
  const layoutContainerClass = layoutIsSplit
    ? 'flex flex-col gap-8 md:grid md:grid-cols-[minmax(0,1.3fr)_minmax(0,1fr)]'
    : 'flex flex-col gap-8';
  const reviewBarClasses = [
    'sticky bottom-0 mt-8 -mx-6 border-t border-border/70 bg-background/95 px-6 py-4 shadow-lg shadow-black/5 backdrop-blur supports-[backdrop-filter]:backdrop-blur',
  ];
  if (layoutIsSplit) {
    reviewBarClasses.push(
      'md:static md:mx-0 md:mt-auto md:rounded-2xl md:border md:bg-background/90 md:px-6 md:py-5 md:shadow-md md:backdrop-blur-none md:supports-[backdrop-filter]:backdrop-blur-none'
    );
  }

  const passageHeadingId = `passage-${current.id}-title`;

  return (
    <>
      <Shell
        title={paper.title}
        right={
          <>
            <div className="text-small text-foreground/80">Answered {percent}%</div>
            <div className="rounded-full border border-border px-3 py-1 text-small">â± {hhmmss(timeLeft)}</div>
            <FocusModeToggle active={focusMode} onToggle={handleFocusModeToggle} />
            <LayoutModeChips value={layoutMode} onChange={handleLayoutModeChange} />
          </>
        }
      >
        <div className="min-w-0 rounded-3xl border border-border/80 bg-background/60 p-6 shadow-lg shadow-black/5">
          {focusMode && isStarted ? <FocusModeNotice onExit={exitFocusMode} /> : null}
          <div className={layoutContainerClass}>
            <section className="min-w-0 space-y-4">
              <div className="flex flex-wrap items-center justify-between gap-3">
                <div className="text-small font-medium">
                  Passage {passageIdx + 1} of {paper.passages.length} â€” {current.title}
                </div>
                <div className="flex gap-2">
                  <Button
                    variant="ghost"
                    size="sm"
                    disabled={passageIdx === 0}
                    onClick={() => setPassageIdx((i) => Math.max(0, i - 1))}
                    className="border border-border text-small hover:border-primary disabled:opacity-60"
                  >
                    Prev
                  </Button>
                  <Button
                    variant="ghost"
                    size="sm"
                    disabled={passageIdx === paper.passages.length - 1}
                    onClick={() => setPassageIdx((i) => Math.min(paper.passages.length - 1, i + 1))}
                    className="border border-border text-small hover:border-primary disabled:opacity-60"
                  >
                    Next
                  </Button>
                </div>
              </div>
              <div className="rounded-xl border border-border/70 bg-background/70 p-4">
                <ReadingPassage
                  text={current.text}
                  highlights={passageHighlights}
                  onCreateHighlight={handleSelectionHighlight}
                  onCreateNote={handleSelectionNote}
                  onHighlightFocus={handleHighlightFocus}
                />
              </div>
              <p className="text-caption text-foreground/70">
                Select text in the passage to highlight or add a note. Highlights autosave for this attempt.
              </p>
            </section>
            <section className="min-w-0 flex flex-col gap-4">
              <div className="grid gap-3">
              {current.questions.map((q, idx) => {
                const entry = answers[q.id];
                const value = getAnswerText(entry);
                const flagged = isFlagged(entry);
                const answered = isAnsweredEntry(entry);
                const questionNumber = questionIndexMap.get(q.id) ?? idx + 1;
                return (
                  <div
                    key={q.id}
                    ref={(node) => {
                      if (node) {
                        questionRefs.current[q.id] = node;
                      } else {
                        delete questionRefs.current[q.id];
                      }
                    }}
                    className={[
                      'group rounded-xl border bg-background/90 p-4 transition focus-within:ring-2 focus-within:ring-ring focus-within:ring-offset-2 focus-within:ring-offset-background',
                      flagged ? 'border-warning/80 bg-warning/5' : answered ? 'border-success/60' : 'border-border',
                      currentQuestionId === q.id ? 'ring-1 ring-primary/40' : '',
                    ].join(' ')}
                  >
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1">
                        <div className="text-caption font-semibold uppercase tracking-wide text-foreground/60">
                          Question {questionNumber}
                        </div>
                        <div className="mt-1 text-small font-medium text-foreground">{q.prompt || q.id}</div>
                      </div>
                      <Button
                        type="button"
                        variant="ghost"
                        size="sm"
                        onClick={() => toggleFlag(q.id)}
                        className={[
                          'rounded-full border px-2 text-caption',
                          flagged
                            ? 'border-warning bg-warning/10 text-warning'
                            : 'border-border text-foreground/70 hover:border-warning hover:text-warning',
                        ].join(' ')}
                        leadingIcon={<Flag className="h-3.5 w-3.5" aria-hidden />}
                        aria-pressed={flagged}
                      >
                        {flagged ? 'Flagged' : 'Flag'}
                      </Button>
                    </div>
                    <div className="mt-3">
                      {renderInput(q, value, {
                        onChange: (val) => updateAnswerValue(q.id, val),
                        onFocus: () => setActiveQuestionId(q.id),
                      })}
                    </div>
                  </div>
                );
              })}
            </div>
            <div className={reviewBarClasses.join(' ')}>
              <div className="flex flex-col gap-3 lg:flex-row lg:items-center lg:justify-between">
                <div className="flex flex-wrap gap-2" role="group" aria-label="Question filters">
                  {quickFilters.map((item) => {
                    const isActive = questionFilter === item.id;
                    return (
                      <Button
                        key={item.id}
                        type="button"
                        variant="ghost"
                        size="sm"
                        onClick={() => applyQuestionFilter(item.id, 'toolbar')}
                        className={[
                          'rounded-full border px-3 text-small',
                          isActive
                            ? 'border-primary bg-primary/10 text-primary'
                            : 'border-border text-foreground hover:border-primary',
                        ].join(' ')}
                        aria-pressed={isActive}
                      >
                        {item.label}
                        <span className="ml-2 text-foreground/60">{item.count}</span>
                      </Button>
                    );
                  })}
                </div>
                <div className="flex flex-wrap items-center gap-2">
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={() => {
                      applyQuestionFilter('unanswered', 'toolbar');
                      if (nextUnanswered) scrollToQuestion(nextUnanswered.id);
                    }}
                    className="rounded-full border border-border text-small text-foreground hover:border-primary disabled:cursor-not-allowed disabled:opacity-60"
                    disabled={isSubmitting || !nextUnanswered}
                  >
                    Review unanswered
                  </Button>
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={() => {
                      applyQuestionFilter('flagged', 'toolbar');
                      if (nextFlagged) scrollToQuestion(nextFlagged.id);
                    }}
                    className="rounded-full border border-border text-small text-foreground hover:border-warning disabled:cursor-not-allowed disabled:opacity-60"
                    disabled={isSubmitting || !nextFlagged}
                  >
                    Review flagged
                  </Button>
                  <Button
                    type="button"
                    variant="primary"
                    size="sm"
                    onClick={submit}
                    className="rounded-full px-4 text-small font-semibold text-background disabled:cursor-not-allowed disabled:opacity-70"
                    disabled={isSubmitting}
                    aria-busy={isSubmitting}
                  >
                    {isSubmitting ? 'Submittingâ€¦' : 'Submit for scoring'}
                  </Button>
                </div>
              </div>
            </div>
            </section>
          </div>
      </div>
      <aside className="flex h-full min-w-0 flex-col gap-4 md:max-w-sm xl:max-w-md">
        {localOnly && <OfflineOnlyBanner />}
        <QuestionNav
          questions={questionItems}
          answers={answers}
          filter={questionFilter}
          onFilterChange={(next) => applyQuestionFilter(next, 'nav')}
          onSelect={scrollToQuestion}
          onToggleFlag={toggleFlag}
          currentQuestionId={currentQuestionId}
        />
        <div className="flex-1 rounded-3xl border border-border/80 bg-background/60 p-5 shadow-lg shadow-black/5">
          <div className="mb-2 flex items-center justify-between gap-3">
            <div className="text-small font-medium">Highlights &amp; notes</div>
            {!notesLoaded && <span className="text-caption text-foreground/60">Syncingâ€¦</span>}
          </div>
          {passageNotes.length === 0 ? (
            <p className="text-caption text-foreground/60">
              Select text in the passage to leave highlights or notes. They&apos;ll appear here for quick access.
            </p>
          ) : (
            <div className="flex flex-col gap-3">
              {passageNotes.map((note) => {
                const isEditing = editingNoteId === note.id;
                const hasNote = Boolean(note.noteText && note.noteText.trim().length > 0);
                const excerpt = current ? excerptForNote(note, current.text) : '';
                return (
                  <div
                    key={note.id}
                    ref={(node) => {
                      if (node) {
                        noteRefs.current[note.id] = node;
                      } else {
                        delete noteRefs.current[note.id];
                      }
                    }}
                    tabIndex={-1}
                    className={`rounded-xl border p-3 outline-none transition focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background ${
                      isEditing ? 'border-primary shadow-sm' : 'border-border'
                    }`}
                  >
                    <div className="text-caption font-medium uppercase text-foreground/60">Highlight</div>
                    <p className="mt-1 whitespace-pre-wrap text-small text-foreground/90">{excerpt}</p>
                    {isEditing ? (
                      <div className="mt-3 space-y-2">
                        <label className="block text-caption font-medium text-foreground/70" htmlFor={`note-edit-${note.id}`}>
                          Note
                        </label>
                        <textarea
                          id={`note-edit-${note.id}`}
                          value={noteEditorValue}
                          onChange={(event) => setNoteEditorValue(event.target.value)}
                          rows={3}
                          className="w-full resize-none rounded-lg border border-border bg-background px-3 py-2 text-small focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background"
                          placeholder="Add your note"
                        />
                        <div className="flex flex-wrap gap-2">
                          <Button
                            type="button"
                            variant="primary"
                            size="sm"
                            onClick={() => handleNoteSave(note.id)}
                            className="rounded-full px-3 text-small font-medium text-background"
                          >
                            Save
                          </Button>
                          <Button
                            type="button"
                            variant="ghost"
                            size="sm"
                            onClick={cancelNoteEditing}
                            className="rounded-full border border-border text-small text-foreground/70 hover:border-foreground/50"
                          >
                            Cancel
                          </Button>
                        </div>
                      </div>
                    ) : (
                      <div className="mt-3 space-y-2">
                        <div className="whitespace-pre-wrap text-small text-foreground/80">
                          {hasNote ? note.noteText : <span className="text-foreground/60">No note yet.</span>}
                        </div>
                        <div className="flex flex-wrap gap-2">
                          <Button
                            type="button"
                            variant="ghost"
                            size="sm"
                            onClick={() => handleHighlightFocus(note.id)}
                            className="rounded-full border border-border text-small text-foreground hover:border-primary hover:text-primary"
                          >
                            {hasNote ? 'Edit note' : 'Add note'}
                          </Button>
                          <Button
                            type="button"
                            variant="ghost"
                            size="sm"
                            onClick={() => handleRemoveHighlight(note.id)}
                            className="rounded-full border border-border text-small text-danger hover:border-danger hover:bg-danger/10"
                          >
                            Remove
                          </Button>
                        </div>
                      </div>
                    )}
                  </div>
                );
              })}
            </div>
          )}
        </div>
        <div className="mt-auto pt-4">
          <Link href="/reading" className="text-small underline underline-offset-4">
            Change test
          </Link>
        </div>
      </aside>
      </Shell>
      <StartOverlay
        open={!isStarted}
        layoutMode={layoutMode}
        onLayoutChange={handleLayoutModeChange}
        focusMode={focusMode}
        onFocusModeChange={handleFocusModeToggle}
        onStart={startExam}
        paperTitle={paper.title}
        durationSec={paper.durationSec}
        resumeAvailable={resumeAvailable}
      />
      <style jsx global>{`
        :root[data-focus-mode="true"] header[data-solid] {
          display: none !important;
        }
        :root[data-focus-mode="true"] nav[aria-label="Bottom navigation"],
        :root[data-focus-mode="true"] [aria-controls="quick-actions-menu"],
        :root[data-focus-mode="true"] #quick-actions-menu {
          display: none !important;
        }
      `}</style>
    </>
  );
}

type LayoutModeChipsProps = {
  value: LayoutMode;
  onChange: (mode: LayoutMode) => void;
};

type FocusModeToggleProps = {
  active: boolean;
  onToggle: (next: boolean) => void;
};

function FocusModeToggle({ active, onToggle }: FocusModeToggleProps) {
  return (
    <Button
      type="button"
      variant="ghost"
      size="sm"
      onClick={() => onToggle(!active)}
      aria-pressed={active}
      className={[
        'rounded-full border px-3 text-small',
        active ? 'border-primary bg-primary/10 text-primary' : 'border-border text-foreground/80 hover:border-primary',
      ].join(' ')}
    >
      {active ? 'Focus mode on' : 'Focus mode off'}
    </Button>
  );
}

type FocusModeNoticeProps = {
  onExit: () => void;
};

function FocusModeNotice({ onExit }: FocusModeNoticeProps) {
  return (
    <div className="mb-4 rounded-xl border border-primary/40 bg-primary/10 px-4 py-3 text-small text-primary">
      <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
        <p className="font-medium">Focus mode is on â€” navigation and alerts are hidden.</p>
        <Button
          type="button"
          variant="ghost"
          size="sm"
          onClick={onExit}
          className="rounded-full border border-primary text-small font-semibold text-primary hover:bg-primary hover:text-background"
        >
          Exit focus mode
        </Button>
      </div>
      <p className="mt-1 text-caption text-primary/80">You can toggle focus mode anytime from the header controls.</p>
    </div>
  );
}

function LayoutModeChips({ value, onChange }: LayoutModeChipsProps) {
  return (
    <div className="flex items-center gap-2">
      <span className="text-caption text-foreground/60">Layout</span>
      <div
        className="inline-flex items-center gap-1 rounded-full border border-border bg-background/60 p-1"
        role="group"
        aria-label="Exam layout"
      >
        {LAYOUT_OPTIONS.map((option) => {
          const active = value === option.id;
          return (
            <Button
              key={option.id}
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => onChange(option.id)}
              className={[
                'rounded-full px-3 text-caption font-medium',
                active ? 'bg-primary text-background shadow-sm' : 'text-foreground/70 hover:text-foreground',
              ].join(' ')}
              aria-pressed={active}
            >
              {option.shortLabel}
            </Button>
          );
        })}
      </div>
    </div>
  );
}

type StartOverlayProps = {
  open: boolean;
  layoutMode: LayoutMode;
  onLayoutChange: (mode: LayoutMode) => void;
  focusMode: boolean;
  onFocusModeChange: (next: boolean) => void;
  onStart: () => void;
  paperTitle: string;
  durationSec: number;
  resumeAvailable: boolean;
};

function StartOverlay({
  open,
  layoutMode,
  onLayoutChange,
  focusMode,
  onFocusModeChange,
  onStart,
  paperTitle,
  durationSec,
  resumeAvailable,
}: StartOverlayProps) {
  const dialogId = useId();
  if (!open) return null;

  const minutes = Math.max(1, Math.round(durationSec / 60));
  const layoutGroupName = `${dialogId}-layout`;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-background/95 px-4 pb-safe pt-safe backdrop-blur supports-[backdrop-filter]:bg-background/80">
      <div
        role="dialog"
        aria-modal="true"
        aria-labelledby={`${dialogId}-title`}
        aria-describedby={`${dialogId}-description`}
        className="w-full max-w-xl rounded-2xl border border-border bg-card p-6 shadow-card"
      >
        <div className="space-y-5">
          <div className="space-y-2">
            <h2 id={`${dialogId}-title`} className="text-h4 font-semibold">
              Ready to start?
            </h2>
            <p id={`${dialogId}-description`} className="text-small text-foreground/70">
              Choose how you want to view the passage and questions before you begin. You can change this later from the top bar.
            </p>
          </div>
          <div className="rounded-xl border border-border bg-background/60 p-4">
            <div className="text-small font-semibold text-foreground">{paperTitle}</div>
            <div className="mt-1 text-caption text-foreground/70">Approx. {minutes} minute session</div>
          </div>
          {resumeAvailable ? (
            <div className="rounded-xl border border-warning/50 bg-warning/10 px-4 py-3 text-small text-warning">
              <p className="font-semibold">We saved your progress.</p>
              <p className="text-caption text-warning/90">
                Your answers, highlights, and timer will resume from the last checkpoint.
              </p>
            </div>
          ) : null}
          <div className="rounded-xl border border-border bg-background/60 p-4">
            <div className="text-small font-semibold text-foreground">Instructions &amp; rules</div>
            <ul className="mt-2 list-disc space-y-2 pl-5 text-small text-foreground/80">
              <li>The timer keeps running even if you leave or refresh the page.</li>
              <li>Use highlights and notes to mark the passage â€” everything autosaves.</li>
              <li>Flag questions you want to review before submitting.</li>
            </ul>
          </div>
          <div className="space-y-2">
            <div className="text-small font-medium text-foreground" id={`${dialogId}-layout-label`}>
              Pick your layout
            </div>
            <div
              role="radiogroup"
              aria-labelledby={`${dialogId}-layout-label`}
              className="grid gap-3 sm:grid-cols-2"
            >
              {LAYOUT_OPTIONS.map((option) => {
                const checked = layoutMode === option.id;
                const optionId = `${layoutGroupName}-${option.id}`;
                return (
                  <label
                    key={option.id}
                    htmlFor={optionId}
                    className={[
                      'cursor-pointer rounded-xl border p-4 transition focus-within:outline-none focus-within:ring-2 focus-within:ring-ring focus-within:ring-offset-2 focus-within:ring-offset-background',
                      checked
                        ? 'border-primary bg-primary/10 text-primary shadow-sm'
                        : 'border-border bg-background/80 text-foreground hover:border-primary/60',
                    ].join(' ')}
                  >
                    <input
                      id={optionId}
                      type="radio"
                      name={layoutGroupName}
                      checked={checked}
                      onChange={() => onLayoutChange(option.id)}
                      className="sr-only"
                    />
                    <div className="text-small font-semibold">{option.label}</div>
                    <p className="mt-1 text-caption text-foreground/70">{option.description}</p>
                  </label>
                );
              })}
            </div>
          </div>
          <div className="rounded-xl border border-border bg-background/70 p-4">
            <Checkbox
              checked={focusMode}
              onCheckedChange={onFocusModeChange}
              label="Start in focus mode"
              description="Hide navigation and notifications for a distraction-free session. You can exit anytime from the exam header."
            />
          </div>
          <div className="flex flex-wrap items-center justify-between gap-3">
            <p className="text-caption text-foreground/60">Layout applies on desktop; mobile stays single column.</p>
            <Button
              type="button"
              variant="primary"
              size="sm"
              onClick={onStart}
              className="rounded-full px-4 text-small font-semibold text-background"
            >
              {resumeAvailable ? 'Resume exam' : 'Start exam'}
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
}

function renderInput(
  q: Q,
  value: string,
  handlers: { onChange: (v: string) => void; onFocus: () => void }
) {
  if (q.type === 'tfng') {
    const opts = ['True', 'False', 'Not Given'];
    return <Options options={opts} value={value} onPick={handlers.onChange} onFocus={handlers.onFocus} />;
  }
  if (q.type === 'yynn') {
    const opts = ['Yes', 'No', 'Not Given'];
    return <Options options={opts} value={value} onPick={handlers.onChange} onFocus={handlers.onFocus} />;
  }
  if (q.type === 'heading' || q.type === 'mcq') {
    return (
      <Options
        options={normalizeOptionList(q.options)}
        value={value}
        onPick={handlers.onChange}
        onFocus={handlers.onFocus}
      />
    );
  }
  if (q.type === 'match') {
    return (
      <MatchOptions
        options={normalizeOptionList(q.options)}
        value={value}
        onPick={handlers.onChange}
        onFocus={handlers.onFocus}
      />
    );
  }
  return (
    <input
      value={value}
      onChange={(e) => handlers.onChange(e.target.value)}
      onFocus={handlers.onFocus}
      className="mt-1 w-full rounded-lg border border-border bg-background px-3 py-2 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background"
      placeholder="Type your answer"
    />
  );
}

function normalizeOptionList(options: Q['options']): string[] {
  if (!options) return [];
  if (Array.isArray(options)) return options;
  const fromPairs = Array.isArray(options.pairs)
    ? options.pairs.flatMap((pair) => {
        if (!pair) return [];
        const rights = Array.isArray(pair.right) ? pair.right : pair.right ? [pair.right] : [];
        if (rights.length === 0) return pair.left ? [pair.left] : [];
        return rights.map((right) => `${pair.left} -> ${right}`);
      })
    : [];
  const extras = Array.isArray(options.choices) ? options.choices : [];
  return [...fromPairs, ...extras];
}

const Options: React.FC<{
  options: string[];
  value: string;
  onPick: (v: string) => void;
  onFocus: () => void;
}> = ({ options, value, onPick, onFocus }) => (
  <div className="flex flex-wrap gap-2">
    {options.map((opt) => (
      <Button
        key={opt}
        type="button"
        variant="ghost"
        size="sm"
        onClick={() => {
          onFocus();
          onPick(opt);
        }}
        onFocus={onFocus}
        className={[
          'h-auto rounded-lg border px-3 text-small',
          value === opt ? 'border-primary bg-primary/10 text-primary' : 'border-border text-foreground',
        ].join(' ')}
      >
        {opt}
      </Button>
    ))}
  </div>
);

const MatchOptions: React.FC<{
  options: string[];
  value: string;
  onPick: (v: string) => void;
  onFocus: () => void;
}> = ({ options, value, onPick, onFocus }) => (
  <div className="grid gap-2 sm:grid-cols-2">
    {options.map((opt, index) => (
      <Button
        key={toOptionId(opt, index)}
        type="button"
        variant="ghost"
        size="sm"
        onClick={() => {
          onFocus();
          onPick(opt);
        }}
        onFocus={onFocus}
        className={[
          'h-auto rounded-lg border px-3 text-left text-small leading-snug',
          value === opt ? 'border-primary bg-primary/10 text-primary' : 'border-border text-foreground',
        ].join(' ')}
      >
        {opt}
      </Button>
    ))}
  </div>
);

function normalizeAnswerEntry(value: unknown): ReadingAnswer {
  if (value && typeof value === 'object') {
    const record = value as { value?: unknown; flagged?: unknown };
    const raw = record.value;
    const normalizedValue =
      typeof raw === 'string' ? raw : raw == null ? '' : String(raw);
    return {
      value: normalizedValue,
      flagged: record.flagged === true,
    };
  }
  if (typeof value === 'string') {
    return { value, flagged: false };
  }
  if (value == null) {
    return { value: '', flagged: false };
  }
  return { value: String(value), flagged: false };
}

function normalizeAnswerMap(input: unknown): AnswerMap {
  if (!input || typeof input !== 'object') return {};
  const result: AnswerMap = {};
  Object.entries(input as Record<string, unknown>).forEach(([key, value]) => {
    if (typeof key !== 'string') return;
    result[key] = normalizeAnswerEntry(value);
  });
  return result;
}

function normalizeQuestionFilter(value: unknown): QuestionNavFilter {
  return value === 'flagged' || value === 'unanswered' ? value : 'all';
}

function isAnsweredEntry(entry?: ReadingAnswer): boolean {
  if (!entry) return false;
  return getAnswerText(entry).trim().length > 0;
}

function isFlaggedEntry(entry?: ReadingAnswer): boolean {
  return isFlagged(entry);
}

const hhmmss = (sec: number) => `${Math.floor(sec/60).toString().padStart(2,'0')}:${Math.floor(sec%60).toString().padStart(2,'0')}`;
const formatTimeForAnnouncement = (seconds: number) => {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  const parts: string[] = [];
  if (mins > 0) parts.push(`${mins} minute${mins === 1 ? '' : 's'}`);
  if (secs > 0 || mins === 0) parts.push(`${secs} second${secs === 1 ? '' : 's'}`);
  return parts.join(' ');
};
const toOptionId = (value: string, index: number) => {
  const base = value.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
  return base || `option-${index}`;
};
const describeQuestionType = (type: QType) => {
  switch (type) {
    case 'tfng':
      return 'True, False, or Not Given question';
    case 'yynn':
      return 'Yes, No, or Not Given question';
    case 'heading':
      return 'Heading matching question';
    case 'match':
      return 'Matching question';
    case 'mcq':
      return 'Multiple choice question';
    default:
      return 'Short answer question';
  }
};
function normalizeLayoutMode(value: unknown): LayoutMode {
  return value === 'scroll' ? 'scroll' : 'split';
}

function getStoredLayoutMode(): LayoutMode {
  if (typeof window === 'undefined') return 'split';
  try {
    const stored = window.localStorage.getItem(LAYOUT_PREF_KEY);
    return normalizeLayoutMode(stored ?? undefined);
  } catch {
    return 'split';
  }
}

function setStoredLayoutMode(mode: LayoutMode) {
  if (typeof window === 'undefined') return;
  try {
    window.localStorage.setItem(LAYOUT_PREF_KEY, mode);
  } catch {
    // ignore persistence errors
  }
}

function getStoredFocusMode(): boolean {
  if (typeof window === 'undefined') return false;
  try {
    return window.localStorage.getItem(FOCUS_MODE_PREF_KEY) === '1';
  } catch {
    return false;
  }
}

function setStoredFocusMode(value: boolean) {
  if (typeof window === 'undefined') return;
  try {
    window.localStorage.setItem(FOCUS_MODE_PREF_KEY, value ? '1' : '0');
  } catch {
    // ignore persistence errors
  }
}

function hasAnyAnswered(map: AnswerMap): boolean {
  return Object.values(map).some((entry) => getAnswerText(entry).trim().length > 0);
}

function mapReadingNote(row: {
  id?: string;
  passageId?: string;
  ranges?: Array<{ start?: number; end?: number; color?: string }>;
  noteText?: string | null;
  text?: string | null;
  start?: number;
  end?: number;
  color?: string;
}): ReadingNote | null {
  const parsed = parseServerNote(row);
  const passageId = typeof row?.passageId === 'string' ? row.passageId : null;
  if (!parsed.id || !passageId) return null;

  let ranges = parsed.ranges;
  if (ranges.length === 0) {
    const legacyStart = typeof row?.start === 'number' ? Number(row.start) : null;
    const legacyEnd = typeof row?.end === 'number' ? Number(row.end) : null;
    if (legacyStart !== null && legacyEnd !== null && legacyEnd > legacyStart) {
      ranges = [{ start: legacyStart, end: legacyEnd }];
    }
  }
  const normalizedRanges = ranges
    .map((range) => ({
      start: Math.max(0, Math.round(range.start)),
      end: Math.max(0, Math.round(range.end)),
    }))
    .filter((range) => range.end > range.start);
  if (normalizedRanges.length === 0) return null;

  const [primary] = normalizedRanges;
  const colorCandidate =
    (Array.isArray(row?.ranges) && typeof row.ranges[0]?.color === 'string' && row.ranges[0]?.color) ||
    (typeof row?.color === 'string' && row.color) ||
    DEFAULT_NOTE_COLOR;

  const textValue =
    typeof row?.noteText === 'string'
      ? row.noteText
      : typeof row?.text === 'string'
        ? row.text
        : parsed.text;

  return {
    id: parsed.id,
    passageId,
    start: primary.start,
    end: primary.end,
    ranges: normalizedRanges,
    color: colorCandidate,
    noteText: textValue && textValue.length > 0 ? textValue : null,
  };
}

function mergeNotes(existing: ReadingNote[], incoming: ReadingNote[]): ReadingNote[] {
  const map = new Map<string, ReadingNote>();
  for (const note of existing) {
    map.set(note.id, note);
  }
  for (const note of incoming) {
    map.set(note.id, note);
  }
  return Array.from(map.values()).sort((a, b) => {
    if (a.passageId === b.passageId) return a.start - b.start;
    return a.passageId.localeCompare(b.passageId);
  });
}

function rangesOverlap(aStart: number, aEnd: number, bStart: number, bEnd: number) {
  return Math.max(aStart, bStart) < Math.min(aEnd, bEnd);
}

function excerptForNote(note: ReadingNote, text: string): string {
  if (!text) return '';
  const length = text.length;
  const start = Math.max(0, Math.min(note.start, length));
  const end = Math.max(start, Math.min(note.end, length));
  const raw = text.slice(start, end).trim();
  if (!raw) {
    const fallback = text.slice(start, Math.min(start + 160, length)).trim();
    return fallback.length > 0 ? fallback : text.slice(0, Math.min(160, length)).trim();
  }
  if (raw.length <= 160) return raw;
  return `${raw.slice(0, 157)}â€¦`;
}




============================================================
FILE #42
PATH: pages/account/index.tsx
============================================================
// pages/settings/index.tsx
'use client';

import * as React from "react";
import Head from "next/head";
import Link from "next/link";
import { useRouter } from "next/router";
import { Container } from "@/components/design-system/Container";
import { Button } from "@/components/design-system/Button";
import { Badge } from "@/components/design-system/Badge";
import { Card } from "@/components/design-system/Card";
import { supabaseBrowser as supabase } from "@/lib/supabaseBrowser";
import { getPlan, isPaidPlan, type PlanId } from "@/types/pricing";

type BillingSummary = {
  plan: PlanId;
  status:
    | "active"
    | "trialing"
    | "canceled"
    | "incomplete"
    | "past_due"
    | "unpaid"
    | "paused";
  renewsAt?: string;
  trialEndsAt?: string;
};

type BillingSummaryResponse =
  | { ok: true; summary: BillingSummary; customerId?: string | null; needsStripeSetup?: boolean }
  | { ok: false; error: string };

export default function SettingsHubPage() {
  const router = useRouter();
  const [email, setEmail] = React.useState<string | null>(null);
  const [sending, setSending] = React.useState(false);
  const [isAdmin, setIsAdmin] = React.useState(false);  // Admin check
  const [billingLoading, setBillingLoading] = React.useState(true);
  const [billingError, setBillingError] = React.useState<string | null>(null);
  const [summary, setSummary] = React.useState<BillingSummary | null>(null);
  const [portalAvailable, setPortalAvailable] = React.useState(false);
  const [portalLoading, setPortalLoading] = React.useState(false);

  const statusVariant = React.useCallback((status: BillingSummary["status"]): React.ComponentProps<typeof Badge>["variant"] => {
    switch (status) {
      case "active":
        return "success";
      case "trialing":
        return "info";
      case "past_due":
      case "incomplete":
        return "warning";
      case "unpaid":
        return "danger";
      case "paused":
        return "secondary";
      case "canceled":
      default:
        return "neutral";
    }
  }, []);

  const formatStatus = React.useCallback((status: BillingSummary["status"]) => {
    return status
      .replace(/_/g, " ")
      .replace(/\b\w/g, (char) => char.toUpperCase());
  }, []);

  React.useEffect(() => {
    let cancelled = false;

    (async () => {
      try {
        setBillingLoading(true);
        setBillingError(null);

        const response = await fetch("/api/billing/summary", { credentials: "include" });
        const data: BillingSummaryResponse = await response.json();

        if (!response.ok) {
          throw new Error(response.statusText || "Failed to load billing");
        }

        if (!data.ok) {
          throw new Error(data.error || "Failed to load billing");
        }

        if (cancelled) return;

        setSummary(data.summary);
        const canOpenPortal = Boolean(data.customerId) && !data.needsStripeSetup;
        setPortalAvailable(canOpenPortal);
      } catch (error) {
        if (cancelled) return;
        setBillingError((error as Error).message || "Failed to load billing");
        setSummary(null);
        setPortalAvailable(false);
      } finally {
        if (!cancelled) {
          setBillingLoading(false);
        }
      }
    })();

    return () => {
      cancelled = true;
    };
  }, []);

  const openPortal = React.useCallback(async () => {
    try {
      setBillingError(null);
      setPortalLoading(true);

      const response = await fetch("/api/billing/create-portal-session", {
        method: "POST",
        credentials: "include",
      });
      const payload = await response.json();

      if (!response.ok) {
        throw new Error((payload && payload.error) || response.statusText || "Failed to open billing portal");
      }

      const url = typeof payload?.url === "string" ? payload.url : null;
      if (!url) {
        throw new Error("Failed to open billing portal");
      }

      window.location.href = url;
    } catch (error) {
      setBillingError((error as Error).message || "Failed to open billing portal");
      setPortalLoading(false);
    }
  }, []);

  const planDefinition = React.useMemo(() => (summary ? getPlan(summary.plan) : null), [summary]);
  const isPremiumPlan = React.useMemo(() => (summary ? isPaidPlan(summary.plan) : false), [summary]);
  const dateFormatter = React.useMemo(() => new Intl.DateTimeFormat(undefined, { dateStyle: "medium" }), []);
  const planMeta = React.useMemo(() => {
    if (!summary) return null;
    const parts: string[] = [];
    if (summary.renewsAt) {
      parts.push(`Renews ${dateFormatter.format(new Date(summary.renewsAt))}`);
    }
    if (summary.trialEndsAt) {
      parts.push(`Trial ends ${dateFormatter.format(new Date(summary.trialEndsAt))}`);
    }
    return parts;
  }, [summary, dateFormatter]);

  React.useEffect(() => {
    let mounted = true;
    (async () => {
      const { data } = await supabase.auth.getSession();
      if (mounted) setEmail(data.session?.user?.email ?? null);

      // Check if the user is an admin
      const { data: profile } = await supabase
        .from('profiles')
        .select('role')
        .eq('id', data.session?.user?.id)
        .single();

      if (profile?.role === 'admin') setIsAdmin(true);
    })();
    return () => { mounted = false; };
  }, []);

  const safePush = (href: string) => {
    if (router.asPath !== href) void router.push(href);
  };

  const handleReset = async () => {
    if (!email || sending) return;
    setSending(true);
    try {
      const origin =
        typeof window !== "undefined"
          ? window.location.origin
          : process.env.NEXT_PUBLIC_SITE_URL || "";
      const { error } = await supabase.auth.resetPasswordForEmail(email, {
        redirectTo: `${origin}/login/reset`,
      });
      if (error) {
        alert(error.message);
      } else {
        alert("Password reset email sent.");
      }
    } finally {
      setSending(false);
    }
  };

  return (
    <>
      <Head>
        <title>Settings Â· GramorX</title>
        <meta
          name="description"
          content="Manage language, notifications, accessibility and account settings."
        />
      </Head>

      <main className="bg-lightBg py-16 dark:bg-gradient-to-br dark:from-dark/80 dark:to-darker/90">
        <Container className="space-y-6">
          <header className="mb-4">
            <h1 className="text-h2 font-bold text-foreground">Settings</h1>
            <p className="text-small text-muted-foreground">
              Tweak your experience and account preferences.
            </p>
          </header>

          <section className="grid grid-cols-1 gap-4 md:grid-cols-2">
            {/* Plan & Billing */}
            <div className="rounded-xl border border-border bg-card p-4">
              <div className="flex items-start justify-between gap-3">
                <div>
                  <h2 className="text-small font-medium text-foreground">Plan &amp; Billing</h2>
                  <p className="mt-1 text-small text-muted-foreground">
                    Check your subscription status and manage billing details.
                  </p>
                </div>
                {isPremiumPlan && <Badge variant="accent">Premium</Badge>}
              </div>

              <div className="mt-3 space-y-3">
                {billingLoading ? (
                  <p className="text-small text-muted-foreground">Checking your planâ€¦</p>
                ) : billingError ? (
                  <p className="text-small text-danger">{billingError}</p>
                ) : summary ? (
                  <>
                    <div className="flex flex-wrap items-center gap-2">
                      <Badge variant={statusVariant(summary.status)}>{formatStatus(summary.status)}</Badge>
                      {planDefinition && (
                        <span className="text-small text-muted-foreground">{planDefinition.name}</span>
                      )}
                    </div>

                    {planMeta && planMeta.length > 0 && (
                      <p className="text-caption text-muted-foreground">
                        {planMeta.map((part, index) => (
                          <React.Fragment key={`${part}-${index}`}>
                            {index > 0 && <span aria-hidden="true"> Â· </span>}
                            <span>{part}</span>
                          </React.Fragment>
                        ))}
                      </p>
                    )}

                    <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:gap-3">
                      {isPremiumPlan ? (
                        portalAvailable ? (
                          <Button onClick={openPortal} loading={portalLoading} variant="soft" tone="accent">
                            {portalLoading ? "Openingâ€¦" : "Manage billing"}
                          </Button>
                        ) : (
                          <Button asChild variant="soft">
                            <Link href="/pricing">Change plan</Link>
                          </Button>
                        )
                      ) : (
                        <Button asChild variant="soft" tone="accent">
                          <Link href="/pricing">Upgrade to Premium</Link>
                        </Button>
                      )}

                      {!isPremiumPlan && (
                        <span className="text-caption text-muted-foreground">
                          Unlock unlimited mock exams, full AI evaluations, and coaching tools.
                        </span>
                      )}
                    </div>

                    {!portalAvailable && isPremiumPlan && (
                      <p className="text-caption text-muted-foreground">
                        The billing portal is temporarily unavailable. Email {" "}
                        <a className="underline" href="mailto:support@gramorx.com">
                          support@gramorx.com
                        </a>{" "}
                        to update or cancel your plan.
                      </p>
                    )}
                  </>
                ) : (
                  <p className="text-small text-muted-foreground">
                    We couldnâ€™t find an active subscription yet. Upgrade to unlock Premium perks.
                  </p>
                )}
              </div>
            </div>

            {/* Language */}
            <div className="rounded-xl border border-border bg-card p-4">
              <h2 className="text-small font-medium text-foreground">Language</h2>
              <p className="mt-1 text-small text-muted-foreground">
                Switch between English and Urdu. We remember your choice.
              </p>
              <div className="mt-3 flex gap-2">
                <Button
                  variant="soft"
                  onClick={(e) => {
                    e.preventDefault();
                    if (router.asPath !== "/settings/language") {
                      safePush("/settings/language");
                    }
                  }}
                >
                  Open Language Settings
                </Button>
                <Link href="/settings/language" prefetch={false} className="sr-only">
                  Language (link for SEO)
                </Link>
              </div>
            </div>

            {/* Notifications (placeholder) */}
            <div className="rounded-xl border border-border bg-card p-4">
              <h2 className="text-small font-medium text-foreground">Notifications</h2>
              <p className="mt-1 text-small text-muted-foreground">
                Daily task reminders and challenge nudges.
              </p>
              <div className="mt-3 text-caption text-muted-foreground">
                Coming soon â€” wired to <code className="font-mono">/api/notifications/nudge</code>.
              </div>
            </div>

            {/* Accessibility */}
            <div className="rounded-xl border border-border bg-card p-4">
              <h2 className="text-small font-medium text-foreground">Accessibility</h2>
              <p className="mt-1 text-small text-muted-foreground">
                High contrast themes, keyboard checks, and screen reader hints.
              </p>
              <div className="mt-3">
                <Button
                  variant="soft"
                  onClick={(e) => {
                    e.preventDefault();
                    safePush("/settings/accessibility");
                  }}
                >
                  Open Accessibility
                </Button>
                <Link href="/settings/accessibility" prefetch={false} className="sr-only">
                  Accessibility (link for SEO)
                </Link>
              </div>
            </div>

            {/* Security */}
            <div className="rounded-xl border border-border bg-card p-4">
              <h2 className="text-small font-medium text-foreground">Security</h2>
              <p className="mt-1 text-small text-muted-foreground">
                Reset your password.{" "}
                {email ? `Email on file: ${email}` : "No email on file."}
              </p>
              <div className="mt-3 flex items-center gap-2">
                <Button
                  variant="solid"
                  tone="accent"
                  onClick={handleReset}
                  disabled={!email || sending}
                  loading={sending}
                >
                  Send reset email
                </Button>
                {!email && (
                  <span className="text-caption text-muted-foreground">
                    Add an email to your account first.
                  </span>
                )}
              </div>
            </div>

            {/* Premium PIN */}
            <div className="rounded-xl border border-border bg-card p-4">
              <h2 className="text-small font-medium text-foreground">Premium PIN</h2>
              <p className="mt-1 text-small text-muted-foreground">
                Redeem a one-time access PIN shared by the GramorX team to unlock premium features
                without entering payment details.
              </p>
              <div className="mt-3">
                <Button asChild variant="soft">
                  <Link href="/account/redeem">Redeem PIN</Link>
                </Button>
              </div>
            </div>
          </section>

          {/* Admin Panel Link */}
          {isAdmin && (
            <Card className="p-6 flex flex-col md:flex-row md:items-center md:justify-between gap-3 card-surface">
              <div className="space-y-1">
                <div className="flex items-center gap-2">
                  <h2 className="text-lg font-semibold">Admin Panel</h2>
                  <Badge variant="secondary">Admin</Badge>
                </div>
                <p className="text-sm text-muted-foreground">
                  Manage teachers, partners, pricing, and reports.
                </p>
              </div>
              <Link href="/admin" className="nav-pill">
                <Button className="btn">Open Admin Panel</Button>
              </Link>
            </Card>
          )}
        </Container>
      </main>
    </>
  );
}





============================================================
FILE #43
PATH: pages/notifications/index.tsx
============================================================
import * as React from 'react';
import Head from 'next/head';
import Link from 'next/link';
import type { GetServerSideProps } from 'next';
import { DateTime } from 'luxon';

import { Container } from '@/components/design-system/Container';
import { Button } from '@/components/design-system/Button';
import { Alert } from '@/components/design-system/Alert';
import { createSupabaseServerClient } from '@/lib/supabaseServer';
import {
  NotificationListResponseSchema,
  type NotificationListResponse,
  type NotificationNudge,
} from '@/lib/schemas/notifications';

const PAGE_SIZE = 20;

type NotificationsPageProps = {
  initial: NotificationListResponse;
  loadError?: string | null;
};

function formatTimestamp(iso: string): string {
  const dt = DateTime.fromISO(iso);
  if (!dt.isValid) return '';
  const relative = dt.toRelative({ style: 'long' });
  return relative ?? dt.toLocaleString(DateTime.DATETIME_MED);
}

const EMPTY_PAYLOAD: NotificationListResponse = {
  items: [],
  nextCursor: null,
  unreadCount: 0,
};

const NotificationsPage: React.FC<NotificationsPageProps> = ({ initial, loadError = null }) => {
  const [items, setItems] = React.useState<NotificationNudge[]>(initial.items);
  const [nextCursor, setNextCursor] = React.useState<string | null>(initial.nextCursor);
  const [loadingMore, setLoadingMore] = React.useState(false);
  const [error, setError] = React.useState<string | null>(loadError);

  const handleLoadMore = React.useCallback(async () => {
    if (!nextCursor || loadingMore) return;
    setLoadingMore(true);
    setError(null);

    try {
      const params = new URLSearchParams({ limit: String(PAGE_SIZE) });
      if (nextCursor) params.set('cursor', nextCursor);

      const response = await fetch(`/api/notifications/list?${params.toString()}`);
      if (!response.ok) throw new Error('Failed to load more notifications.');

      const json = await response.json();
      const payload = NotificationListResponseSchema.parse(json);

      setItems((prev) => [...prev, ...payload.items]);
      setNextCursor(payload.nextCursor);
    } catch (err) {
      console.error('[notifications] load more error', err);
      setError('Unable to load more notifications.');
    } finally {
      setLoadingMore(false);
    }
  }, [loadingMore, nextCursor]);

  const handleMarkAsRead = React.useCallback(async (notificationId: string) => {
    try {
      // Optimistic update
      setItems(prev => prev.map(item => 
        item.id === notificationId ? { ...item, read: true } : item
      ));

      const response = await fetch(`/api/notifications/${notificationId}`, {
        method: 'PATCH',
      });

      if (!response.ok) {
        // Revert optimistic update on error
        setItems(prev => prev.map(item => 
          item.id === notificationId ? { ...item, read: false } : item
        ));
        throw new Error('Failed to mark as read');
      }
    } catch (err) {
      console.error('[notifications] mark as read error', err);
      setError('Failed to mark notification as read');
    }
  }, []);

  const handleMarkAllAsRead = React.useCallback(async () => {
    const unreadIds = items.filter(item => !item.read).map(item => item.id);
    if (unreadIds.length === 0) return;

    try {
      // Optimistic update
      setItems(prev => prev.map(item => ({ ...item, read: true })));

      // Mark each notification as read individually
      await Promise.all(
        unreadIds.map(id => 
          fetch(`/api/notifications/${id}`, { method: 'PATCH' })
        )
      );
    } catch (err) {
      console.error('[notifications] mark all as read error', err);
      setError('Failed to mark all as read');
      // TODO: Revert optimistic update on error (would need to refetch)
    }
  }, [items]);

  const hasNotifications = items.length > 0;
  const hasUnread = items.some(item => !item.read);

  return (
    <>
      <Head>
        <title>Notifications | GramorX</title>
      </Head>
      <Container className="mx-auto max-w-4xl space-y-8 py-10">
        <header className="space-y-3">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-caption uppercase tracking-[0.2em] text-muted-foreground">Inbox</p>
              <h1 className="font-slab text-h2 text-foreground">Notifications</h1>
            </div>
            {hasUnread && (
              <Button 
                onClick={handleMarkAllAsRead} 
                variant="soft" 
                size="sm"
              >
                Mark all as read
              </Button>
            )}
          </div>
          <p className="text-body text-muted-foreground">
            See announcements, study nudges, and progress updates across your GramorX workspace.
          </p>
          <div className="flex flex-wrap gap-3">
            <Button href="/settings/notifications" variant="soft" tone="info" size="sm">
              Manage preferences
            </Button>
            <Button href="/dashboard" variant="outline" size="sm">
              Back to dashboard
            </Button>
          </div>
        </header>

        {error && (
          <Alert variant="error" title="Something went wrong" className="max-w-2xl" role="alert">
            {error}
          </Alert>
        )}

        <section aria-live="polite" className="space-y-6">
          {hasNotifications ? (
            <ul className="divide-y divide-border rounded-2xl border border-border bg-card/50">
              {items.map((notification) => {
                const formatted = formatTimestamp(notification.createdAt);
                const unreadBadge = notification.read ? null : (
                  <span className="inline-flex items-center rounded-full bg-electricBlue/15 px-2 py-0.5 text-[11px] font-semibold uppercase tracking-wide text-electricBlue">
                    New
                  </span>
                );

                const content = (
                  <article className="flex flex-col gap-1 py-4">
                    <div className="flex items-start justify-between gap-3">
                      <h2 className="text-small font-semibold text-foreground">{notification.message}</h2>
                      <div className="flex items-center gap-2">
                        {unreadBadge}
                        {!notification.read && (
                          <button
                            onClick={() => handleMarkAsRead(notification.id)}
                            className="text-xs text-muted-foreground hover:text-foreground"
                            title="Mark as read"
                          >
                            âœ“
                          </button>
                        )}
                      </div>
                    </div>
                    <p className="text-caption text-muted-foreground">{formatted}</p>
                  </article>
                );

                return (
                  <li key={notification.id} className="px-5 hover:bg-muted/50 transition-colors">
                    {notification.url ? (
                      <Link
                        href={notification.url}
                        className="block focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background"
                        onClick={() => !notification.read && handleMarkAsRead(notification.id)}
                      >
                        {content}
                      </Link>
                    ) : (
                      <div onClick={() => !notification.read && handleMarkAsRead(notification.id)}>
                        {content}
                      </div>
                    )}
                  </li>
                );
              })}
            </ul>
          ) : (
            <div className="rounded-2xl border border-dashed border-border/70 bg-card/40 p-8 text-center">
              <h2 className="font-slab text-h4 text-foreground">You&apos;re all caught up</h2>
              <p className="mt-2 text-small text-muted-foreground">
                We&apos;ll drop a notification here when there&apos;s something newâ€”like streak milestones, study reminders, or
                payment updates.
              </p>
              <div className="mt-6 flex justify-center">
                <Button href="/learning" size="sm" variant="primary">
                  Explore practice modules
                </Button>
              </div>
            </div>
          )}

          {nextCursor && (
            <div className="flex justify-center">
              <Button onClick={handleLoadMore} disabled={loadingMore} variant="ghost" size="sm">
                {loadingMore ? 'Loadingâ€¦' : 'Load older notifications'}
              </Button>
            </div>
          )}
        </section>
      </Container>
    </>
  );
};

export const getServerSideProps: GetServerSideProps<NotificationsPageProps> = async (ctx) => {
  const supabase = createSupabaseServerClient({ req: ctx.req, res: ctx.res });
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    const next = encodeURIComponent(ctx.resolvedUrl ?? '/notifications');
    return {
      redirect: {
        destination: `/login?next=${next}`,
        permanent: false,
      },
    };
  }

  const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://gramorx.com';
  const limitPlusOne = PAGE_SIZE + 1;

  const { data, error } = await supabase
    .from('notifications')
    .select('id, message, url, read, created_at')
    .eq('user_id', user.id)
    .order('created_at', { ascending: false })
    .limit(limitPlusOne);

  if (error) {
    return {
      props: {
        initial: EMPTY_PAYLOAD,
        loadError: error.message,
      },
    };
  }

  const notifications = (data ?? []).map((row) => ({
    id: row.id,
    message: row.message ?? 'Notification',
    url:
      row.url && row.url.trim() !== ''
        ? row.url.startsWith('http')
          ? row.url
          : `${baseUrl}${row.url}` // relative -> absolute
        : null,
    read: Boolean(row.read),
    createdAt:
      row.created_at instanceof Date
        ? row.created_at.toISOString()
        : typeof row.created_at === 'string' && !isNaN(Date.parse(row.created_at))
        ? new Date(row.created_at).toISOString()
        : new Date().toISOString(),
  }));

  const items = notifications.slice(0, PAGE_SIZE);
  const hasMore = notifications.length > PAGE_SIZE;
  const nextCursor = hasMore ? items[items.length - 1]?.createdAt ?? null : null;

  // REMOVED: Automatic mark-as-read in getServerSideProps
  // This is now handled explicitly by user actions

  const initial = NotificationListResponseSchema.parse({
    items,
    nextCursor,
    unreadCount: items.filter(item => !item.read).length,
  });

  return {
    props: {
      initial,
      loadError: null,
    },
  };
};

export default NotificationsPage;




============================================================
FILE #44
PATH: pages/_app.tsx
============================================================
// pages/_app.tsx
import type { AppProps } from 'next/app';
import { useEffect, useMemo, useRef, useState, useCallback } from 'react';
import dynamic from 'next/dynamic';
import { useRouter } from 'next/router';
import { ThemeProvider } from 'next-themes';
import type { AuthChangeEvent, Session, User as SupabaseUser } from '@supabase/supabase-js';
import { Poppins, Roboto_Slab } from 'next/font/google';

import '@/styles/tokens.css';
import '@/styles/semantic.css';
import '@/styles/globals.css';
import '@/styles/themes/index.css';

import 'aos/dist/aos.css';
import { AnimationProvider } from '@/components/providers/AnimationProvider';

import { ToastProvider } from '@/components/design-system/Toaster';
import { NotificationProvider } from '@/components/notifications/NotificationProvider';
import { supabaseBrowser as supabaseClientSource } from '@/lib/supabaseBrowser';
import { env } from '@/lib/env';
import { LocaleProvider, useLocale } from '@/lib/locale';
import { initIdleTimeout } from '@/utils/idleTimeout';
import useRouteGuard from '@/hooks/useRouteGuard';
import { destinationByRole } from '@/lib/routeAccess';
import { refreshClientFlags, flagsHydratedRef } from '@/lib/flags/refresh';
import { InstalledAppProvider } from '@/hooks/useInstalledApp';

import { PremiumThemeProvider } from '@/premium-ui/theme/PremiumThemeProvider';
import AppLayoutManager from '@/components/layouts/AppLayoutManager';

import { UserProvider, useUserContext } from '@/context/UserContext';
import { OrgProvider } from '@/lib/orgs/context';
import { HighContrastProvider } from '@/context/HighContrastContext';

import { loadTranslations } from '@/lib/i18n';
import type { SupportedLocale } from '@/lib/i18n/config';
import type { SubscriptionTier } from '@/lib/navigation/types';
import { getRouteConfig, isAttemptPath } from '@/lib/routes/routeLayoutMap';

import { Container } from '@/components/design-system/Container';
import { PlanNavCta } from '@/components/layouts/PlanNavCta';

const PricingReasonBanner = dynamic(
  () => import('@/components/paywall/PricingReasonBanner'),
  { ssr: false }
);

// ---- Safe Supabase getter (works for both factory or instance exports)
function getSupa() {
  const v: any = supabaseClientSource as any;
  return typeof v === 'function' ? v() : v;
}

const poppins = Poppins({
  subsets: ['latin'],
  weight: ['400', '500', '600', '700'],
  display: 'swap',
  variable: '--font-sans',
});
const slab = Roboto_Slab({
  subsets: ['latin'],
  weight: ['400', '600', '700'],
  display: 'swap',
  variable: '--font-display',
});

const IS_CI = process.env.NEXT_PUBLIC_CI === 'true';

function GuardSkeleton() {
  return (
    <div className="grid min-h-[100dvh] place-items-center">
      <div className="h-6 w-40 animate-pulse rounded bg-border" />
    </div>
  );
}

// ---------- Route type helpers ----------
const isAuthPage = (pathname: string) =>
  /^\/(login|signup|register)(\/|$)/.test(pathname) ||
  /^\/auth\/(login|signup|register|mfa|verify)(\/|$)/.test(pathname) ||
  pathname === '/forgot-password';

const isPremiumRoomRoute = (pathname: string) =>
  pathname.startsWith('/premium/') && !pathname.startsWith('/premium-pin');

// Attempts only (used by older code that referenced â€œflowâ€)
const isMockTestsFlowRoute = (pathname: string) => {
  const isMockAttempt = /^\/mock\/[^/]+$/.test(pathname);
  const isWritingMockAttempt = /^\/writing\/mock\/[^/]+$/.test(pathname);
  return isMockAttempt || isWritingMockAttempt;
};

// ---------- Enhanced route loading ----------
const ROUTE_LOADING_DELAY_MS = 260;
const ROUTE_LOADING_MIN_VISIBLE_MS = 400;
const ROUTE_LOADING_FALLBACK_MS = 12000;

function useRouteLoading() {
  const router = useRouter();
  const [isRouteLoading, setIsRouteLoading] = useState(false);
  const routeLoadingTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const routeLoadingFallbackRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const routeLoadingHideDelayRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const pendingPathRef = useRef<string | null>(null);
  const visibleSinceRef = useRef<number | null>(null);

  useEffect(() => {
    const toComparablePath = (value: string) => {
      if (!value) return '/';
      const withoutOrigin = value.replace(/^https?:\/\/[^/]+/, '');
      const withoutHash = withoutOrigin.split('#')[0] ?? '';
      const withoutQuery = withoutHash.split('?')[0] ?? '';
      return (withoutQuery || '/').replace(/\/+$/, '') || '/';
    };

    const hasMeaningfulPathChange = (nextUrl: string) => {
      const nextPath = toComparablePath(nextUrl);
      const currentPath = toComparablePath(router.asPath);
      return nextPath !== currentPath;
    };

    const clearTimers = () => {
      if (routeLoadingTimeoutRef.current) {
        clearTimeout(routeLoadingTimeoutRef.current);
        routeLoadingTimeoutRef.current = null;
      }
      if (routeLoadingFallbackRef.current) {
        clearTimeout(routeLoadingFallbackRef.current);
        routeLoadingFallbackRef.current = null;
      }
      if (routeLoadingHideDelayRef.current) {
        clearTimeout(routeLoadingHideDelayRef.current);
        routeLoadingHideDelayRef.current = null;
      }
    };

    const startLoading = (url: string, options: { shallow?: boolean } = {}) => {
      if (options.shallow) return;
      if (!hasMeaningfulPathChange(url)) {
        pendingPathRef.current = null;
        clearTimers();
        return;
      }
      pendingPathRef.current = toComparablePath(url);
      clearTimers();
      routeLoadingTimeoutRef.current = setTimeout(() => {
        visibleSinceRef.current = Date.now();
        setIsRouteLoading(true);
        routeLoadingFallbackRef.current = setTimeout(() => {
          pendingPathRef.current = null;
          visibleSinceRef.current = null;
          setIsRouteLoading(false);
        }, ROUTE_LOADING_FALLBACK_MS);
      }, ROUTE_LOADING_DELAY_MS);
    };

    const stopLoading = (url?: string | null) => {
      const finalize = () => {
        pendingPathRef.current = null;
        clearTimers();
        visibleSinceRef.current = null;
        setIsRouteLoading(false);
      };

      if (pendingPathRef.current && url) {
        const normalizedUrl = toComparablePath(url);
        if (normalizedUrl !== pendingPathRef.current) {
          return;
        }
      }

      const ensureMinimumVisibility = () => {
        if (visibleSinceRef.current == null) {
          finalize();
          return;
        }

        const elapsed = Date.now() - visibleSinceRef.current;
        if (elapsed >= ROUTE_LOADING_MIN_VISIBLE_MS) {
          finalize();
          return;
        }

        const remaining = ROUTE_LOADING_MIN_VISIBLE_MS - elapsed;
        routeLoadingHideDelayRef.current = setTimeout(() => {
          visibleSinceRef.current = null;
          finalize();
        }, remaining);
      };

      if (typeof window !== 'undefined') {
        requestAnimationFrame(() =>
          requestAnimationFrame(ensureMinimumVisibility)
        );
        return;
      }

      ensureMinimumVisibility();
    };

    const handleRouteError = (_err: unknown, url: string) => stopLoading(url);

    const handleBeforeHistoryChange = (
      url: string | { pathname?: string | null } = '',
      opts: { shallow?: boolean } = {}
    ) => {
      const rawUrl = typeof url === 'string' ? url : url?.pathname ?? '';

      if (opts.shallow) {
        if (!pendingPathRef.current) {
          stopLoading();
        }
        return;
      }

      if (!hasMeaningfulPathChange(rawUrl)) {
        pendingPathRef.current = null;
        stopLoading();
        return;
      }

      pendingPathRef.current = toComparablePath(rawUrl);
    };

    router.events.on('routeChangeStart', startLoading as any);
    router.events.on('beforeHistoryChange', handleBeforeHistoryChange as any);
    router.events.on('routeChangeComplete', stopLoading as any);
    router.events.on('routeChangeError', handleRouteError as any);

    const handleVisibilityChange = () => {
      if (document.visibilityState === 'hidden') stopLoading();
    };
    const handlePageHide = () => stopLoading();

    document.addEventListener('visibilitychange', handleVisibilityChange);
    window.addEventListener('pagehide', handlePageHide);

    return () => {
      router.events.off('routeChangeStart', startLoading as any);
      router.events.off('beforeHistoryChange', handleBeforeHistoryChange as any);
      router.events.off('routeChangeComplete', stopLoading as any);
      router.events.off('routeChangeError', handleRouteError as any);
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      window.removeEventListener('pagehide', handlePageHide);
      clearTimers();
    };
  }, [router]);

  useEffect(() => {
    if (routeLoadingFallbackRef.current) {
      clearTimeout(routeLoadingFallbackRef.current);
      routeLoadingFallbackRef.current = null;
    }
    pendingPathRef.current = null;
    setIsRouteLoading(false);
  }, [router.asPath]);

  return isRouteLoading;
}

// ---------- Auth bridge ----------
function useAuthBridge() {
  const router = useRouter();
  const syncingRef = useRef(false);
  const lastBridgeKeyRef = useRef<string | null>(null);
  const subscribedRef = useRef(false);

  const bridgeSession = useCallback(
    async (event: AuthChangeEvent, sessionNow: Session | null) => {
      const shouldPost =
        event === 'SIGNED_IN' ||
        event === 'SIGNED_OUT' ||
        event === 'TOKEN_REFRESHED';
      if (!shouldPost) return;

      if (event !== 'SIGNED_OUT' && !sessionNow?.access_token) return;

      const token = sessionNow?.access_token ?? '';
      const dedupeKey = `${event}:${token}`;

      if (event !== 'SIGNED_OUT' && lastBridgeKeyRef.current === dedupeKey) return;
      lastBridgeKeyRef.current = event === 'SIGNED_OUT' ? null : dedupeKey;

      try {
        await fetch('/api/auth/set-session', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'same-origin',
          body: JSON.stringify({ event, session: sessionNow }),
        });
      } catch (err) {
        console.error('Failed to bridge auth session:', err);
      }
    },
    []
  );

  useEffect(() => {
    if (IS_CI) return;

    if (typeof window !== 'undefined') {
      if ((window as any).__GX_AUTH_BRIDGE_ACTIVE) return;
      (window as any).__GX_AUTH_BRIDGE_ACTIVE = true;
    }

    let cancelled = false;

    (async () => {
      const supa = getSupa();

      syncingRef.current = true;
      const {
        data: { session },
      } = await supa.auth.getSession();

      if (!cancelled) {
        if (session) {
          await bridgeSession('SIGNED_IN', session);
        } else {
          await bridgeSession('SIGNED_OUT', null);
        }

        if (!flagsHydratedRef.current) {
          void refreshClientFlags();
        }

        if (session?.user && isAuthPage(router.pathname)) {
          const pathname = router.pathname;
          const isSpecialAuthHandler =
            pathname === '/auth/callback' ||
            pathname === '/auth/confirm' ||
            pathname === '/auth/verify';

          if (!isSpecialAuthHandler) {
            const url = new URL(window.location.href);
            const next = url.searchParams.get('next');
            const target =
              next && next.startsWith('/')
                ? next
                : destinationByRole(session.user) ?? '/';

            router.replace(target);
          }
        }
      }

      syncingRef.current = false;
    })();

    if (!subscribedRef.current) {
      const supa = getSupa();

      const {
        data: { subscription },
      } = supa.auth.onAuthStateChange((event, sessionNow) => {
        (async () => {
          if (cancelled) return;

          await bridgeSession(event, sessionNow);

          if (event === 'SIGNED_IN' && sessionNow?.user) {
            const pathname = router.pathname;
            const isSpecialAuthHandler =
              pathname === '/auth/callback' ||
              pathname === '/auth/confirm' ||
              pathname === '/auth/verify';

            if (!isSpecialAuthHandler) {
              const url = new URL(window.location.href);
              const next = url.searchParams.get('next');

              if (next && next.startsWith('/')) {
                router.replace(next);
              } else if (isAuthPage(pathname)) {
                router.replace(destinationByRole(sessionNow.user));
              }
            }
          }

          if (event === 'SIGNED_OUT') {
            if (!['/login', '/signup', '/forgot-password'].includes(router.pathname)) {
              router.replace('/login');
            }
          }
        })();
      });

      subscribedRef.current = true;

      return () => {
        cancelled = true;
        (subscription as any)?.unsubscribe?.();
        subscribedRef.current = false;
        if (typeof window !== 'undefined') {
          (window as any).__GX_AUTH_BRIDGE_ACTIVE = false;
        }
      };
    }
  }, [router, bridgeSession]);
}

// ---------- Route configuration ----------
function useRouteConfiguration(pathname: string) {
  const { user } = useUserContext();

  return useMemo(() => {
    const routeConfig = getRouteConfig(pathname);
    const derivedIsAuth = routeConfig.layout === 'auth' || isAuthPage(pathname);

    const isAttempt = isAttemptPath(pathname);

    const isNoChromeRoute =
      derivedIsAuth ||
      routeConfig.layout === 'proctoring' ||
      pathname.startsWith('/premium') ||
      /\/focus-mode(\/|$)/.test(pathname) ||
      routeConfig.showChrome === false ||
      isAttempt ||
      isMockTestsFlowRoute(pathname);

    const showLayout = !pathname.startsWith('/premium') && !isNoChromeRoute;

    return {
      isAuthPage: derivedIsAuth,
      isProctoringRoute: routeConfig.layout === 'proctoring',
      showLayout,
      forceLayoutOnAuthPage: derivedIsAuth && !!user,
      isAdminRoute: routeConfig.layout === 'admin',
      isInstitutionsRoute: routeConfig.layout === 'institutions',
      isDashboardRoute:
        routeConfig.layout === 'dashboard' ||
        routeConfig.layout === 'profile' ||
        routeConfig.layout === 'billing' ||
        routeConfig.layout === 'analytics',
      isMarketplaceRoute: routeConfig.layout === 'marketplace',
      isLearningRoute:
        routeConfig.layout === 'learning' || routeConfig.layout === 'resources',
      isCommunityRoute:
        routeConfig.layout === 'community' || routeConfig.layout === 'communication',
      isReportsRoute: routeConfig.layout === 'reports',
      isMarketingRoute:
        routeConfig.layout === 'marketing' || routeConfig.layout === 'support',
      needPremium: pathname.startsWith('/premium'),
      isPremiumRoute: isPremiumRoomRoute(pathname),
      routeConfig,
    };
  }, [pathname, user]);
}

// ---------- Access checks ----------
function useRouteAccessCheck(pathname: string, role?: string | null) {
  const router = useRouter();

  useEffect(() => {
    const config = getRouteConfig(pathname);
    if (!config.requiresAuth) return;

    // If we don't know the role yet, don't instantly redirect â€“ let UserContext load.
    if (role === undefined) return;

    if (!role) {
      router.replace('/login');
      return;
    }

    if (config.allowedRoles && role && !config.allowedRoles.includes(role)) {
      router.replace('/restricted');
    }
  }, [pathname, role, router]);
}

function InnerApp({ Component, pageProps }: AppProps) {
  const router = useRouter();
  const pathname = router.pathname;
  const { locale: activeLocale } = useLocale();

  const isRouteLoading = useRouteLoading();
  useAuthBridge();

  useEffect(() => {
    void loadTranslations(activeLocale as SupportedLocale);
  }, [activeLocale]);

  useEffect(() => {
    const logRoute = (url: string) => {
      if (!url) return;
    };
    logRoute(router.asPath);
    const handleRouteChange = (url: string) => logRoute(url);
    router.events.on('routeChangeComplete', handleRouteChange);
    return () => router.events.off('routeChangeComplete', handleRouteChange);
  }, [router]);

  const { user, role, isTeacherApproved } = useUserContext() as {
    user: SupabaseUser | null;
    role?: string | null;
    isTeacherApproved?: boolean | null;
  };
  const [subscriptionTier, setSubscriptionTier] = useState<SubscriptionTier>('free');

  useEffect(() => {
    const metadata = (user?.user_metadata ?? {}) as { tier?: SubscriptionTier | null };
    const appMeta = (user?.app_metadata ?? {}) as { tier?: SubscriptionTier | null };
    const nextTier = metadata.tier ?? appMeta.tier ?? 'free';
    setSubscriptionTier(nextTier);
  }, [user]);

  useEffect(() => {
    const handleTierUpdated = (event: Event) => {
      const detail = (event as CustomEvent<{ tier?: SubscriptionTier }>).detail;
      if (detail?.tier) setSubscriptionTier(detail.tier);
    };
    window.addEventListener('subscription:tier-updated', handleTierUpdated as EventListener);
    return () =>
      window.removeEventListener('subscription:tier-updated', handleTierUpdated as EventListener);
  }, []);

  const routeConfiguration = useRouteConfiguration(pathname);
  const forceLayoutOnAuthPage = routeConfiguration.isAuthPage && !!user;

  useRouteAccessCheck(pathname, role);

  useEffect(() => {
    if (!role) return;
    if (role === 'teacher') {
      const onTeacherArea =
        pathname.startsWith('/teacher') || routeConfiguration.isAuthPage;
      if (!onTeacherArea) router.replace('/teacher');
    }
  }, [role, pathname, routeConfiguration.isAuthPage, router]);

  const idleMinutes = useMemo(() => {
    try {
      const minutes =
        env?.NEXT_PUBLIC_IDLE_TIMEOUT_MINUTES ??
        process.env.NEXT_PUBLIC_IDLE_TIMEOUT_MINUTES ??
        '30';
      return Number(minutes) || 30;
    } catch {
      return 30;
    }
  }, []);

  useEffect(() => {
    if (IS_CI) return;
    if (typeof initIdleTimeout !== 'function') return;
    try {
      const cleanup = initIdleTimeout(idleMinutes);
      return cleanup;
    } catch {
      // noop
    }
  }, [idleMinutes]);

  const { isChecking } = useRouteGuard();
  if (isChecking) return <GuardSkeleton />;

  const basePage =
    routeConfiguration.needPremium || routeConfiguration.isPremiumRoute ? (
      <PremiumThemeProvider>
        <Component {...pageProps} key={router.asPath} />
      </PremiumThemeProvider>
    ) : (
      <Component {...pageProps} key={router.asPath} />
    );

  // Show global AppHeader-style nav for marketing & pricing routes
  const shouldShowGlobalHeader =
    routeConfiguration.isMarketingRoute ||
    pathname === '/' ||
    pathname === '/pricing' ||
    pathname.startsWith('/pricing/');

  const isPricingRoute =
    pathname === '/pricing' || pathname === '/pricing/overview';

  return (
    <ThemeProvider attribute="class" defaultTheme="light" enableSystem={false}>
      <HighContrastProvider>
        <div
          className={`${poppins.className} ${slab.className} min-h-screen min-h-[100dvh] bg-background text-foreground antialiased`}
        >
          <AnimationProvider>
            <AppLayoutManager
              isAuthPage={routeConfiguration.isAuthPage}
              isProctoringRoute={routeConfiguration.isProctoringRoute}
              showLayout={routeConfiguration.showLayout}
              forceLayoutOnAuthPage={forceLayoutOnAuthPage}
              isAdminRoute={routeConfiguration.isAdminRoute}
              isInstitutionsRoute={routeConfiguration.isInstitutionsRoute}
              isDashboardRoute={routeConfiguration.isDashboardRoute}
              isMarketplaceRoute={routeConfiguration.isMarketplaceRoute}
              isLearningRoute={routeConfiguration.isLearningRoute}
              isCommunityRoute={routeConfiguration.isCommunityRoute}
              isReportsRoute={routeConfiguration.isReportsRoute}
              isMarketingRoute={routeConfiguration.isMarketingRoute}
              isPremiumRoute={routeConfiguration.isPremiumRoute}
              subscriptionTier={subscriptionTier}
              isRouteLoading={isRouteLoading}
              role={role}
              isTeacherApproved={isTeacherApproved}
              guardFallback={() => <GuardSkeleton />}
            >
              {shouldShowGlobalHeader ? (
                <>
                  <header className="border-b border-subtle bg-background/80 backdrop-blur">
                    <Container className="flex h-14 items-center justify-between">
                      <div className="text-sm font-semibold">GramorX</div>
                      <PlanNavCta />
                    </Container>
                  </header>
                  {isPricingRoute ? <PricingReasonBanner /> : null}
                  {basePage}
                </>
              ) : (
                <>
                  {isPricingRoute ? <PricingReasonBanner /> : null}
                  {basePage}
                </>
              )}
            </AppLayoutManager>
          </AnimationProvider>
        </div>
      </HighContrastProvider>
    </ThemeProvider>
  );
}

export default function App(props: AppProps) {
  return (
    <LocaleProvider initialLocale="en">
      <ToastProvider>
        <NotificationProvider>
          <UserProvider>
            <OrgProvider>
              <InstalledAppProvider>
                <InnerApp {...props} />
              </InstalledAppProvider>
            </OrgProvider>
          </UserProvider>
        </NotificationProvider>
      </ToastProvider>
    </LocaleProvider>
  );
}





============================================================
FILE #45
PATH: pages/api/notifications/enqueue.ts
============================================================
import type { NextApiRequest, NextApiResponse } from 'next';
import { DateTime } from 'luxon';
import { supabaseService } from '@/lib/supabaseServer';
import { EnqueueBody } from '@/types/notifications';
import { enqueueEvent } from '@/lib/notify';

const DEFAULT_RATE_LIMIT = 5;

function resolveSecret(): string | null {
  return process.env.NOTIFICATIONS_ENQUEUE_SECRET ?? null;
}

function resolveLimit(): number {
  const raw = process.env.NOTIFICATIONS_ENQUEUE_LIMIT;
  const parsed = raw ? Number(raw) : NaN;
  if (Number.isFinite(parsed) && parsed > 0) {
    return parsed;
  }
  return DEFAULT_RATE_LIMIT;
}

function authorised(req: NextApiRequest): boolean {
  const secret = resolveSecret();
  if (!secret) {
    return process.env.NODE_ENV !== 'production';
  }

  const header = req.headers['x-notifications-secret'] ?? req.headers['x-api-key'] ?? null;
  if (!header) return false;
  if (Array.isArray(header)) {
    return header.some((value) => value === secret);
  }
  return header === secret;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    res.setHeader('Allow', 'POST');
    return res.status(405).end('Method Not Allowed');
  }

  if (!authorised(req)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const parsed = EnqueueBody.safeParse(req.body);
  if (!parsed.success) {
    return res.status(400).json({ 
      error: 'Invalid payload', 
      details: parsed.error.flatten() 
    });
  }

  return enqueueEvent(req, res, parsed.data);
}




============================================================
FILE #46
PATH: pages/api/notifications/list.ts
============================================================
import type { NextApiRequest, NextApiResponse } from 'next';
import { createSupabaseServerClient } from '@/lib/supabaseServer';
import {
  NotificationListQuerySchema,
  NotificationListResponseSchema,
} from '@/lib/schemas/notifications';
import { NotificationService } from '@/lib/notificationService';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'GET') {
    res.setHeader('Allow', 'GET');
    return res.status(405).end('Method Not Allowed');
  }

  const supabase = createSupabaseServerClient({ req });
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const parseResult = NotificationListQuerySchema.safeParse(req.query);
  if (!parseResult.success) {
    return res.status(400).json({ error: 'Invalid query parameters' });
  }

  const { cursor, limit } = parseResult.data;
  const service = new NotificationService(supabase);

  try {
    // Validate cursor format
    if (cursor) {
      const cursorDate = new Date(cursor);
      if (isNaN(cursorDate.getTime())) {
        return res.status(400).json({ error: 'Invalid cursor format' });
      }
    }

    const result = await service.listNotifications(user.id, { cursor, limit });
    const payload = NotificationListResponseSchema.parse(result);

    return res.status(200).json(payload);
  } catch (error) {
    console.error('Error in notifications list API:', error);
    const message = error instanceof Error ? error.message : 'Failed to load notifications';
    return res.status(500).json({ error: message });
  }
}




============================================================
FILE #47
PATH: pages/api/notifications/index.ts
============================================================
// pages/api/notifications/index.ts
import { randomUUID } from 'crypto';
import type { NextApiRequest, NextApiResponse } from 'next';
import { createSupabaseServerClient } from '@/lib/supabaseServer';

type RawNotification = Record<string, any>;

type ApiNotification = {
  id: string;
  message: string;
  url: string | null;
  read: boolean;
  created_at: string;
};

const FALLBACK_MESSAGE = 'Notification';

function toBoolean(value: unknown, fallback = false): boolean {
  if (typeof value === 'boolean') return value;
  if (typeof value === 'number') return value !== 0;
  if (typeof value === 'string') return value === 'true';
  return fallback;
}

function normalizeUrl(value: unknown): string | null {
  if (typeof value !== 'string') return null;
  const trimmed = value.trim();
  return trimmed.length ? trimmed : null;
}

function parseTimestamp(value: unknown): string {
  const date = value instanceof Date ? value : new Date(value as any);
  return isNaN(date.getTime()) ? new Date().toISOString() : date.toISOString();
}

function mapRow(row: RawNotification): ApiNotification {
  const idValue = row.id ?? row.notification_id ?? row.uuid ?? randomUUID();
  const message =
    row.message ??
    row.title ??
    row.subject ??
    row.body ??
    row.details ??
    row.data?.message ??
    FALLBACK_MESSAGE;

  const url =
    normalizeUrl(row.url) ??
    normalizeUrl(row.link) ??
    normalizeUrl(row.data?.url) ??
    normalizeUrl(row.data?.link) ??
    null;

  const read = toBoolean(row.read, toBoolean(row.is_read));

  return {
    id: typeof idValue === 'string' ? idValue : String(idValue),
    message,
    url,
    read,
    created_at: parseTimestamp(row.created_at ?? row.inserted_at ?? Date.now()),
  };
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'GET') {
    res.setHeader('Allow', 'GET');
    return res.status(405).json({ error: 'method_not_allowed' });
  }

  try {
    const supabase = createSupabaseServerClient({ req, res });
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return res.status(401).json({ error: 'unauthorized' });
    }

    const { data, error } = await supabase
      .from<RawNotification>('notifications')
      .select('*')
      .eq('user_id', user.id)
      .order('created_at', { ascending: false })
      .limit(50);

    if (error) {
      console.error('[notifications] supabase error', error);
      return res.status(500).json({ error: error.message ?? 'db_error' });
    }

    const notifications = (data ?? []).map(mapRow);

    return res.status(200).json({ notifications });
  } catch (err: any) {
    console.error('[notifications] unhandled error', err);
    return res.status(500).json({ error: err?.message ?? 'unexpected' });
  }
}





============================================================
FILE #48
PATH: lib/env.ts
============================================================
// lib/env.ts
import { z } from 'zod';

const envSchema = z.object({
  // Public (client) vars
  NEXT_PUBLIC_SUPABASE_URL: z.string().url(),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string().min(1),
  NEXT_PUBLIC_BASE_URL: z.string().url().optional(),
  NEXT_PUBLIC_IDLE_TIMEOUT_MINUTES: z.coerce.number().default(30),
  NEXT_PUBLIC_DEBUG: z.string().optional(),
  NEXT_PUBLIC_SITE_URL: z.string().url().optional(),

  // Feature flags (client)
  NEXT_PUBLIC_FEATURE_TRIAL: z.string().optional(),
  NEXT_PUBLIC_FEATURE_PAYWALL: z.string().optional(),
  NEXT_PUBLIC_FEATURE_REFERRAL: z.string().optional(),
  NEXT_PUBLIC_FEATURE_PARTNER: z.string().optional(),
  NEXT_PUBLIC_FEATURE_PREDICTOR: z.string().optional(),
  NEXT_PUBLIC_FEATURE_CHALLENGE: z.string().optional(),
  NEXT_PUBLIC_FEATURE_AI_COACH: z.string().optional(),
  NEXT_PUBLIC_FEATURE_STUDY_BUDDY: z.string().optional(),
  NEXT_PUBLIC_FEATURE_MISTAKES_BOOK: z.string().optional(),
  NEXT_PUBLIC_FEATURE_WHATSAPP_TASKS: z.string().optional(),
  NEXT_PUBLIC_FEATURE_FLOATING_WIDGET: z.string().optional(),
  NEXT_PUBLIC_FEATURE_COACH: z.string().optional(),
  NEXT_PUBLIC_FEATURE_NOTIFICATIONS: z.string().optional(),
  NEXT_PUBLIC_FEATURE_QUICK_TEN: z.string().optional(),
  NEXT_PUBLIC_FEATURE_AI_ASSIST: z.string().optional(),
  NEXT_PUBLIC_PUSH_PUBLIC_KEY: z.string().optional(),

  // Optional analytics/monitoring
  NEXT_PUBLIC_GA4_ID: z.string().optional(),
  NEXT_PUBLIC_META_PIXEL_ID: z.string().optional(),
  NEXT_PUBLIC_SENTRY_DSN: z.string().optional(),

  // Optional client-side toggles/util
  NEXT_PUBLIC_TWILIO_BYPASS: z.string().optional(),
  NEXT_PUBLIC_PAYMENTS_PROVIDER: z
    .enum(['none', 'stripe', 'easypaisa', 'jazzcash', 'safepay', 'crypto'])
    .optional(),

  // Server-only vars (required in prod)
  SUPABASE_URL: z.string().url(),
  SUPABASE_SERVICE_KEY: z.string().min(1),
  SUPABASE_SERVICE_ROLE_KEY: z.string().min(1),

  REVIEW_SHARE_SECRET: z.string().optional(),
  REVIEW_SHARE_TTL_HOURS: z.coerce.number().optional(),

  ADMIN_EMAILS: z.string().optional(),

  GOOGLE_GENERATIVE_AI_API_KEY: z.string().optional(),
  GROQ_API_KEY: z.string().optional(),
  GROQ_MODEL: z.string().optional(),
  OPENAI_API_KEY: z.string().optional(),
  OPENAI_MODEL: z.string().optional(),
  GEMINI_API_KEY: z.string().optional(),
  GEMINI_MODEL: z.string().optional(),
  GX_AI_PROVIDER: z.string().optional(),

  RESEND_API_KEY: z.string().optional(),
  RESEND_FROM_EMAIL: z.string().optional(),

  PREMIUM_MASTER_PIN: z.string().optional(),
  PREMIUM_PIN_HASH: z.string().optional(),
  PREMIUM_PIN_SALT: z.string().optional(),
  PREMIUM_PIN_RATE: z.coerce.number().optional(),
  PREMIUM_PIN_WINDOW_SEC: z.coerce.number().optional(),

  STRIPE_SECRET_KEY: z.string().optional(),
  STRIPE_WEBHOOK_SECRET: z.string().optional(),
  STRIPE_PRICE_STARTER_MONTHLY: z.string().optional(),
  STRIPE_PRICE_STARTER_ANNUAL: z.string().optional(),
  STRIPE_PRICE_BOOSTER_MONTHLY: z.string().optional(),
  STRIPE_PRICE_BOOSTER_ANNUAL: z.string().optional(),
  STRIPE_PRICE_MASTER_MONTHLY: z.string().optional(),
  STRIPE_PRICE_MASTER_ANNUAL: z.string().optional(),

  SPEAKING_DAILY_LIMIT: z.coerce.number().optional(),
  SPEAKING_BUCKET: z.string().optional(),
  LIMIT_FREE_SPEAKING: z.coerce.number().optional(),

  TWILIO_ACCOUNT_SID: z.string().min(1),
  TWILIO_AUTH_TOKEN: z.string().min(1),
  TWILIO_VERIFY_SERVICE_SID: z.string().min(1),
  TWILIO_WHATSAPP_FROM: z.string().min(1),
  TWILIO_BYPASS: z.string().optional(),
  WHATSAPP_TASKS_SIGNING_SECRET: z.string().min(1),

  NEXT_PUBLIC_DEV_PAYMENTS: z.string().optional(),
  EASYPASA_MERCHANT_ID: z.string().optional(),
  EASYPASA_SECRET: z.string().optional(),
  JAZZCASH_MERCHANT_ID: z.string().optional(),
  JAZZCASH_INTEGRITY_SALT: z.string().optional(),
  SAFEPAY_PUBLIC_KEY: z.string().optional(),
  SAFEPAY_SECRET_KEY: z.string().optional(),
  SAFEPAY_ENV: z.enum(['sandbox', 'production']).default('sandbox'),
  SAFEPAY_API_BASE_URL: z.string().url().optional(),
  SAFEPAY_CHECKOUT_BASE_URL: z.string().url().optional(),

  LOCAL_ADMIN_TOKEN: z.string().optional(),
  ADMIN_API_TOKEN: z.string().optional(),
  SITE_URL: z.string().url().optional(),
  PAYMENTS_PROVIDER: z.enum(['none', 'stripe', 'easypaisa', 'jazzcash', 'safepay', 'crypto']).optional(),
  PORT: z.coerce.number().optional(),
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
});

const raw = {
  NEXT_PUBLIC_SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL,
  NEXT_PUBLIC_SUPABASE_ANON_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
  NEXT_PUBLIC_BASE_URL: process.env.NEXT_PUBLIC_BASE_URL,
  NEXT_PUBLIC_IDLE_TIMEOUT_MINUTES: process.env.NEXT_PUBLIC_IDLE_TIMEOUT_MINUTES,
  NEXT_PUBLIC_DEBUG: process.env.NEXT_PUBLIC_DEBUG,
  NEXT_PUBLIC_SITE_URL: process.env.NEXT_PUBLIC_SITE_URL,

  NEXT_PUBLIC_FEATURE_TRIAL: process.env.NEXT_PUBLIC_FEATURE_TRIAL,
  NEXT_PUBLIC_FEATURE_PAYWALL: process.env.NEXT_PUBLIC_FEATURE_PAYWALL,
  NEXT_PUBLIC_FEATURE_REFERRAL: process.env.NEXT_PUBLIC_FEATURE_REFERRAL,
  NEXT_PUBLIC_FEATURE_PARTNER: process.env.NEXT_PUBLIC_FEATURE_PARTNER,
  NEXT_PUBLIC_FEATURE_PREDICTOR: process.env.NEXT_PUBLIC_FEATURE_PREDICTOR,
  NEXT_PUBLIC_FEATURE_CHALLENGE: process.env.NEXT_PUBLIC_FEATURE_CHALLENGE,
  NEXT_PUBLIC_FEATURE_AI_COACH: process.env.NEXT_PUBLIC_FEATURE_AI_COACH,
  NEXT_PUBLIC_FEATURE_STUDY_BUDDY: process.env.NEXT_PUBLIC_FEATURE_STUDY_BUDDY,
  NEXT_PUBLIC_FEATURE_MISTAKES_BOOK: process.env.NEXT_PUBLIC_FEATURE_MISTAKES_BOOK,
  NEXT_PUBLIC_FEATURE_WHATSAPP_TASKS: process.env.NEXT_PUBLIC_FEATURE_WHATSAPP_TASKS,
  NEXT_PUBLIC_FEATURE_FLOATING_WIDGET: process.env.NEXT_PUBLIC_FEATURE_FLOATING_WIDGET,
  NEXT_PUBLIC_FEATURE_COACH: process.env.NEXT_PUBLIC_FEATURE_COACH,
  NEXT_PUBLIC_FEATURE_NOTIFICATIONS: process.env.NEXT_PUBLIC_FEATURE_NOTIFICATIONS,
  NEXT_PUBLIC_FEATURE_QUICK_TEN: process.env.NEXT_PUBLIC_FEATURE_QUICK_TEN,
  NEXT_PUBLIC_FEATURE_AI_ASSIST: process.env.NEXT_PUBLIC_FEATURE_AI_ASSIST,
  NEXT_PUBLIC_PUSH_PUBLIC_KEY: process.env.NEXT_PUBLIC_PUSH_PUBLIC_KEY,

  NEXT_PUBLIC_GA4_ID: process.env.NEXT_PUBLIC_GA4_ID,
  NEXT_PUBLIC_META_PIXEL_ID: process.env.NEXT_PUBLIC_META_PIXEL_ID,
  NEXT_PUBLIC_SENTRY_DSN: process.env.NEXT_PUBLIC_SENTRY_DSN,

  NEXT_PUBLIC_TWILIO_BYPASS: process.env.NEXT_PUBLIC_TWILIO_BYPASS,
  NEXT_PUBLIC_PAYMENTS_PROVIDER: process.env.NEXT_PUBLIC_PAYMENTS_PROVIDER,

  SUPABASE_URL: process.env.SUPABASE_URL,
  SUPABASE_SERVICE_KEY: process.env.SUPABASE_SERVICE_KEY,
  SUPABASE_SERVICE_ROLE_KEY: process.env.SUPABASE_SERVICE_ROLE_KEY,

  REVIEW_SHARE_SECRET: process.env.REVIEW_SHARE_SECRET,
  REVIEW_SHARE_TTL_HOURS: process.env.REVIEW_SHARE_TTL_HOURS,

  ADMIN_EMAILS: process.env.ADMIN_EMAILS,

  GOOGLE_GENERATIVE_AI_API_KEY: process.env.GOOGLE_GENERATIVE_AI_API_KEY,
  GROQ_API_KEY: process.env.GROQ_API_KEY,
  GROQ_MODEL: process.env.GROQ_MODEL,
  OPENAI_API_KEY: process.env.OPENAI_API_KEY,
  OPENAI_MODEL: process.env.OPENAI_MODEL,
  GEMINI_API_KEY: process.env.GEMINI_API_KEY,
  GEMINI_MODEL: process.env.GEMINI_MODEL,
  GX_AI_PROVIDER: process.env.GX_AI_PROVIDER,

  RESEND_API_KEY: process.env.RESEND_API_KEY,
  RESEND_FROM_EMAIL: process.env.RESEND_FROM_EMAIL,

  PREMIUM_MASTER_PIN: process.env.PREMIUM_MASTER_PIN,
  PREMIUM_PIN_HASH: process.env.PREMIUM_PIN_HASH,
  PREMIUM_PIN_SALT: process.env.PREMIUM_PIN_SALT,
  PREMIUM_PIN_RATE: process.env.PREMIUM_PIN_RATE,
  PREMIUM_PIN_WINDOW_SEC: process.env.PREMIUM_PIN_WINDOW_SEC,

  STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY,
  STRIPE_WEBHOOK_SECRET: process.env.STRIPE_WEBHOOK_SECRET,
  STRIPE_PRICE_STARTER_MONTHLY: process.env.STRIPE_PRICE_STARTER_MONTHLY,
  STRIPE_PRICE_STARTER_ANNUAL: process.env.STRIPE_PRICE_STARTER_ANNUAL,
  STRIPE_PRICE_BOOSTER_MONTHLY: process.env.STRIPE_PRICE_BOOSTER_MONTHLY,
  STRIPE_PRICE_BOOSTER_ANNUAL: process.env.STRIPE_PRICE_BOOSTER_ANNUAL,
  STRIPE_PRICE_MASTER_MONTHLY: process.env.STRIPE_PRICE_MASTER_MONTHLY,
  STRIPE_PRICE_MASTER_ANNUAL: process.env.STRIPE_PRICE_MASTER_ANNUAL,

  SPEAKING_DAILY_LIMIT: process.env.SPEAKING_DAILY_LIMIT,
  SPEAKING_BUCKET: process.env.SPEAKING_BUCKET,
  LIMIT_FREE_SPEAKING: process.env.LIMIT_FREE_SPEAKING,

  TWILIO_ACCOUNT_SID: process.env.TWILIO_ACCOUNT_SID,
  TWILIO_AUTH_TOKEN: process.env.TWILIO_AUTH_TOKEN,
  TWILIO_VERIFY_SERVICE_SID: process.env.TWILIO_VERIFY_SERVICE_SID,
  TWILIO_WHATSAPP_FROM: process.env.TWILIO_WHATSAPP_FROM,
  TWILIO_BYPASS: process.env.TWILIO_BYPASS,
  WHATSAPP_TASKS_SIGNING_SECRET: process.env.WHATSAPP_TASKS_SIGNING_SECRET,

  NEXT_PUBLIC_DEV_PAYMENTS: process.env.NEXT_PUBLIC_DEV_PAYMENTS,
  EASYPASA_MERCHANT_ID: process.env.EASYPASA_MERCHANT_ID,
  EASYPASA_SECRET: process.env.EASYPASA_SECRET,
  JAZZCASH_MERCHANT_ID: process.env.JAZZCASH_MERCHANT_ID,
  JAZZCASH_INTEGRITY_SALT: process.env.JAZZCASH_INTEGRITY_SALT,
  SAFEPAY_PUBLIC_KEY: process.env.SAFEPAY_PUBLIC_KEY,
  SAFEPAY_SECRET_KEY: process.env.SAFEPAY_SECRET_KEY,
  SAFEPAY_ENV: process.env.SAFEPAY_ENV,
  SAFEPAY_API_BASE_URL: process.env.SAFEPAY_API_BASE_URL,
  SAFEPAY_CHECKOUT_BASE_URL: process.env.SAFEPAY_CHECKOUT_BASE_URL,

  LOCAL_ADMIN_TOKEN: process.env.LOCAL_ADMIN_TOKEN,
  ADMIN_API_TOKEN: process.env.ADMIN_API_TOKEN,
  SITE_URL: process.env.SITE_URL,
  PAYMENTS_PROVIDER: process.env.PAYMENTS_PROVIDER,
  PORT: process.env.PORT,
  NODE_ENV: process.env.NODE_ENV as any,
};

const skipValidation =
  process.env.SKIP_ENV_VALIDATION === 'true' || raw.NODE_ENV === 'test';

// Vercel sets VERCEL_ENV to 'development' | 'preview' | 'production'
const isProdBuild =
  raw.NODE_ENV === 'production' && process.env.VERCEL_ENV === 'production';

const parsed = envSchema.safeParse(raw);

const globalEnv = globalThis as typeof globalThis & { __envWarnings?: Set<string> };

if (!parsed.success && typeof window === 'undefined') {
  if (skipValidation || !isProdBuild) {
    const warnings = parsed.error.issues
      .map((i) => `${i.path.join('.')}: ${i.message}`)
      .join('\n');

    const message =
      'Skipping strict environment validation (non-prod or SKIP_ENV_VALIDATION=true). Falling back to safe defaults:\n' +
      warnings;

    if (!globalEnv.__envWarnings) {
      globalEnv.__envWarnings = new Set();
    }

    if (!globalEnv.__envWarnings.has(message)) {
      globalEnv.__envWarnings.add(message);
      console.warn(message);
    }
  } else {
    const errors = parsed.error.issues
      .map((i) => `${i.path.join('.')}: ${i.message}`)
      .join('\n');
    console.error('Invalid environment variables:\n' + errors);
    throw new Error('Invalid environment variables');
  }
}

const defaults = {
  NEXT_PUBLIC_SUPABASE_URL: 'http://localhost:54321',
  NEXT_PUBLIC_SUPABASE_ANON_KEY: 'anon_key',
  SUPABASE_URL: 'http://localhost:54321',
  SUPABASE_SERVICE_KEY: 'service_key',
  SUPABASE_SERVICE_ROLE_KEY: 'service_role_key',
  REVIEW_SHARE_SECRET: 'review_share_secret',
  REVIEW_SHARE_TTL_HOURS: 72,
  TWILIO_ACCOUNT_SID: 'ACXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
  TWILIO_AUTH_TOKEN: 'auth_token',
  TWILIO_VERIFY_SERVICE_SID: 'VAXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
  TWILIO_WHATSAPP_FROM: 'whatsapp:+10000000000',
  WHATSAPP_TASKS_SIGNING_SECRET: 'whatsapp_signing_secret',
  PAYMENTS_PROVIDER: 'none',
  NEXT_PUBLIC_PAYMENTS_PROVIDER: 'none',
};

const filteredRaw = Object.fromEntries(
  Object.entries(raw).filter(([, value]) => value !== undefined && value !== null),
);

export const env = parsed.success
  ? parsed.data
  : {
      ...defaults,
      ...filteredRaw,
      NEXT_PUBLIC_IDLE_TIMEOUT_MINUTES: Number(raw.NEXT_PUBLIC_IDLE_TIMEOUT_MINUTES ?? 30),
      REVIEW_SHARE_TTL_HOURS: Number(
        raw.REVIEW_SHARE_TTL_HOURS ?? defaults.REVIEW_SHARE_TTL_HOURS ?? 72,
      ),
    };

export const isBrowser = typeof window !== 'undefined';
export const isServer = !isBrowser;

const hasSupabaseUrlEnv = Boolean(process.env.NEXT_PUBLIC_SUPABASE_URL ?? process.env.SUPABASE_URL);
const hasSupabaseAnonKeyEnv = Boolean(process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY);
const hasSupabaseServiceKeyEnv = Boolean(
  (process.env.SUPABASE_SERVICE_KEY ?? process.env.SUPABASE_SERVICE_ROLE_KEY) ?? '',
);

export const supabaseEnvState = {
  hasUrl: hasSupabaseUrlEnv,
  hasAnonKey: hasSupabaseAnonKeyEnv,
  hasServiceKey: hasSupabaseServiceKeyEnv,
};

export function bool(val?: string, fallback = false) {
  if (val == null) return fallback;
  return ['1', 'true', 'yes', 'on'].includes(String(val).toLowerCase());
}





============================================================
FILE #49
PATH: pages/api/notifications/whatsapp-opt-in.ts
============================================================
import type { NextApiRequest, NextApiResponse } from 'next';
import { z } from 'zod';
import { createSupabaseServerClient } from '@/lib/supabaseServer';
import { buildWhatsAppTaskMessage, dispatchWhatsAppTask } from '@/lib/tasks/whatsapp';

const BodySchema = z.object({
  consent: z.boolean(),
  sendTest: z.boolean().optional(),
  message: z.string().max(600).optional(),
});

type ResponseBody = { ok: boolean; error?: string };

function parseFunctionsError(error: unknown) {
  if (!error) return 'Failed to invoke WhatsApp task dispatcher';
  if (error instanceof Error) return error.message;
  if (typeof error === 'string') return error;
  if (typeof error === 'object' && 'message' in (error as any) && typeof (error as any).message === 'string') {
    return (error as any).message as string;
  }
  return 'Failed to invoke WhatsApp task dispatcher';
}

export default async function handler(req: NextApiRequest, res: NextApiResponse<ResponseBody>) {
  if (req.method !== 'POST') {
    res.setHeader('Allow', 'POST');
    return res.status(405).end('Method Not Allowed');
  }

  const parseResult = BodySchema.safeParse(req.body);
  if (!parseResult.success) {
    return res.status(400).json({ ok: false, error: 'Invalid request body' });
  }

  const { consent, sendTest = false, message } = parseResult.data;

  const supabase = createSupabaseServerClient({ req, res });
  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser();

  if (authError || !user) {
    return res.status(401).json({ ok: false, error: 'Unauthorized' });
  }

  try {
    const { error: optInError } = await supabase
      .from('notifications_opt_in')
      .upsert({ user_id: user.id, wa_opt_in: consent }, { onConflict: 'user_id' });

    if (optInError) {
      return res.status(500).json({ ok: false, error: optInError.message });
    }

    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('notification_channels, full_name')
      .eq('user_id', user.id)
      .maybeSingle();

    if (profileError) {
      return res.status(500).json({ ok: false, error: profileError.message });
    }

    const channels = new Set<string>((profile?.notification_channels ?? []) as string[]);
    if (consent) channels.add('whatsapp');
    else channels.delete('whatsapp');

    const { error: profileUpdateError } = await supabase.from('profiles').upsert({
      user_id: user.id,
      whatsapp_opt_in: consent,
      notification_channels: Array.from(channels),
    });

    if (profileUpdateError) {
      return res.status(500).json({ ok: false, error: profileUpdateError.message });
    }

    const { error: eventError } = await supabase.from('notification_consent_events').insert({
      user_id: user.id,
      actor_id: user.id,
      channel: 'whatsapp',
      action: consent ? 'opt_in' : 'opt_out',
      metadata: {
        source: 'api/notifications/whatsapp-opt-in',
        sendTest,
      },
    });

    if (eventError) {
      return res.status(500).json({ ok: false, error: eventError.message });
    }

    if (consent && sendTest) {
      const confirmationMessage =
        message?.trim() ||
        buildWhatsAppTaskMessage('optInConfirmation', {
          userName: profile?.full_name ?? undefined,
        });

      const response = await dispatchWhatsAppTask(supabase, {
        userId: user.id,
        type: 'test',
        message: confirmationMessage,
        metadata: {
          source: 'api/notifications/whatsapp-opt-in',
          trigger: 'sendTest',
        },
      });

      if (response.error) {
        return res.status(502).json({ ok: false, error: parseFunctionsError(response.error) });
      }
    }

    return res.status(200).json({ ok: true });
  } catch (error) {
    console.error('Error in WhatsApp opt-in API:', error);
    const message = error instanceof Error ? error.message : 'Operation failed';
    return res.status(500).json({ ok: false, error: message });
  }
}




============================================================
FILE #50
PATH: lib/proctoring.ts
============================================================
// File: lib/proctoring.ts
import { api } from './http'

export type PrecheckBody = {
  examAttemptId: string
  device?: { ua?: string; platform?: string; os?: string; browser?: string }
  permissions?: { camera?: boolean; microphone?: boolean; screen?: boolean; notifications?: boolean }
  network?: { downKbps?: number; upKbps?: number; rttMs?: number; jitterMs?: number; packetLoss?: number }
  webcam?: { width?: number; height?: number; fps?: number }
  microphone?: { levelDb?: number; noiseDb?: number }
}

export async function precheck(body: PrecheckBody){
  return api<{ ok: true; examAttemptId: string; passed: boolean; reasons: string[] } | { ok: false; error: string }>(`/api/proctoring/check`, { method: 'POST', body: JSON.stringify(body) })
}

export async function startSession(body: { attemptId: string }){
  return api<{ ok: true; sessionId: string } | { ok: false; error: string }>(`/api/proctoring/start`, { method: 'POST', body: JSON.stringify(body) })
}

export async function verifyFrame(body: { sessionId: string; imageBase64: string; tsUtc?: string }){
  return api<{ ok: true; verified: boolean; confidence?: number } | { ok: false; error: string }>(`/api/proctoring/verify`, { method: 'POST', body: JSON.stringify(body) })
}

export async function sendFlag(body: { sessionId: string; type: string; confidence?: number; notes?: string; evidenceUrl?: string; meta?: Record<string, unknown> }){
  return api<{ ok: true } | { ok: false; error: string }>(`/api/proctoring/flags`, { method: 'POST', body: JSON.stringify(body) })
}






============================================================
FILE #51
PATH: pages/api/notifications/[id].ts
============================================================
import type { NextApiRequest, NextApiResponse } from 'next';
import { createSupabaseServerClient } from '@/lib/supabaseServer';
import { MarkNotificationReadParamsSchema } from '@/lib/schemas/notifications';
import { NotificationService } from '@/lib/notificationService';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const supabase = createSupabaseServerClient({ req });
  const {
    data: { user },
  } = await supabase.auth.getUser();
  
  if (!user) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const paramsResult = MarkNotificationReadParamsSchema.safeParse({ id: req.query.id });
  if (!paramsResult.success) {
    return res.status(400).json({ error: 'Invalid notification ID' });
  }

  const { id } = paramsResult.data;
  const service = new NotificationService(supabase);

  try {
    if (req.method === 'PATCH') {
      await service.markAsRead(user.id, id);
      return res.status(200).json({ success: true });
    }

    if (req.method === 'DELETE') {
      const { error } = await supabase
        .from('notifications')
        .delete()
        .eq('id', id)
        .eq('user_id', user.id);

      if (error) throw error;
      return res.status(200).json({ success: true });
    }

    res.setHeader('Allow', ['PATCH', 'DELETE']);
    return res.status(405).end('Method Not Allowed');
  } catch (error) {
    console.error('Error in notification API:', error);
    const message = error instanceof Error ? error.message : 'Operation failed';
    const status = message.includes('not found') ? 404 : 500;
    return res.status(status).json({ error: message });
  }
}




============================================================
FILE #52
PATH: components/design-system/NotificationBell.tsx
============================================================
// components/notifications/NotificationBell.tsx
import * as React from 'react';
import Link from 'next/link';
import { BellIcon } from '@/lib/icons';
import { useNotifications } from '@/components/notifications/NotificationProvider';

const NotificationBellComponent: React.FC = () => {
  const [open, setOpen] = React.useState(false);
  const { notifications, unread, markRead } = useNotifications();
  const buttonRef = React.useRef<HTMLButtonElement | null>(null);
  const popoverRef = React.useRef<HTMLDivElement | null>(null);
  const itemsRef = React.useRef<Array<HTMLAnchorElement | HTMLButtonElement | null>>([]);

  itemsRef.current = [];

  React.useEffect(() => {
    if (!open) return;
    const onDocClick = (e: MouseEvent) => {
      const t = e.target as Node;
      if (buttonRef.current?.contains(t)) return;
      if (popoverRef.current?.contains(t)) return;
      setOpen(false);
    };
    const onKey = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        setOpen(false);
        buttonRef.current?.focus();
      }
    };
    document.addEventListener('mousedown', onDocClick);
    document.addEventListener('keydown', onKey);
    return () => {
      document.removeEventListener('mousedown', onDocClick);
      document.removeEventListener('keydown', onKey);
    };
  }, [open]);

  React.useEffect(() => {
    if (!open) return;
    const focusable = itemsRef.current.filter(Boolean) as HTMLElement[];
    if (focusable[0]) focusable[0].focus();
    const onKey = (e: KeyboardEvent) => {
      if (!popoverRef.current?.contains(document.activeElement)) return;
      const idx = focusable.indexOf(document.activeElement as HTMLElement);
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        focusable[(idx + 1) % focusable.length]?.focus();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        focusable[(idx - 1 + focusable.length) % focusable.length]?.focus();
      } else if (e.key === 'Enter' && document.activeElement instanceof HTMLElement) {
        (document.activeElement as HTMLElement).click();
      }
    };
    document.addEventListener('keydown', onKey);
    return () => document.removeEventListener('keydown', onKey);
  }, [open, notifications]);

  const markAllAsRead = async () => {
    await Promise.all(notifications.filter(n => !n.read).map(n => markRead(n.id)));
  };

  return (
    <div className="relative">
      <button
        ref={buttonRef}
        type="button"
        aria-label="Notifications"
        aria-haspopup="menu"
        aria-expanded={open}
        aria-controls="notification-menu"
        onClick={() => setOpen(v => !v)}
        className="relative inline-flex h-10 w-10 items-center justify-center rounded-lg hover:bg-muted focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background"
      >
        <BellIcon className="h-5 w-5" aria-hidden="true" />
        {unread > 0 && (
          <span
            aria-live="polite"
            className="absolute -top-1 -right-1 flex h-4 min-w-[1rem] items-center justify-center rounded-full bg-sunsetRed px-1 text-[10px] leading-none text-foreground"
          >
            {unread}
          </span>
        )}
      </button>

      {open && (
        <div
          ref={popoverRef}
          className="absolute right-0 mt-2 w-80 rounded-ds-2xl border border-border bg-card text-card-foreground shadow-lg z-50"
        >
          <div className="flex items-center justify-between border-b border-border px-3 py-2">
            <span className="text-small font-semibold">Notifications</span>
            {unread > 0 && (
              <button
                onClick={markAllAsRead}
                className="text-caption text-foreground/70 hover:text-foreground focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background rounded-ds px-1.5 py-0.5"
              >
                Mark all as read
              </button>
            )}
          </div>
          <ul id="notification-menu" role="menu" className="max-h-72 overflow-auto text-small" aria-live="polite">
            {notifications.map((n, i) => {
              const isInternal = n.url?.startsWith('/');
              const common = 'flex items-start gap-2 px-3 py-2 hover:bg-muted/60 focus:bg-muted/60 rounded-none';
              const row = (
                <div className={n.read ? 'opacity-60' : 'font-bold'}>
                  <div className="font-medium">{n.message}</div>
                </div>
              );
              return (
                <li key={n.id} role="none">
                  {n.url ? (
                    isInternal ? (
                      <Link
                        href={n.url}
                        role="menuitem"
                        ref={el => (itemsRef.current[i] = el as any)}
                        className={common}
                        onClick={() => {
                          markRead(n.id);
                          setOpen(false);
                        }}
                      >
                        {row}
                      </Link>
                    ) : (
                      <a
                        href={n.url!}
                        target="_blank"
                        rel="noreferrer"
                        role="menuitem"
                        ref={el => (itemsRef.current[i] = el as any)}
                        className={common}
                        onClick={() => {
                          markRead(n.id);
                          setOpen(false);
                        }}
                      >
                        {row}
                      </a>
                    )
                  ) : (
                    <button
                      role="menuitem"
                      ref={el => (itemsRef.current[i] = el as any)}
                      className={common + ' w-full text-left'}
                      onClick={() => markRead(n.id)}
                    >
                      {row}
                    </button>
                  )}
                </li>
              );
            })}
            {notifications.length === 0 && (
              <li className="px-3 py-3 text-muted-foreground">No notifications</li>
            )}
            <li className="border-t border-border/70">
              <Link
                href="/notifications"
                role="menuitem"
                ref={(el) => {
                  itemsRef.current[notifications.length] = el as HTMLAnchorElement | null;
                }}
                className="block px-3 py-2 text-center text-caption font-semibold text-primary hover:underline"
                onClick={() => setOpen(false)}
              >
                View all notifications
              </Link>
            </li>
          </ul>
        </div>
      )}
    </div>
  );
};

export const NotificationBell = React.memo(NotificationBellComponent);
NotificationBell.displayName = 'NotificationBell';

export default NotificationBell;




============================================================
FILE #53
PATH: pages/api/notifications/preferences.ts
============================================================
import type { NextApiRequest, NextApiResponse } from 'next';
import { createSupabaseServerClient } from '@/lib/supabaseServer';
import type { NotificationChannel, NotificationsOptIn, Profiles } from '@/types/supabase';
import { Channel, PreferencesBody, type PreferencesBodyInput } from '@/types/notifications';

type PreferencesRow = Pick<
  NotificationsOptIn,
  'channels' | 'email_opt_in' | 'wa_opt_in' | 'quiet_hours_start' | 'quiet_hours_end' | 'timezone'
> & { user_id: string };

type ProfileContact = Pick<Profiles, 'email' | 'phone' | 'phone_verified' | 'timezone'> & { user_id: string };

type PreferencesResponse = PreferencesBodyInput & {
  email: string | null;
  emailOptIn: boolean;
  whatsappOptIn: boolean;
  smsOptIn: boolean;
  phone: string | null;
  phoneVerified: boolean;
};

function toChannelSet(row?: PreferencesRow | null): Set<NotificationChannel> {
  const next = new Set<NotificationChannel>();
  if (!row) {
    next.add('email');
    return next;
  }

  const channels = (row.channels ?? []) as NotificationChannel[];
  channels.forEach((channel) => {
    if (Channel.safeParse(channel).success) {
      next.add(channel);
    }
  });

  if (row.email_opt_in ?? true) {
    next.add('email');
  }

  if (row.wa_opt_in ?? false) {
    next.add('whatsapp');
  }

  return next;
}

function buildResponse(row: PreferencesRow | null, profile: ProfileContact | null): PreferencesResponse {
  const enabled = toChannelSet(row);
  const parsed = PreferencesBody.parse({
    channels: {
      email: enabled.has('email'),
      whatsapp: enabled.has('whatsapp'),
    },
    quietHoursStart: (row?.quiet_hours_start as string | null) ?? null,
    quietHoursEnd: (row?.quiet_hours_end as string | null) ?? null,
    timezone: row?.timezone ?? profile?.timezone ?? 'UTC',
  });

  const email = profile?.email ? profile.email.trim() : null;
  const phone = profile?.phone ? profile.phone.trim() : null;
  const phoneVerified = profile?.phone_verified === null ? false : Boolean(profile?.phone_verified);

  return {
    ...parsed,
    email: email && email.length > 0 ? email : null,
    emailOptIn: parsed.channels.email,
    whatsappOptIn: parsed.channels.whatsapp,
    smsOptIn: false,
    phone: phone && phone.length > 0 ? phone : null,
    phoneVerified,
  };
}

async function loadPreferences(
  supabase: ReturnType<typeof createSupabaseServerClient>,
  userId: string,
): Promise<PreferencesResponse> {
  const [prefRes, profileRes] = await Promise.all([
    supabase
      .from('notifications_opt_in')
      .select(
        'user_id, channels, email_opt_in, wa_opt_in, quiet_hours_start, quiet_hours_end, timezone',
      )
      .eq('user_id', userId)
      .maybeSingle<PreferencesRow>(),
    supabase
      .from('profiles')
      .select('user_id, email, phone, phone_verified, timezone')
      .eq('user_id', userId)
      .maybeSingle<ProfileContact>(),
  ]);

  if (prefRes.error) {
    throw prefRes.error;
  }

  if (profileRes.error && profileRes.error.code !== 'PGRST116') {
    throw profileRes.error;
  }

  return buildResponse(prefRes.data ?? null, profileRes.data ?? null);
}

function normaliseTime(value: string | null | undefined): string | null {
  if (!value) return null;
  const trimmed = value.trim();
  return trimmed.length > 0 ? trimmed : null;
}

function buildChannelsArray(channels: Record<string, boolean>): string[] {
  const next: string[] = [];
  Object.entries(channels).forEach(([key, enabled]) => {
    if (enabled) {
      next.push(key);
    }
  });
  return next;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const supabase = createSupabaseServerClient({ req, res });
  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser();

  if (authError || !user) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    if (req.method === 'GET') {
      const preferences = await loadPreferences(supabase, user.id);
      return res.status(200).json({ preferences });
    }

    if (req.method === 'POST') {
      const parsed = PreferencesBody.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ 
          error: 'Invalid payload', 
          details: parsed.error.flatten() 
        });
      }

      const body = parsed.data;

      const upsertPayload = {
        user_id: user.id,
        channels: buildChannelsArray(body.channels),
        email_opt_in: body.channels.email ?? false,
        wa_opt_in: body.channels.whatsapp ?? false,
        quiet_hours_start: normaliseTime(body.quietHoursStart ?? null),
        quiet_hours_end: normaliseTime(body.quietHoursEnd ?? null),
        timezone: body.timezone ?? 'UTC',
      };

      const { error: upsertError } = await supabase
        .from('notifications_opt_in')
        .upsert(upsertPayload, { onConflict: 'user_id' });

      if (upsertError) {
        return res.status(500).json({ error: upsertError.message });
      }

      const preferences = await loadPreferences(supabase, user.id);
      return res.status(200).json({ preferences });
    }

    res.setHeader('Allow', ['GET', 'POST']);
    return res.status(405).end('Method Not Allowed');
  } catch (error) {
    console.error('Error in preferences API:', error);
    const message = error instanceof Error ? error.message : 'Operation failed';
    return res.status(500).json({ error: message });
  }
}




============================================================
FILE #54
PATH: pages/api/notifications/nudge.ts
============================================================
import type { NextApiRequest, NextApiResponse } from 'next';
import { withPlan, type PlanGuardContext } from '@/lib/api/withPlan';
import { enqueueEvent } from '@/lib/notify';
import { EnqueueBody } from '@/types/notifications';

const NudgeBody = EnqueueBody.pick({
  user_id: true,
  event_key: true,
  payload: true,
  channels: true,
  locale: true,
  bypass_quiet_hours: true,
}).extend({
  event_key: EnqueueBody.shape.event_key.default('nudge_manual'),
});

function buildIdempotencyKey(userId: string, eventKey: string): string {
  const today = new Date().toISOString().slice(0, 10);
  return `${eventKey}:${userId}:${today}`;
}

async function handler(req: NextApiRequest, res: NextApiResponse, ctx?: PlanGuardContext) {
  if (req.method !== 'POST') {
    res.setHeader('Allow', 'POST');
    return res.status(405).end('Method Not Allowed');
  }

  const role = ctx?.role ?? null;
  if (!role || (role !== 'admin' && role !== 'teacher')) {
    return res.status(403).json({ error: 'Forbidden' });
  }

  const parsed = NudgeBody.safeParse(req.body);
  if (!parsed.success) {
    return res.status(400).json({ 
      error: 'Invalid payload', 
      details: parsed.error.flatten() 
    });
  }

  const body = parsed.data;
  const idempotencyKey = buildIdempotencyKey(body.user_id, body.event_key);

  return enqueueEvent(req, res, { 
    ...body, 
    idempotency_key: idempotencyKey 
  });
}

export default withPlan('starter', handler, { allowRoles: ['admin', 'teacher'] });




============================================================
FILE #55
PATH: lib/locale.tsx
============================================================
import React, { createContext, useCallback, useContext, useEffect, useMemo, useState } from 'react';

import enMessages from '@/public/locales/en/common.json';
import hiMessages from '@/public/locales/hi/common.json';
import urMessages from '@/public/locales/ur/common.json';
import arMessages from '@/public/locales/ar/common.json';
import esMessages from '@/public/locales/es/common.json';

const SUPPORTED_LOCALES = ['en', 'ur'] as const;
export type Locale = (typeof SUPPORTED_LOCALES)[number];
const DEFAULT_LOCALE: Locale = 'en';
const STORAGE_KEY = 'gx:locale';
const COOKIE_KEY = 'locale';
const RTL_LOCALES = new Set(['ur', 'ar', 'fa', 'he', 'ps']);

type Messages = Record<string, unknown>;
const registry: Partial<Record<Locale, Messages>> = {};
let currentLocale: Locale = DEFAULT_LOCALE;

const subscribers = new Set<(locale: Locale) => void>();

function isObject(value: unknown): value is Record<string, unknown> {
  return typeof value === 'object' && value !== null && !Array.isArray(value);
}
function deepMerge(target: Messages = {}, source: Messages = {}): Messages {
  const result: Messages = { ...target };
  for (const [key, value] of Object.entries(source)) {
    if (isObject(value)) {
      const existing = isObject(result[key]) ? (result[key] as Messages) : {};
      result[key] = deepMerge(existing, value as Messages);
    } else {
      result[key] = value;
    }
  }
  return result;
}
function deepGet(obj: unknown, path: string): unknown {
  if (!obj) return undefined;
  return path.split('.').reduce<unknown>((acc, part) => {
    if (acc == null) return undefined;
    if (isObject(acc) || Array.isArray(acc)) {
      return (acc as Record<string, unknown>)[part];
    }
    return undefined;
  }, obj);
}

function normaliseLocale(raw?: string | null): Locale {
  if (!raw) return DEFAULT_LOCALE;
  const lower = raw.toLowerCase();
  const direct = SUPPORTED_LOCALES.find((loc) => loc === lower);
  if (direct) return direct;
  const base = lower.split('-')[0];
  const baseMatch = SUPPORTED_LOCALES.find((loc) => loc === base);
  return baseMatch ?? DEFAULT_LOCALE;
}

export function toSupportedLocale(input: string | Locale): Locale {
  return normaliseLocale(typeof input === 'string' ? input : String(input));
}

export function isLocaleRTL(locale: string | null | undefined): boolean {
  if (!locale) return false;
  const base = locale.split('-')[0]?.toLowerCase() ?? '';
  return RTL_LOCALES.has(base);
}

function applyLocale(locale: Locale) {
  if (typeof document === 'undefined') return;
  try {
    const dir = isLocaleRTL(locale) ? 'rtl' : 'ltr';
    document.documentElement.setAttribute('lang', locale);
    document.documentElement.setAttribute('dir', dir);
  } catch (err) {
    console.warn('Failed to apply locale attributes', err);
  }
}
function persistLocaleCookie(locale: Locale, maxAgeSeconds = 60 * 60 * 24 * 180) {
  if (typeof document === 'undefined') return;
  document.cookie = `${COOKIE_KEY}=${encodeURIComponent(locale)}; path=/; max-age=${maxAgeSeconds}`;
}
function persistLocaleStorage(locale: Locale) {
  if (typeof window === 'undefined') return;
  try {
    window.localStorage.setItem(STORAGE_KEY, locale);
  } catch {
    // ignore
  }
}
function notify(locale: Locale) {
  subscribers.forEach((listener) => {
    try {
      listener(locale);
    } catch (err) {
      console.error('Locale subscriber failed', err);
    }
  });
}
function readCookie(name: string, cookieString?: string): string | undefined {
  const source = cookieString ?? (typeof document !== 'undefined' ? document.cookie : undefined);
  if (!source) return undefined;
  const match = source.match(new RegExp(`(?:^|; )${name}=([^;]+)`));
  return match ? decodeURIComponent(match[1]) : undefined;
}
function parseAcceptLanguage(header?: string): string | null {
  if (!header) return null;
  const tokens = header.split(',');
  for (const token of tokens) {
    const locale = token.split(';')[0]?.trim();
    if (locale) return locale;
  }
  return null;
}

export function registerMessages(localeInput: string, messages: Messages) {
  const locale = normaliseLocale(localeInput);
  registry[locale] = deepMerge(registry[locale] ?? {}, messages);
}
function resolveMessage(locale: Locale, key: string): string | undefined {
  const source = registry[locale];
  if (!source) return undefined;
  const value = deepGet(source, key);
  return typeof value === 'string' ? value : undefined;
}

type TemplateValues = Record<string, string | number>;
function formatTemplate(template: string, values: TemplateValues): string {
  return template.replace(/\{\{\s*(\w+)\s*\}\}/g, (_, token: string) => {
    const replacement = values[token];
    return replacement === undefined || replacement === null ? '' : String(replacement);
  });
}

export function t(key: string, arg2?: TemplateValues | string, arg3?: string): string {
  let values: TemplateValues | undefined;
  let fallback: string | undefined;

  if (arg2 && typeof arg2 === 'object' && !Array.isArray(arg2)) {
    values = arg2 as TemplateValues;
    fallback = arg3;
  } else if (typeof arg2 === 'string') {
    fallback = arg2;
  }

  const primary = resolveMessage(currentLocale, key);
  const fallbackLocale = currentLocale === DEFAULT_LOCALE ? undefined : resolveMessage(DEFAULT_LOCALE, key);
  const template = primary ?? fallbackLocale ?? fallback ?? key;
  return values ? formatTemplate(template, values) : template;
}

export function detectLocale(
  defaultLocale: Locale = DEFAULT_LOCALE,
  opts?: { cookieString?: string; acceptLanguageHeader?: string },
): Locale {
  const fromCookie = readCookie(COOKIE_KEY, opts?.cookieString);
  if (fromCookie) return normaliseLocale(fromCookie);

  if (typeof window !== 'undefined') {
    try {
      const stored = window.localStorage.getItem(STORAGE_KEY);
      if (stored) return normaliseLocale(stored);
    } catch { /* ignore */ }

    const htmlLocale = document?.documentElement?.getAttribute('lang');
    if (htmlLocale) return normaliseLocale(htmlLocale);

    const nav = (navigator?.languages && navigator.languages[0]) || navigator?.language;
    if (nav) return normaliseLocale(nav);
  }

  const fromHeader = parseAcceptLanguage(opts?.acceptLanguageHeader);
  if (fromHeader) return normaliseLocale(fromHeader);

  return defaultLocale;
}

export const _detectLocale = detectLocale;

export function setLocale(nextInput: string | Locale) {
  const next = normaliseLocale(nextInput as string);
  if (currentLocale === next) return;
  currentLocale = next;
  applyLocale(next);
  persistLocaleCookie(next);
  persistLocaleStorage(next);
  if (typeof window !== 'undefined') {
    try {
      window.dispatchEvent(new CustomEvent('locale:changed', { detail: next }));
    } catch { /* ignore */ }
  }
  notify(next);
}
export const persistLocale = setLocale;
export function getLocale(): Locale {
  return currentLocale;
}

type LocaleContextValue = {
  locale: Locale;
  setLocale: (locale: Locale | string) => void;
  t: typeof t;
  direction: 'ltr' | 'rtl';
  isRTL: boolean;
};

const LocaleCtx = createContext<LocaleContextValue | null>(null);

export function useLocale(): LocaleContextValue {
  const ctx = useContext(LocaleCtx);
  if (ctx) return ctx;
  const direction = isLocaleRTL(currentLocale) ? 'rtl' : 'ltr';
  return { locale: currentLocale, setLocale, t, direction, isRTL: direction === 'rtl' };
}

export function LocaleProvider({
  initialLocale = DEFAULT_LOCALE,
  children,
}: {
  initialLocale?: Locale | string;
  children: React.ReactNode;
}) {
  const [locale, setLocaleState] = useState<Locale>(() => {
    const detected =
      typeof window === 'undefined'
        ? normaliseLocale(initialLocale as string)
        : detectLocale(normaliseLocale(initialLocale as string));
    currentLocale = detected;
    return detected;
  });

  useEffect(() => {
    applyLocale(locale);
    persistLocaleCookie(locale);
    persistLocaleStorage(locale);
  }, [locale]);

  useEffect(() => {
    const handleStorage = (event: StorageEvent) => {
      if (event.key === STORAGE_KEY && event.newValue) {
        setLocale(event.newValue);
      }
    };
    const handleCustom = (event: Event) => {
      const detail = (event as CustomEvent<Locale>).detail;
      if (detail) setLocale(detail);
    };
    if (typeof window !== 'undefined') {
      window.addEventListener('storage', handleStorage);
      window.addEventListener('locale:changed', handleCustom as EventListener);
    }
    return () => {
      if (typeof window !== 'undefined') {
        window.removeEventListener('storage', handleStorage);
        window.removeEventListener('locale:changed', handleCustom as EventListener);
      }
    };
  }, []);

  useEffect(() => {
    const unsubscribe = subscribe((next) => setLocaleState(next));
    return unsubscribe;
  }, []);

  const update = useCallback((next: Locale | string) => setLocale(next), []);

  const value = useMemo<LocaleContextValue>(() => {
    const direction = isLocaleRTL(locale) ? 'rtl' : 'ltr';
    return { locale, setLocale: update, t, direction, isRTL: direction === 'rtl' };
  }, [locale, update]);

  return <LocaleCtx.Provider value={value}>{children}</LocaleCtx.Provider>;
}

function subscribe(listener: (locale: Locale) => void) {
  subscribers.add(listener);
  return () => {
    subscribers.delete(listener);
  };
}

// register built-in message bundles (including Urdu)
const builtinMessages: Record<string, Messages> = {
  en: enMessages,
  hi: hiMessages,
  ur: urMessages,
  ar: arMessages,
  es: esMessages,
};
Object.entries(builtinMessages).forEach(([loc, messages]) => {
  registerMessages(loc, messages);
});





============================================================
FILE #56
PATH: lib/payments/safepay.ts
============================================================
import crypto from 'node:crypto';

import { env } from '@/lib/env';
import type { Cycle, PlanKey } from './index';

export type SafepaySession = Readonly<{ url: string; sessionId: string }>;

type InitiateSafepayInput = Readonly<{
  origin: string;
  plan: PlanKey;
  cycle: Cycle;
  amountCents: number;
  currency: 'PKR' | 'USD';
  intentId: string;
}>;

const DEFAULTS = {
  sandbox: {
    apiBase: 'https://sandbox.api.getsafepay.com',
    checkoutBase: 'https://sandbox.api.getsafepay.com/components',
  },
  production: {
    apiBase: 'https://api.getsafepay.com',
    checkoutBase: 'https://getsafepay.com/components',
  },
} as const;

const SAFEPAY_ENV = env.SAFEPAY_ENV === 'production' ? 'production' : 'sandbox';

function getApiBase(): string {
  return env.SAFEPAY_API_BASE_URL || DEFAULTS[SAFEPAY_ENV].apiBase;
}

function getCheckoutBase(): string {
  return env.SAFEPAY_CHECKOUT_BASE_URL || DEFAULTS[SAFEPAY_ENV].checkoutBase;
}

function roundCentsToMajor(cents: number): number {
  return Math.round((cents / 100) * 100) / 100;
}

export function isSafepayConfigured(): boolean {
  return Boolean(env.SAFEPAY_PUBLIC_KEY && env.SAFEPAY_SECRET_KEY);
}

export function devSafepaySession(origin: string, plan: PlanKey, _cycle: Cycle): SafepaySession {
  const sid = `sp_dev_${Date.now()}`;
  return { url: `${origin}/checkout/success?session_id=${sid}&plan=${plan}`, sessionId: sid };
}

function buildCheckoutUrl(sessionId: string, params: { orderId: string; redirectUrl: string; cancelUrl: string }): string {
  const search = new URLSearchParams({
    env: SAFEPAY_ENV,
    beacon: sessionId,
    order_id: params.orderId,
    source: 'custom',
    redirect_url: params.redirectUrl,
    cancel_url: params.cancelUrl,
  });
  return `${getCheckoutBase()}?${search.toString()}`;
}

/** Initiate a Safepay payment session */
export async function initiateSafepay(input: InitiateSafepayInput): Promise<SafepaySession> {
  if (!isSafepayConfigured() || env.NEXT_PUBLIC_DEV_PAYMENTS) {
    return devSafepaySession(input.origin, input.plan, input.cycle);
  }

  const amount = roundCentsToMajor(input.amountCents);
  const response = await fetch(`${getApiBase()}/order/v1/init`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      environment: SAFEPAY_ENV,
      client: env.SAFEPAY_PUBLIC_KEY,
      amount,
      currency: input.currency,
    }),
  });

  if (!response.ok) {
    throw new Error(`Safepay order init failed (${response.status})`);
  }

  const payload = (await response.json()) as { data?: { token?: string; tracker?: string } };
  const sessionId = String(payload?.data?.token || payload?.data?.tracker || '').trim();
  if (!sessionId) {
    throw new Error('Safepay response missing session token');
  }

  const redirectUrl = `${input.origin}/api/payments/webhooks/safepay?plan=${encodeURIComponent(
    input.plan,
  )}&cycle=${encodeURIComponent(input.cycle)}`;
  const cancelUrl = `${input.origin}/pricing?canceled=1&plan=${encodeURIComponent(
    input.plan,
  )}&provider=safepay`;

  return {
    sessionId,
    url: buildCheckoutUrl(sessionId, { orderId: `gx_${input.intentId}`, redirectUrl, cancelUrl }),
  };
}

/** Verify Safepay payment notification/webhook */
export async function verifySafepay(payload: unknown): Promise<boolean> {
  if (!isSafepayConfigured() || env.NEXT_PUBLIC_DEV_PAYMENTS) {
    return true;
  }

  const data = payload as Record<string, unknown> | null;
  const tracker = String((data?.tracker ?? data?.beacon ?? data?.token ?? '') || '').trim();
  const signature = String((data?.sig ?? data?.signature ?? data?.order_signature ?? '') || '').trim();
  if (!tracker || !signature) {
    return false;
  }

  const expected = crypto.createHmac('sha256', env.SAFEPAY_SECRET_KEY as string).update(tracker).digest('hex');
  return expected === signature;
}





============================================================
FILE #57
PATH: lib/payments/jazzcash.ts
============================================================
import { env } from '@/lib/env';
import type { Cycle, PlanKey } from './index';

export type JazzCashSession = Readonly<{ url: string; sessionId: string }>;

/** Detect if real JazzCash keys are available */
export function isJazzCashConfigured(): boolean {
  return Boolean(env.JAZZCASH_MERCHANT_ID && env.JAZZCASH_INTEGRITY_SALT);
}

/** Dev fallback: returns a mock JazzCash session */
export function devJazzCashSession(origin: string, plan: PlanKey, _cycle: Cycle): JazzCashSession {
  const sid = `jc_dev_${Date.now()}`;
  return { url: `${origin}/checkout/success?session_id=${sid}&plan=${plan}`, sessionId: sid };
}

/** Initiate a JazzCash payment session */
export async function initiateJazzCash(
  origin: string,
  plan: PlanKey,
  cycle: Cycle
): Promise<JazzCashSession> {
  if (!isJazzCashConfigured() || env.NEXT_PUBLIC_DEV_PAYMENTS) {
    return devJazzCashSession(origin, plan, cycle);
  }
  // TODO: Wire to real JazzCash API when keys/SDK are available
  throw new Error('JazzCash live integration not implemented yet.');
}

/** Verify JazzCash payment notification/webhook */
export async function verifyJazzCash(payload: unknown): Promise<boolean> {
  if (!isJazzCashConfigured() || env.NEXT_PUBLIC_DEV_PAYMENTS) {
    return true; // trust all in dev
  }
  // TODO: Implement real signature/hash verification
  throw new Error('JazzCash verification not implemented yet.');
}





============================================================
FILE #58
PATH: lib/flags/index.ts
============================================================
// lib/flags/index.ts
// Unified feature flag registry backed by env defaults + Supabase table overrides.
// - Server: fetches flag rows with light caching, supports audience targeting.
// - Client: hydrated via /api/debug/feature-flags snapshot and works offline.

import { bool, env } from '@/lib/env';
import { supabaseAdmin } from '@/lib/supabaseAdmin';
import type { PlanId } from '@/types/pricing';

export type FeatureFlagKey =
  | 'trial'
  | 'paywall'
  | 'referral'
  | 'partner'
  | 'predictor'
  | 'challenge'
  | 'coach'
  | 'notifications'
  | 'quickTen'
  | 'aiAssist'
  | 'writingExports'
  | 'writingCertificates'
  | 'killSwitchWriting'
  | 'killSwitchAiCoach'
  | 'killSwitchAuth'
  | 'adminConsole'
  | 'perfBudgets';

export type FlagAudience = {
  plan?: PlanId | null;
  role?: string | null;
  userId?: string | null;
};

export type FlagTargeting = {
  plans?: PlanId[] | null;
  roles?: string[] | null;
  percentage?: number | null;
};

export type FlagRow = {
  key: string;
  enabled: boolean;
  audience: FlagTargeting | null;
  updated_at?: string | null;
};

const STATIC_DEFAULTS: Record<FeatureFlagKey, boolean> = {
  trial: bool(env.NEXT_PUBLIC_FEATURE_TRIAL, true),
  paywall: bool(env.NEXT_PUBLIC_FEATURE_PAYWALL, true),
  referral: bool(env.NEXT_PUBLIC_FEATURE_REFERRAL, false),
  partner: bool(env.NEXT_PUBLIC_FEATURE_PARTNER, false),
  predictor: bool(env.NEXT_PUBLIC_FEATURE_PREDICTOR, true),
  challenge: bool(env.NEXT_PUBLIC_FEATURE_CHALLENGE, false),
  coach: bool(env.NEXT_PUBLIC_FEATURE_COACH, false),
  notifications: bool(env.NEXT_PUBLIC_FEATURE_NOTIFICATIONS, false),
  quickTen: bool(env.NEXT_PUBLIC_FEATURE_QUICK_TEN, false),
  aiAssist: bool(env.NEXT_PUBLIC_FEATURE_AI_ASSIST, false),
  writingExports: false,
  writingCertificates: false,
  killSwitchWriting: false,
  killSwitchAiCoach: false,
  killSwitchAuth: false,
  adminConsole: false,
  perfBudgets: false,
};

type DynamicMap = Map<string, FlagRow>;

let dynamicFlags: DynamicMap = new Map();
let lastRefresh = 0;
const REFRESH_MS = 60_000;
let inFlight: Promise<void> | null = null;

let clientSnapshot: Record<string, boolean> = { ...STATIC_DEFAULTS };

const inBrowser = () => typeof window !== 'undefined';

const normalisePercentage = (value?: number | null): number | null => {
  if (typeof value !== 'number' || Number.isNaN(value)) return null;
  if (value <= 0) return 0;
  if (value >= 100) return 100;
  return Math.round(value);
};

const hashPercent = (input: string): number => {
  let hash = 0;
  for (let i = 0; i < input.length; i += 1) {
    hash = (hash * 31 + input.charCodeAt(i)) >>> 0;
  }
  return hash % 100;
};

function matchesAudience(flag: FlagRow, audience?: FlagAudience | null): boolean {
  if (!flag.audience) return true;
  const targeting = flag.audience;
  if (!audience) {
    // Without audience context we cannot safely evaluate targeted flags â†’ default deny.
    return false;
  }

  if (Array.isArray(targeting.plans) && targeting.plans.length > 0) {
    if (!audience.plan || !targeting.plans.includes(audience.plan)) {
      return false;
    }
  }

  if (Array.isArray(targeting.roles) && targeting.roles.length > 0) {
    const role = (audience.role ?? '').toLowerCase();
    if (!role || !targeting.roles.map((r) => r.toLowerCase()).includes(role)) {
      return false;
    }
  }

  const pct = normalisePercentage(targeting.percentage ?? null);
  if (pct != null) {
    const basis = audience.userId ?? `${audience.plan ?? ''}:${audience.role ?? ''}`;
    if (!basis) return false;
    const bucket = hashPercent(basis);
    return bucket < pct;
  }

  return true;
}

async function ensureDynamicFlags(force = false): Promise<void> {
  if (inBrowser()) return;
  if (!supabaseAdmin) return;
  const now = Date.now();
  if (!force && now - lastRefresh < REFRESH_MS) return;
  if (inFlight) return inFlight;

  inFlight = (async () => {
    const { data, error } = await supabaseAdmin
      .from('feature_flags')
      .select('key, enabled, audience, updated_at');
    if (error) {
      console.error('[flags] failed to load feature_flags table', error.message);
      inFlight = null;
      return;
    }
    dynamicFlags = new Map(
      (data ?? []).map((row) => [row.key, {
        key: row.key,
        enabled: Boolean(row.enabled),
        audience: row.audience as FlagTargeting | null,
        updated_at: row.updated_at ?? null,
      }]),
    );
    lastRefresh = Date.now();
    inFlight = null;
  })();

  await inFlight;
}

function resolveFlagValue(key: string, audience?: FlagAudience | null): boolean {
  const staticDefault = STATIC_DEFAULTS[key as FeatureFlagKey] ?? false;
  const record = dynamicFlags.get(key);
  if (!record) return staticDefault;
  if (!record.enabled) return false;
  return matchesAudience(record, audience);
}

export type FlagSnapshot = Record<string, boolean>;

export async function resolveFlags(audience?: FlagAudience | null): Promise<FlagSnapshot> {
  if (inBrowser()) return { ...clientSnapshot };
  await ensureDynamicFlags(false);
  const entries = new Set<string>([
    ...Object.keys(STATIC_DEFAULTS),
    ...Array.from(dynamicFlags.keys()),
  ]);
  const snapshot: FlagSnapshot = {};
  entries.forEach((key) => {
    snapshot[key] = resolveFlagValue(key, audience);
  });
  return snapshot;
}

export async function serverEnabled(
  key: FeatureFlagKey,
  audience?: FlagAudience | null,
): Promise<boolean> {
  await ensureDynamicFlags(false);
  return resolveFlagValue(key, audience);
}

export function primeClientSnapshot(snapshot: FlagSnapshot) {
  clientSnapshot = { ...STATIC_DEFAULTS, ...snapshot };
}

export function invalidateFlagCache() {
  lastRefresh = 0;
}

export const flags = {
  enabled(key: FeatureFlagKey, audience?: FlagAudience | null) {
    if (inBrowser()) {
      return Boolean(clientSnapshot[key] ?? STATIC_DEFAULTS[key]);
    }
    return resolveFlagValue(key, audience);
  },
  snapshot() {
    if (inBrowser()) {
      return { ...clientSnapshot };
    }
    const entries = new Set<string>([
      ...Object.keys(STATIC_DEFAULTS),
      ...Array.from(dynamicFlags.keys()),
    ]);
    const snap: FlagSnapshot = {};
    entries.forEach((key) => {
      snap[key] = resolveFlagValue(key);
    });
    return snap;
  },
};






============================================================
FILE #59
PATH: lib/payments/localWebhook.ts
============================================================
import { supabaseService } from '@/lib/supabaseService';
import { trackor } from '@/lib/analytics/trackor.server';
import { queueNotificationEvent, getNotificationContact } from '@/lib/notify';
import { getBaseUrl } from '@/lib/url';
import type { PaymentProvider } from '@/lib/payments/gateway';

type IntentRow = {
  id: string;
  user_id: string | null;
  plan_id: string;
  cycle: string;
  status: string;
};

export type FinalizePaymentResult =
  | { ok: true; intent: IntentRow; alreadyProcessed: boolean }
  | { ok: false; error: 'intent_not_found'; status: 404 }
  | { ok: false; error: 'update_failed'; status: 500 };

export async function finalizeLocalPayment(
  provider: PaymentProvider,
  sessionId: string,
): Promise<FinalizePaymentResult> {
  const { data: intent } = await supabaseService
    .from('payment_intents')
    .select('id, user_id, plan_id, cycle, status')
    .eq('provider', provider)
    .eq('gateway_session_id', sessionId)
    .maybeSingle();

  if (!intent) {
    return { ok: false, error: 'intent_not_found', status: 404 };
  }

  if (intent.status === 'succeeded') {
    return { ok: true, intent, alreadyProcessed: true };
  }

  const confirmedAt = new Date().toISOString();

  const updateResult = await supabaseService
    .from('payment_intents')
    .update({ status: 'succeeded', confirmed_at: confirmedAt, updated_at: confirmedAt })
    .eq('id', intent.id);

  if (updateResult.error) {
    return { ok: false, error: 'update_failed', status: 500 };
  }

  await supabaseService.from('payment_intent_events').insert({
    intent_id: intent.id,
    user_id: intent.user_id,
    event: 'webhook.success',
    payload: { provider, sessionId },
  });

  if (intent.user_id) {
    await supabaseService.from('profiles').update({ plan_id: intent.plan_id }).eq('id', intent.user_id);
  }

  await trackor.log('payments.intent.success', {
    userId: intent.user_id,
    intentId: intent.id,
    provider,
    plan: intent.plan_id,
    cycle: intent.cycle,
  });

  if (intent.user_id) {
    const contact = await getNotificationContact(intent.user_id);
    if (contact.email) {
      const baseUrl = getBaseUrl();
      const payload: Record<string, unknown> = {
        plan: intent.plan_id,
        cycle: intent.cycle,
        provider,
        deep_link: `${baseUrl}/settings/billing`,
        user_email: contact.email,
      };
      if (contact.phone) {
        payload.user_phone = contact.phone;
      }

      const result = await queueNotificationEvent({
        event_key: 'payment_success',
        user_id: intent.user_id,
        payload,
        channels: ['email'],
        idempotency_key: `payment_success:${intent.id}`,
      });

      if (!result.ok && result.reason !== 'duplicate') {
        console.error('[payments:webhook:notify]', provider, result.message);
      }
    }
  }

  return { ok: true, intent, alreadyProcessed: false };
}





============================================================
FILE #60
PATH: lib/payments/easypaisa.ts
============================================================
import { env } from '@/lib/env';
import type { Cycle, PlanKey } from './index';

export type EasypaisaSession = Readonly<{ url: string; sessionId: string }>;

/** Detect if real Easypaisa keys are available */
export function isEasypaisaConfigured(): boolean {
  return Boolean(env.EASYPASA_MERCHANT_ID && env.EASYPASA_SECRET);
}

/** Dev fallback: returns a mock Easypaisa session */
export function devEasypaisaSession(origin: string, plan: PlanKey, _cycle: Cycle): EasypaisaSession {
  const sid = `ep_dev_${Date.now()}`;
  return { url: `${origin}/checkout/success?session_id=${sid}&plan=${plan}`, sessionId: sid };
}

/** Initiate an Easypaisa payment session */
export async function initiateEasypaisa(
  origin: string,
  plan: PlanKey,
  cycle: Cycle
): Promise<EasypaisaSession> {
  if (!isEasypaisaConfigured() || env.NEXT_PUBLIC_DEV_PAYMENTS) {
    return devEasypaisaSession(origin, plan, cycle);
  }
  // TODO: Wire to real Easypaisa API when keys/SDK are available
  throw new Error('Easypaisa live integration not implemented yet.');
}

/** Verify Easypaisa payment notification/webhook */
export async function verifyEasypaisa(payload: unknown): Promise<boolean> {
  if (!isEasypaisaConfigured() || env.NEXT_PUBLIC_DEV_PAYMENTS) {
    return true; // trust all in dev
  }
  // TODO: Implement real signature/hash verification
  throw new Error('Easypaisa verification not implemented yet.');
}





============================================================
FILE #61
PATH: lib/autosave.ts
============================================================
export type AutosaveSnapshot<T> = {
  data: T;
  updatedAt: string;
  version: number;
};

export type AutosaveListener<T> = (snapshot: AutosaveSnapshot<T> | null) => void;

export interface AutosaveSession<T> {
  key: string;
  version: number;
  load: () => AutosaveSnapshot<T> | null;
  save: (data: T) => AutosaveSnapshot<T>;
  patch: (partial: Partial<T>) => AutosaveSnapshot<T>;
  clear: () => void;
  subscribe: (listener: AutosaveListener<T>) => () => void;
}

export interface GlobalAutosaveRegistry {
  register: (session: AutosaveSession<any>) => void;
  get: (key: string) => AutosaveSession<any> | undefined;
  keys: () => string[];
  snapshot: (key: string) => AutosaveSnapshot<any> | null;
  clear: (key: string) => void;
}

type AnyListener = AutosaveListener<any>;

type StorageLike = Pick<Storage, 'getItem' | 'setItem' | 'removeItem'>;

const KEY_PREFIX = 'autosave:';

const listeners = new Map<string, Set<AnyListener>>();

const getStorage = (): StorageLike | null => {
  if (typeof window === 'undefined') return null;
  try {
    return window.localStorage;
  } catch {
    return null;
  }
};

const nowIso = () => new Date().toISOString();

const parseSnapshot = <T,>(raw: string | null, version: number): AutosaveSnapshot<T> | null => {
  if (!raw) return null;
  try {
    const parsed = JSON.parse(raw);
    if (parsed && typeof parsed === 'object') {
      const candidate = parsed as { data?: unknown; version?: number; updatedAt?: string } & Record<string, unknown>;
      const parsedVersion = typeof candidate.version === 'number' ? candidate.version : undefined;
      if (parsedVersion != null && parsedVersion !== version) {
        return null;
      }
      const updatedAt = typeof candidate.updatedAt === 'string' ? candidate.updatedAt : nowIso();
      if (candidate.data && typeof candidate.data === 'object') {
        return { data: candidate.data as T, updatedAt, version };
      }
      return { data: parsed as T, updatedAt, version };
    }
  } catch {
    return null;
  }
  return null;
};

const notify = <T,>(key: string, snapshot: AutosaveSnapshot<T> | null) => {
  const subs = listeners.get(key);
  if (!subs || subs.size === 0) return;
  subs.forEach((listener) => {
    try {
      listener(snapshot);
    } catch {
      // ignore listener errors
    }
  });
};

const writeSnapshot = <T,>(key: string, snapshot: AutosaveSnapshot<T> | null) => {
  const storage = getStorage();
  if (!storage) return;
  try {
    if (snapshot) {
      storage.setItem(key, JSON.stringify(snapshot));
    } else {
      storage.removeItem(key);
    }
  } catch {
    // ignore storage failures
  }
};

const ensureRegistry = (): GlobalAutosaveRegistry | null => {
  if (typeof window === 'undefined') return null;
  const w = window as Window & { __GRAMOR_AUTOSAVE__?: GlobalAutosaveRegistry };
  if (w.__GRAMOR_AUTOSAVE__) return w.__GRAMOR_AUTOSAVE__;
  const sessions = new Map<string, AutosaveSession<any>>();
  const registry: GlobalAutosaveRegistry = {
    register: (session) => {
      sessions.set(session.key, session);
    },
    get: (key) => sessions.get(key),
    keys: () => Array.from(sessions.keys()),
    snapshot: (key) => sessions.get(key)?.load() ?? null,
    clear: (key) => sessions.get(key)?.clear(),
  };
  Object.defineProperty(w, '__GRAMOR_AUTOSAVE__', {
    configurable: true,
    value: registry,
  });
  return registry;
};

export const autosaveStorageKey = (scope: string, id: string) => `${KEY_PREFIX}${scope}:${id}`;

type SessionOptions = {
  scope: string;
  id: string;
  version?: number;
  legacyKeys?: string[];
};

export function createAutosaveSession<T>(options: SessionOptions): AutosaveSession<T> {
  const version = options.version ?? 1;
  const key = autosaveStorageKey(options.scope, options.id);
  const legacyKeys = options.legacyKeys ?? [];

  const loadFrom = (storageKey: string): AutosaveSnapshot<T> | null => {
    const storage = getStorage();
    if (!storage) return null;
    let raw: string | null = null;
    try {
      raw = storage.getItem(storageKey);
    } catch {
      raw = null;
    }
    const snapshot = parseSnapshot<T>(raw, version);
    if (snapshot && storageKey !== key) {
      // migrate legacy payloads to the canonical key
      try {
        storage.setItem(key, JSON.stringify(snapshot));
        storage.removeItem(storageKey);
      } catch {
        // ignore migration failures
      }
    }
    return snapshot;
  };

  const load = () => {
    const primary = loadFrom(key);
    if (primary) return primary;
    for (const legacyKey of legacyKeys) {
      const migrated = loadFrom(legacyKey);
      if (migrated) return migrated;
    }
    return null;
  };

  const save = (data: T) => {
    const snapshot: AutosaveSnapshot<T> = { data, updatedAt: nowIso(), version };
    writeSnapshot(key, snapshot);
    notify(key, snapshot);
    return snapshot;
  };

  const patch = (partial: Partial<T>) => {
    const current = load()?.data ?? ({} as T);
    const next = { ...current, ...partial } as T;
    return save(next);
  };

  const clear = () => {
    writeSnapshot<T>(key, null);
    notify<T>(key, null);
  };

  const subscribe = (listener: AutosaveListener<T>) => {
    const set = listeners.get(key) ?? new Set<AnyListener>();
    set.add(listener as AnyListener);
    listeners.set(key, set);
    return () => {
      const curr = listeners.get(key);
      if (!curr) return;
      curr.delete(listener as AnyListener);
      if (curr.size === 0) listeners.delete(key);
    };
  };

  const session: AutosaveSession<T> = {
    key,
    version,
    load,
    save,
    patch,
    clear,
    subscribe,
  };

  ensureRegistry()?.register(session);

  return session;
}

declare global {
  interface Window {
    __GRAMOR_AUTOSAVE__?: GlobalAutosaveRegistry;
  }
}

export {};





============================================================
FILE #62
PATH: lib/notify/index.ts
============================================================
import type { NextApiRequest, NextApiResponse } from 'next';
import type { PostgrestError, SupabaseClient } from '@supabase/supabase-js';
import { DateTime } from 'luxon';

import { trackor } from '@/lib/analytics/trackor.server';
import { captureException } from '@/lib/monitoring/sentry';
import { supabaseService } from '@/lib/supabaseServer';
import { getBaseUrl } from '@/lib/url';
import { EnqueueBody, type Channel, type EnqueueBodyInput } from '@/types/notifications';
import type {
  Database,
  NotificationDelivery,
  NotificationEvent,
  NotificationTemplate,
  NotificationsOptIn,
  Profiles,
} from '@/types/supabase';

import { sendEmail } from './email';
import { renderTemplate } from './render';
import { allowedChannels, isInQuietHours } from './rules';
import { sendWhatsApp } from './sms';

type ServiceClient = SupabaseClient<Database>;

type NotificationEventRow = NotificationEvent & { id: string };
type NotificationDeliveryRow = NotificationDelivery & { id: string };
type NotificationTemplateRow = NotificationTemplate & { id: string };

type PreferencesRow = NotificationsOptIn & { user_id: string };

type ProfileRow = Profiles & { user_id: string };

interface DispatchSummary {
  attempted: number;
  sent: number;
  deferred: number;
  failed: number;
  noop: number;
}

interface UserNotificationContext {
  preferences: Record<Channel, boolean>;
  quietHoursStart: string | null;
  quietHoursEnd: string | null;
  timezone: string;
  email: string | null;
  phone: string | null;
  fullName: string | null;
}

interface AttemptOutcome {
  attempted: boolean;
  sent: boolean;
  deferred: boolean;
  failed: boolean;
  noop: boolean;
}

export type EnqueueResult =
  | { ok: true; id: string }
  | { ok: false; reason: 'duplicate'; message?: string; id?: string }
  | { ok: false; reason: 'error'; message: string };

export interface NotificationContact {
  email: string | null;
  phone: string | null;
  fullName: string | null;
  timezone: string | null;
}

const MAX_ATTEMPTS = 3;
const RETRY_MINUTES = [15, 30, 60];

function parseChannels(raw?: string[] | null): Channel[] {
  if (!raw) return [];
  const allowed: Channel[] = [];
  for (const value of raw) {
    if (value === 'email' || value === 'whatsapp') {
      allowed.push(value);
    }
  }
  return allowed;
}

function readString(payload: Record<string, unknown>, key: string): string | null {
  const value = payload[key];
  if (typeof value === 'string') {
    const trimmed = value.trim();
    return trimmed.length > 0 ? trimmed : null;
  }
  return null;
}

function readBoolean(payload: Record<string, unknown>, key: string): boolean | null {
  const value = payload[key];
  if (typeof value === 'boolean') return value;
  if (typeof value === 'string') {
    if (value === 'true') return true;
    if (value === 'false') return false;
  }
  return null;
}

function buildSummary(): DispatchSummary {
  return { attempted: 0, sent: 0, deferred: 0, failed: 0, noop: 0 };
}

async function loadUserContext(client: ServiceClient, userId: string): Promise<UserNotificationContext> {
  const [{ data: pref }, { data: profile }] = await Promise.all([
    client
      .from('notifications_opt_in')
      .select('user_id, email_opt_in, sms_opt_in, wa_opt_in, channels, quiet_hours_start, quiet_hours_end, timezone')
      .eq('user_id', userId)
      .maybeSingle<PreferencesRow>(),
    client
      .from('profiles')
      .select('user_id, email, phone, full_name, timezone, notification_channels')
      .eq('user_id', userId)
      .maybeSingle<ProfileRow>(),
  ]);

  const prefChannels = new Set<Channel>(parseChannels((pref?.channels as string[] | null) ?? null));
  const profileChannels = new Set<string>((profile?.notification_channels ?? []) as string[]);

  if (profileChannels.has('email')) {
    prefChannels.add('email');
  }
  if (profileChannels.has('whatsapp')) {
    prefChannels.add('whatsapp');
  }

  if (pref?.wa_opt_in) {
    prefChannels.add('whatsapp');
  }
  if (pref?.email_opt_in ?? true) {
    prefChannels.add('email');
  }

  const preferences: Record<Channel, boolean> = {
    email: prefChannels.has('email'),
    whatsapp: prefChannels.has('whatsapp'),
  };

  const timezone = pref?.timezone || profile?.timezone || 'UTC';

  const email = profile?.email ? profile.email.trim() : null;
  const phone = profile?.phone ? profile.phone.trim() : null;

  return {
    preferences,
    quietHoursStart: (pref?.quiet_hours_start as string | null) ?? null,
    quietHoursEnd: (pref?.quiet_hours_end as string | null) ?? null,
    timezone,
    email: email && email.length > 0 ? email : null,
    phone: phone && phone.length > 0 ? phone : null,
    fullName: profile?.full_name ?? null,
  };
}

export async function getNotificationContact(userId: string): Promise<NotificationContact> {
  const client = supabaseService<Database>();
  const { data, error } = await client
    .from('profiles')
    .select('user_id, email, phone, full_name, timezone')
    .eq('user_id', userId)
    .maybeSingle<ProfileRow>();

  if (error && (error as PostgrestError).code !== 'PGRST116') {
    captureException(error, { scope: 'notify:getContact', userId });
  }

  let email = data?.email ? data.email.trim() : null;
  const phone = data?.phone ? data.phone.trim() : null;
  if (!email) {
    try {
      const { data: userData } = await client.auth.admin.getUserById(userId);
      email = userData.user?.email ?? null;
    } catch (adminError) {
      captureException(adminError, { scope: 'notify:getContact:admin', userId });
    }
  }

  return {
    email: email && email.length > 0 ? email : null,
    phone: phone && phone.length > 0 ? phone : null,
    fullName: data?.full_name ?? null,
    timezone: data?.timezone ?? null,
  };
}

async function getTemplate(
  client: ServiceClient,
  eventKey: string,
  channel: Channel,
  locale: string,
): Promise<NotificationTemplateRow | null> {
  const { data, error } = await client
    .from('notification_templates')
    .select('*')
    .eq('template_key', eventKey)
    .eq('channel', channel)
    .eq('locale', locale)
    .maybeSingle<NotificationTemplateRow>();

  if (error) {
    console.error('[notify:template:error]', error.message);
    return null;
  }

  if (data) return data;
  if (locale === 'en') return null;

  const fallback = await client
    .from('notification_templates')
    .select('*')
    .eq('template_key', eventKey)
    .eq('channel', channel)
    .eq('locale', 'en')
    .maybeSingle<NotificationTemplateRow>();

  if (fallback.error) {
    console.error('[notify:template:error]', fallback.error.message);
    return null;
  }

  return fallback.data ?? null;
}

async function ensureDelivery(
  client: ServiceClient,
  eventId: string,
  channel: Channel,
  templateId: string | null,
): Promise<NotificationDeliveryRow | null> {
  const { data, error } = await client
    .from('notification_deliveries')
    .insert({ event_id: eventId, channel, template_id: templateId })
    .select('*')
    .single<NotificationDeliveryRow>();

  if (!error && data) {
    return data;
  }

  if (error && (error as PostgrestError).code === '23505') {
    const existing = await client
      .from('notification_deliveries')
      .select('*')
      .eq('event_id', eventId)
      .eq('channel', channel)
      .maybeSingle<NotificationDeliveryRow>();
    if (existing.error) {
      console.error('[notify:delivery:fetch]', existing.error.message);
      return null;
    }
    const row = existing.data ?? null;
    if (row && templateId && row.template_id !== templateId) {
      await client
        .from('notification_deliveries')
        .update({ template_id: templateId })
        .eq('id', row.id);
      row.template_id = templateId;
    }
    return row;
  }

  if (error) {
    console.error('[notify:delivery:create]', error.message);
  }

  return null;
}

function mergePayload(
  event: NotificationEventRow,
  context: UserNotificationContext,
): Record<string, unknown> {
  const payload = (event.payload as Record<string, unknown>) ?? {};
  const firstName =
    readString(payload, 'first_name') ||
    readString(payload, 'firstName') ||
    (context.fullName ? context.fullName.split(' ')[0] : null);

  const baseUrl = getBaseUrl();
  const manageUrl = `${baseUrl}/settings/notifications`;
  const unsubscribeUrl = `${manageUrl}?unsubscribe=1`;

  const defaults: Record<string, unknown> = {
    manage_notifications_url: manageUrl,
    unsubscribe_url: unsubscribeUrl,
  };

  if (!('user_email' in payload) && context.email) {
    defaults.user_email = context.email;
  }
  if (!('user_phone' in payload) && context.phone) {
    defaults.user_phone = context.phone;
  }

  return {
    ...defaults,
    ...payload,
    first_name: firstName ?? '',
    full_name: context.fullName ?? '',
  };
}

async function attemptDelivery(
  client: ServiceClient,
  event: NotificationEventRow,
  delivery: NotificationDeliveryRow,
  template: NotificationTemplateRow,
  context: UserNotificationContext,
  now: DateTime,
): Promise<AttemptOutcome> {
  const payload = mergePayload(event, context);
  const bypassQuiet = Boolean(readBoolean(payload, 'bypass_quiet_hours') ?? false);
  const quiet = !bypassQuiet &&
    isInQuietHours({
      now: now.toJSDate(),
      quietHoursStart: context.quietHoursStart,
      quietHoursEnd: context.quietHoursEnd,
      timezone: context.timezone,
    });

  if (quiet) {
    const nextRetry = now.plus({ minutes: RETRY_MINUTES[0] }).toISO();
    await client
      .from('notification_deliveries')
      .update({ status: 'deferred', next_retry_at: nextRetry })
      .eq('id', delivery.id);
    return { attempted: false, sent: false, deferred: true, failed: false, noop: false };
  }

  const nowIso = now.toISO();
  let outcome: AttemptOutcome = { attempted: true, sent: false, deferred: false, failed: false, noop: false };
  let errorMessage: string | null = null;
  let noop = false;
  let metadata = delivery.metadata as Record<string, unknown> | null;
  metadata = metadata ? { ...metadata } : {};

  if (delivery.channel === 'email') {
    const to = readString(payload, 'user_email') || context.email;
    if (!to) {
      errorMessage = 'Missing email recipient';
    } else {
      const subjectTemplate = template.subject ?? '';
      const subject = renderTemplate(subjectTemplate, payload);
      const body = renderTemplate(template.body, payload);
      const html = body.replace(/\n/g, '<br />');
      const result = await sendEmail({ to, subject, text: body, html });
      noop = Boolean(result.noop);
      if (result.ok) {
        outcome = { attempted: true, sent: true, deferred: false, failed: false, noop };
        if (result.id) {
          metadata.messageId = result.id;
        }
      } else {
        errorMessage = result.error ?? 'Email send failed';
      }
    }
  } else {
    const to = readString(payload, 'user_phone') || context.phone;
    if (!to) {
      errorMessage = 'Missing WhatsApp recipient';
    } else {
      const body = renderTemplate(template.body, payload);
      const result = await sendWhatsApp({ to, body });
      noop = Boolean(result.noop);
      if (result.ok) {
        outcome = { attempted: true, sent: true, deferred: false, failed: false, noop };
        if (result.id) {
          metadata.messageSid = result.id;
        }
      } else {
        errorMessage = result.error ?? 'WhatsApp send failed';
      }
    }
  }

  const attempts = delivery.attempt_count + 1;
  const update: Partial<NotificationDeliveryRow> = {
    attempt_count: attempts,
    last_attempt_at: nowIso,
    metadata,
  };

  if (!errorMessage) {
    update.status = 'sent';
    update.sent_at = nowIso;
    update.error = null;
    update.next_retry_at = null;
  } else if (attempts >= MAX_ATTEMPTS) {
    update.status = 'failed';
    update.error = errorMessage;
    update.next_retry_at = null;
    outcome = { attempted: true, sent: false, deferred: false, failed: true, noop: false };
  } else {
    const delayMinutes = RETRY_MINUTES[Math.min(attempts, RETRY_MINUTES.length) - 1];
    update.status = 'deferred';
    update.error = errorMessage;
    update.next_retry_at = now.plus({ minutes: delayMinutes }).toISO();
    outcome = { attempted: true, sent: false, deferred: true, failed: false, noop: false };
  }

  await client
    .from('notification_deliveries')
    .update(update)
    .eq('id', delivery.id);

  if (outcome.sent) {
    await trackor.log('delivery_sent', {
      eventId: event.id,
      deliveryId: delivery.id,
      userId: event.user_id,
      channel: delivery.channel,
      attempts,
      noop,
    });
  } else if (outcome.failed) {
    await trackor.log('delivery_failed', {
      eventId: event.id,
      deliveryId: delivery.id,
      userId: event.user_id,
      channel: delivery.channel,
      attempts,
      error: errorMessage ?? update.error ?? null,
    });
  }

  return outcome;
}

async function processEvent(
  client: ServiceClient,
  event: NotificationEventRow,
  now: DateTime,
): Promise<DispatchSummary> {
  const summary = buildSummary();
  try {
    const context = await loadUserContext(client, event.user_id);
    const requestedChannels = parseChannels((event.requested_channels as string[] | null) ?? null);
    const payload = (event.payload as Record<string, unknown>) ?? {};
    const bypassQuiet = readBoolean(payload, 'bypass_quiet_hours') ?? false;

    const quiet = !bypassQuiet &&
      isInQuietHours({
        now: now.toJSDate(),
        quietHoursStart: context.quietHoursStart,
        quietHoursEnd: context.quietHoursEnd,
        timezone: context.timezone,
      });

    const allowed = allowedChannels({
      preferences: context.preferences,
      requestedChannels,
      quiet,
      quietOverrides: bypassQuiet ? requestedChannels : [],
    });

    if (allowed.length === 0) {
      await client
        .from('notification_events')
        .update({ processed_at: now.toISO(), error: 'No channels allowed' })
        .eq('id', event.id);
      return summary;
    }

    for (const channel of allowed) {
      const template = await getTemplate(client, event.event_key, channel, event.locale ?? 'en');
      const delivery = await ensureDelivery(client, event.id, channel, template?.id ?? null);

      if (!delivery) {
        summary.failed += 1;
        summary.attempted += 1;
        continue;
      }

      if (!template) {
        const attempts = delivery.attempt_count + 1;
        await client
          .from('notification_deliveries')
          .update({
            status: 'failed',
            error: `Template not found for ${event.event_key}/${channel}`,
            next_retry_at: null,
            last_attempt_at: now.toISO(),
          })
          .eq('id', delivery.id);
        await trackor.log('delivery_failed', {
          eventId: event.id,
          deliveryId: delivery.id,
          userId: event.user_id,
          channel,
          attempts,
          error: `Template not found for ${event.event_key}/${channel}`,
        });
        summary.failed += 1;
        summary.attempted += 1;
        continue;
      }

      const outcome = await attemptDelivery(client, event, delivery, template, context, now);
      if (outcome.attempted) {
        summary.attempted += 1;
      }
      if (outcome.sent) {
        summary.sent += 1;
      }
      if (outcome.deferred) {
        summary.deferred += 1;
      }
      if (outcome.failed) {
        summary.failed += 1;
      }
      if (outcome.noop) {
        summary.noop += 1;
      }
    }

    await client
      .from('notification_events')
      .update({ processed_at: now.toISO(), error: null })
      .eq('id', event.id);
  } catch (error) {
    captureException(error, { scope: 'notify:dispatch:event', eventId: event.id });
    const message = error instanceof Error ? error.message : 'Unknown dispatcher error';
    await client
      .from('notification_events')
      .update({ processed_at: now.toISO(), error: message })
      .eq('id', event.id);
    summary.failed += 1;
  }

  return summary;
}

async function processDelivery(
  client: ServiceClient,
  delivery: NotificationDeliveryRow,
  now: DateTime,
): Promise<DispatchSummary> {
  const summary = buildSummary();
  const { data: event, error } = await client
    .from('notification_events')
    .select('*')
    .eq('id', delivery.event_id)
    .maybeSingle<NotificationEventRow>();

  if (error) {
    captureException(error, { scope: 'notify:delivery:event', deliveryId: delivery.id });
    return summary;
  }

  if (!event) {
    await client
      .from('notification_deliveries')
      .update({ status: 'failed', error: 'Event missing', next_retry_at: null })
      .eq('id', delivery.id);
    await trackor.log('delivery_failed', {
      eventId: delivery.event_id,
      deliveryId: delivery.id,
      userId: null,
      channel: delivery.channel,
      attempts: delivery.attempt_count + 1,
      error: 'Event missing',
    });
    summary.failed += 1;
    summary.attempted += 1;
    return summary;
  }

  const template = await getTemplate(client, event.event_key, delivery.channel as Channel, event.locale ?? 'en');
  if (!template) {
    await client
      .from('notification_deliveries')
      .update({
        status: 'failed',
        error: `Template not found for ${event.event_key}/${delivery.channel}`,
        next_retry_at: null,
        last_attempt_at: now.toISO(),
      })
      .eq('id', delivery.id);
    await trackor.log('delivery_failed', {
      eventId: event.id,
      deliveryId: delivery.id,
      userId: event.user_id,
      channel: delivery.channel,
      attempts: delivery.attempt_count + 1,
      error: `Template not found for ${event.event_key}/${delivery.channel}`,
    });
    summary.failed += 1;
    summary.attempted += 1;
    return summary;
  }

  const context = await loadUserContext(client, event.user_id);
  const outcome = await attemptDelivery(client, event, delivery, template, context, now);

  if (outcome.attempted) summary.attempted += 1;
  if (outcome.sent) summary.sent += 1;
  if (outcome.deferred) summary.deferred += 1;
  if (outcome.failed) summary.failed += 1;
  if (outcome.noop) summary.noop += 1;

  return summary;
}

async function insertEvent(payload: EnqueueBodyInput): Promise<EnqueueResult> {
  const service = supabaseService<Database>();
  const insertPayload = {
    user_id: payload.user_id,
    event_key: payload.event_key,
    locale: payload.locale ?? 'en',
    payload: payload.payload ?? {},
    requested_channels: payload.channels ?? [],
    idempotency_key: payload.idempotency_key ?? null,
  };

  const { data, error } = await service
    .from('notification_events')
    .insert(insertPayload)
    .select('id')
    .single<{ id: string }>();

  if (error) {
    const code = (error as PostgrestError).code;
    if (code === '23505') {
      let existingId: string | undefined;
      if (payload.idempotency_key) {
        const { data: existing } = await service
          .from('notification_events')
          .select('id')
          .eq('idempotency_key', payload.idempotency_key)
          .maybeSingle<{ id: string }>();
        existingId = existing?.id;
      }
      return { ok: false, reason: 'duplicate', message: 'Event already enqueued', id: existingId };
    }

    captureException(error, {
      scope: 'notify:enqueue',
      eventKey: payload.event_key,
      userId: payload.user_id,
    });
    return { ok: false, reason: 'error', message: error.message };
  }

  await trackor.log('notification_enqueued', {
    eventKey: payload.event_key,
    userId: payload.user_id,
    id: data.id,
    channels: payload.channels ?? [],
    locale: payload.locale ?? 'en',
  });

  return { ok: true, id: data.id };
}

export async function enqueueEvent(
  _req: NextApiRequest,
  res: NextApiResponse,
  body: unknown,
) {
  const parsed = EnqueueBody.safeParse(body);
  if (!parsed.success) {
    return res.status(400).json({ error: 'Invalid payload', details: parsed.error.flatten() });
  }

  const result = await insertEvent(parsed.data);

  if (result.ok) {
    return res.status(200).json({ id: result.id });
  }

  if (result.reason === 'duplicate') {
    return res
      .status(409)
      .json({ error: result.message ?? 'Event already enqueued', id: result.id });
  }

  return res.status(500).json({ error: result.message });
}

export async function queueNotificationEvent(payload: EnqueueBodyInput): Promise<EnqueueResult> {
  const parsed = EnqueueBody.parse(payload);
  return insertEvent(parsed);
}

export async function dispatchPending(
  _req: NextApiRequest,
  res: NextApiResponse,
) {
  const service = supabaseService<Database>();
  const now = DateTime.utc();
  const summary = {
    eventsProcessed: 0,
    deliveriesAttempted: 0,
    deliveriesSent: 0,
    deliveriesDeferred: 0,
    deliveriesFailed: 0,
    deliveriesNoop: 0,
  };

  const { data: events, error: eventError } = await service
    .from('notification_events')
    .select('*')
    .is('processed_at', null)
    .order('created_at', { ascending: true })
    .limit(20);

  if (eventError) {
    return res.status(500).json({ error: eventError.message });
  }

  if (events) {
    for (const event of events as NotificationEventRow[]) {
      summary.eventsProcessed += 1;
      const result = await processEvent(service, event, now);
      summary.deliveriesAttempted += result.attempted;
      summary.deliveriesSent += result.sent;
      summary.deliveriesDeferred += result.deferred;
      summary.deliveriesFailed += result.failed;
      summary.deliveriesNoop += result.noop;
    }
  }

  const { data: deliveries, error: deliveriesError } = await service
    .from('notification_deliveries')
    .select('*')
    .in('status', ['pending', 'deferred'])
    .order('created_at', { ascending: true })
    .limit(25);

  if (deliveriesError) {
    return res.status(500).json({ error: deliveriesError.message });
  }

  if (deliveries) {
    for (const delivery of deliveries as NotificationDeliveryRow[]) {
      if (delivery.status === 'deferred' && delivery.next_retry_at) {
        const retry = DateTime.fromISO(delivery.next_retry_at);
        if (retry.isValid && retry > now) {
          continue;
        }
      }

      const result = await processDelivery(service, delivery, now);
      summary.deliveriesAttempted += result.attempted;
      summary.deliveriesSent += result.sent;
      summary.deliveriesDeferred += result.deferred;
      summary.deliveriesFailed += result.failed;
      summary.deliveriesNoop += result.noop;
    }
  }

  return res.status(200).json({ ok: true, summary });
}





============================================================
FILE #63
PATH: lib/notify/rules.ts
============================================================
import { DateTime } from 'luxon';

import type { Channel } from '@/types/notifications';

export interface QuietHoursInput {
  now?: Date;
  quietHoursStart?: string | null;
  quietHoursEnd?: string | null;
  timezone?: string | null;
}

function parseTimeFragment(value?: string | null, zone = 'UTC') {
  if (!value) return null;
  const format = value.length === 8 ? 'HH:mm:ss' : 'HH:mm';
  const parsed = DateTime.fromFormat(value, format, { zone });
  return parsed.isValid ? parsed : null;
}

export function isInQuietHours({
  now = new Date(),
  quietHoursStart,
  quietHoursEnd,
  timezone = 'UTC',
}: QuietHoursInput): boolean {
  if (!quietHoursStart || !quietHoursEnd) {
    return false;
  }

  const zone = timezone || 'UTC';
  const current = DateTime.fromJSDate(now).setZone(zone);
  if (!current.isValid) {
    return false;
  }

  const startTime = parseTimeFragment(quietHoursStart, zone);
  const endTime = parseTimeFragment(quietHoursEnd, zone);

  if (!startTime || !endTime) {
    return false;
  }

  const currentSeconds = current.hour * 3600 + current.minute * 60 + current.second;
  const startSeconds = startTime.hour * 3600 + startTime.minute * 60 + startTime.second;
  const endSeconds = endTime.hour * 3600 + endTime.minute * 60 + endTime.second;

  if (startSeconds === endSeconds) {
    return false;
  }

  if (startSeconds < endSeconds) {
    return currentSeconds >= startSeconds && currentSeconds < endSeconds;
  }

  return currentSeconds >= startSeconds || currentSeconds < endSeconds;
}

export interface AllowedChannelsInput {
  preferences: Partial<Record<Channel, boolean>>;
  requestedChannels?: Channel[] | null;
  quiet?: boolean;
  quietOverrides?: Channel[];
}

export function allowedChannels({
  preferences,
  requestedChannels,
  quiet = false,
  quietOverrides = [],
}: AllowedChannelsInput): Channel[] {
  const enabled = new Set<Channel>();
  const baseChannels = requestedChannels && requestedChannels.length > 0
    ? requestedChannels
    : (Object.keys(preferences) as Channel[]);

  const quietAllowed = quiet ? new Set<Channel>(quietOverrides) : null;

  for (const channel of baseChannels) {
    if (!preferences[channel]) continue;
    if (quiet && quietAllowed && !quietAllowed.has(channel)) {
      continue;
    }
    enabled.add(channel);
  }

  if (quiet && quietAllowed && quietAllowed.size === 0) {
    return [];
  }

  return Array.from(enabled.values());
}





============================================================
FILE #64
PATH: lib/notify/email.ts
============================================================
import nodemailer from 'nodemailer';

import { captureException } from '@/lib/monitoring/sentry';

export interface EmailPayload {
  to: string;
  subject: string;
  text: string;
  html?: string;
}

export interface EmailResult {
  ok: boolean;
  noop?: boolean;
  id?: string;
  error?: string;
}

function resolveConfig() {
  const host = process.env.SMTP_HOST;
  const port = process.env.SMTP_PORT ? Number(process.env.SMTP_PORT) : undefined;
  const user = process.env.SMTP_USER;
  const pass = process.env.SMTP_PASS;
  const fromEmail = process.env.SMTP_FROM_EMAIL;
  const fromName = process.env.SMTP_FROM_NAME ?? 'GramorX';

  if (!host || !port || !user || !pass || !fromEmail) {
    return null;
  }

  return {
    host,
    port,
    auth: { user, pass },
    from: `${fromName} <${fromEmail}>`,
  } as const;
}

export async function sendEmail(payload: EmailPayload): Promise<EmailResult> {
  const config = resolveConfig();

  if (!config) {
    console.info('[email:noop]', { to: payload.to, subject: payload.subject });
    return { ok: true, noop: true };
  }

  try {
    const transporter = nodemailer.createTransport({
      host: config.host,
      port: config.port,
      secure: config.port === 465,
      auth: config.auth,
    });

    const info = await transporter.sendMail({
      from: config.from,
      to: payload.to,
      subject: payload.subject,
      text: payload.text,
      html: payload.html,
    });

    return { ok: true, id: info.messageId };
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown SMTP error';
    console.error('[email:error]', message);
    captureException(error, { scope: 'notify:email', to: payload.to });
    return { ok: false, error: message };
  }
}





============================================================
FILE #65
PATH: lib/notify/sms.ts
============================================================
import twilio from 'twilio';

import { captureException } from '@/lib/monitoring/sentry';

export interface WhatsAppPayload {
  to: string;
  body: string;
  mediaUrl?: string;
}

export interface WhatsAppResult {
  ok: boolean;
  noop?: boolean;
  id?: string;
  error?: string;
}

function resolveCredentials() {
  const bypass = process.env.TWILIO_BYPASS === '1' || process.env.TWILIO_BYPASS === 'true';
  const accountSid = process.env.TWILIO_ACCOUNT_SID;
  const authToken = process.env.TWILIO_AUTH_TOKEN;
  const fromNumber = process.env.TWILIO_WHATSAPP_FROM;

  if (bypass || !accountSid || !authToken || !fromNumber) {
    return null;
  }

  return { accountSid, authToken, fromNumber } as const;
}

export async function sendWhatsApp(payload: WhatsAppPayload): Promise<WhatsAppResult> {
  const credentials = resolveCredentials();

  if (!credentials) {
    console.info('[wa:noop]', { to: payload.to });
    return { ok: true, noop: true };
  }

  try {
    const client = twilio(credentials.accountSid, credentials.authToken);
    const message = await client.messages.create({
      from: `whatsapp:${credentials.fromNumber}`,
      to: payload.to.startsWith('whatsapp:') ? payload.to : `whatsapp:${payload.to}`,
      body: payload.body,
      mediaUrl: payload.mediaUrl ? [payload.mediaUrl] : undefined,
    });

    return { ok: true, id: message.sid };
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown Twilio error';
    console.error('[wa:error]', message);
    captureException(error, { scope: 'notify:whatsapp', to: payload.to });
    return { ok: false, error: message };
  }
}





============================================================
FILE #66
PATH: pages/api/payments/create-intent.ts
============================================================
// pages/api/payments/create-intent.ts
import type { NextApiHandler, NextApiRequest } from 'next';
import { z } from 'zod';

import { createSupabaseServerClient } from '@/lib/supabaseServer';
import { supabaseService } from '@/lib/supabaseService';
import { trackor } from '@/lib/analytics/trackor.server';
import { createGatewayIntent, amountInCents, type PaymentProvider } from '@/lib/payments/gateway';
import { createPendingPayment } from '@/lib/billing/manual';
import type { Cycle, PlanKey } from '@/lib/pricing';
import { queueNotificationEvent, getNotificationContact, type NotificationContact } from '@/lib/notify';
import { getBaseUrl } from '@/lib/url';

const providers: PaymentProvider[] = ['stripe', 'easypaisa', 'jazzcash', 'safepay', 'crypto'];

const Body = z.object({
  plan: z.enum(['starter', 'booster', 'master']).default('booster'),
  cycle: z.enum(['monthly', 'annual']).optional(),
  // Back-compat for old client param name
  billingCycle: z.enum(['monthly', 'annual']).optional(),
  provider: z.enum(providers as [PaymentProvider, ...PaymentProvider[]]).optional(),
  referralCode: z.string().max(64).optional(),
  promoCode: z.string().max(64).optional(),
});

const getOrigin = (req: NextApiRequest) => {
  const proto = (req.headers['x-forwarded-proto'] as string) || 'https';
  const host = (req.headers['x-forwarded-host'] as string) || req.headers.host || 'localhost:3000';
  return `${proto}://${host}`;
};

// Provider â†’ default currency map (expand later if you add multi-currency prices)
const PROVIDER_DEFAULT_CURRENCY: Record<PaymentProvider, 'USD' | 'PKR'> = {
  stripe: 'USD',
  easypaisa: 'PKR',
  jazzcash: 'PKR',
  safepay: 'PKR',
  crypto: 'USD',
};

type SuccessRedirect = Readonly<{ ok: true; provider: PaymentProvider; url: string; sessionId?: string | null }>;
type SuccessManual = Readonly<{ ok: true; manual: true; message: string }>;
type Failure = Readonly<{ ok: false; error: string; details?: unknown }>;
type ResBody = SuccessRedirect | SuccessManual | Failure;

const handler: NextApiHandler<ResBody> = async (req, res) => {
  if (req.method !== 'POST') {
    return res.status(405).json({ ok: false, error: 'Method Not Allowed' });
  }

  // Validate input strictly
  const parsed = Body.safeParse(req.body ?? {});
  if (!parsed.success) {
    return res.status(400).json({ ok: false, error: 'Invalid body', details: parsed.error.flatten() });
  }

  const body = parsed.data;
  const plan: PlanKey = body.plan;
  const cycle: Cycle = (body.cycle ?? body.billingCycle ?? 'monthly') as Cycle;
  const provider: PaymentProvider = (body.provider ?? 'stripe') as PaymentProvider;
  const referralCode = body.referralCode;
  const promoCode = body.promoCode;

  const supabase = createSupabaseServerClient({ req, res });
  const { data: auth } = await supabase.auth.getUser();
  const userId = auth.user?.id;
  const userEmail = auth.user?.email ?? null;
  if (!userId) return res.status(401).json({ ok: false, error: 'Unauthorized' });

  const { data: profileRow } = await supabaseService
    .from('profiles')
    .select('full_name')
    .eq('id', userId)
    .maybeSingle();

  const customerName = typeof profileRow?.full_name === 'string' ? profileRow.full_name : null;

  const origin = getOrigin(req);
  const baseUrl = getBaseUrl();

  // Choose currency by provider (donâ€™t accept arbitrary currency from client)
  const currency = PROVIDER_DEFAULT_CURRENCY[provider];

  // Price sanity
  const amountCents = amountInCents(plan, cycle);
  if (!Number.isFinite(amountCents) || amountCents <= 0) {
    return res.status(400).json({ ok: false, error: 'invalid_amount' });
  }

  // Create DB intent first (traceability & idempotency)
  const { data: intentRow, error: insertErr } = await supabaseService
    .from('payment_intents')
    .insert({
      user_id: userId,
      plan_id: plan,
      cycle,
      provider,
      amount_cents: amountCents,
      currency,
      status: 'pending',
      metadata: { referralCode, promoCode },
    })
    .select('id')
    .single();

  if (insertErr || !intentRow) {
    console.error('[payments] insert payment_intents failed', insertErr);
    return res.status(500).json({ ok: false, error: 'intent_create_failed', details: insertErr?.message ?? insertErr });
  }

  const intentId = intentRow.id as string;
  const nowIso = new Date().toISOString();

  let contactPromise: Promise<NotificationContact> | null = null;
  const ensureContact = () => (contactPromise ??= getNotificationContact(userId));

  const notify = async (eventKey: 'payment_success' | 'payment_failed', reason?: string) => {
    const contact = await ensureContact();
    if (!contact.email) return;

    const payload: Record<string, unknown> = {
      plan,
      cycle,
      provider,
      deep_link: `${baseUrl}/settings/billing`,
      user_email: contact.email,
    };
    if (contact.phone) payload.user_phone = contact.phone;
    if (reason) payload.reason = reason;

    const result = await queueNotificationEvent({
      event_key: eventKey,
      user_id: userId,
      payload,
      channels: ['email'],
      idempotency_key: `${eventKey}:${intentId}`,
    });
    if (!result.ok && result.reason !== 'duplicate') {
      console.error('[payments:notify]', eventKey, result.message);
    }
  };

  await supabaseService.from('payment_intent_events').insert({
    intent_id: intentId,
    user_id: userId,
    event: 'created',
    payload: { provider, plan, cycle, referralCode, promoCode, currency, amount_cents: amountCents },
  });

  await trackor.log('payments.intent.create', { userId, intentId, provider, plan, cycle, currency, amountCents });

  try {
    // Create the gateway intent/session
    const gateway = await createGatewayIntent({
      provider,
      plan,
      cycle,
      origin,
      userId,
      referralCode,
      promoCode,
      amountCents,
      currency, // <- important for Stripe (and future multi-currency support)
      intentId,
      customerEmail: userEmail,
      customerName,
    });

    await supabaseService
      .from('payment_intents')
      .update({
        status: provider === 'stripe' ? 'requires_payment_method' : 'pending_confirmation',
        gateway_session_id: gateway.sessionId ?? null,
        updated_at: nowIso,
      })
      .eq('id', intentId);

    await supabaseService.from('payment_intent_events').insert({
      intent_id: intentId,
      user_id: userId,
      event: 'gateway.created',
      payload: { url: gateway.url, sessionId: gateway.sessionId ?? null, promoCode, currency },
    });

    return res.status(200).json({ ok: true, provider, url: gateway.url, sessionId: gateway.sessionId ?? null });
  } catch (error) {
    const message = (error as Error)?.message || 'gateway_error';

    // If Stripe is not configured, fall back to manual activation (your existing path)
    if (provider === 'stripe' && message === 'Stripe not configured') {
      try {
        const { amount_cents, currency: manualCurrency } = await createPendingPayment({
          userId,
          email: userEmail,
          plan,
          cycle,
          note: 'Manual fallback via /api/payments/create-intent',
        });

        const confirmedAt = new Date().toISOString();

        await supabaseService
          .from('payment_intents')
          .update({
            status: 'manual',
            confirmed_at: confirmedAt,
            updated_at: confirmedAt,
            metadata: { referralCode, promoCode, manual: true },
          })
          .eq('id', intentId);

        await supabaseService.from('payment_intent_events').insert({
          intent_id: intentId,
          user_id: userId,
          event: 'manual.provisioned',
          payload: { amount_cents, currency: manualCurrency },
        });

        await trackor.log('payments.intent.success', {
          userId,
          intentId,
          provider: 'manual',
          plan,
          cycle,
        });

        await notify('payment_success');

        return res.status(200).json({
          ok: true,
          manual: true,
          message: 'Subscription activated. Your payment will be collected offline and has been marked as due.',
        });
      } catch (manualErr) {
        await supabaseService
          .from('payment_intents')
          .update({
            status: 'failed',
            failure_message: (manualErr as Error).message,
            updated_at: new Date().toISOString(),
          })
          .eq('id', intentId);

        await supabaseService.from('payment_intent_events').insert({
          intent_id: intentId,
          user_id: userId,
          event: 'manual.error',
          payload: { message: (manualErr as Error).message },
        });

        await notify('payment_failed', (manualErr as Error).message);
        return res.status(500).json({ ok: false, error: 'manual_fallback_failed' });
      }
    }

    // Regular gateway failure
    console.error('[payments] gateway error', { provider, message, plan, cycle, currency });
    await supabaseService
      .from('payment_intents')
      .update({ status: 'failed', failure_message: message, updated_at: new Date().toISOString() })
      .eq('id', intentId);

    await supabaseService.from('payment_intent_events').insert({
      intent_id: intentId,
      user_id: userId,
      event: 'gateway.error',
      payload: { message, provider, currency },
    });

    await notify('payment_failed', message);
    return res.status(500).json({ ok: false, error: message });
  }
};

export default handler;





============================================================
FILE #67
PATH: pages/api/payments/create-checkout-session.ts
============================================================
// pages/api/payments/create-checkout-session.ts
import type { NextApiHandler, NextApiRequest, NextApiResponse } from 'next';
import { createSupabaseServerClient } from '@/lib/supabaseServer';
import { env } from '@/lib/env';
import { createClient as createSbClient } from '@supabase/supabase-js';
import { getPlanBillingAmount, type Cycle, type PlanKey } from '@/lib/pricing';

type CreateCheckoutBody = Readonly<{
  plan: PlanKey;
  referralCode?: string;
  billingCycle?: Cycle;
}>;

type Success = Readonly<{ ok: true; url?: string; sessionId?: string; manual?: boolean; message?: string }>;
type Failure = Readonly<{ ok: false; error: string }>;
type ResBody = Success | Failure;

// ---- Helpers ----
const isPlan = (v: unknown): v is PlanKey =>
  typeof v === 'string' && ['starter', 'booster', 'master'].includes(v);
const isCycle = (v: unknown): v is Cycle =>
  typeof v === 'string' && ['monthly', 'annual'].includes(v);

const getOrigin = (req: NextApiRequest) => {
  const proto = (req.headers['x-forwarded-proto'] as string) || 'https';
  const host = (req.headers['x-forwarded-host'] as string) || req.headers.host || 'localhost:3000';
  return `${proto}://${host}`;
};

// Stripe Price IDs from env (USD prices)
const priceMap: Record<PlanKey, Record<Cycle, string | undefined>> = {
  starter: {
    monthly: env.STRIPE_PRICE_STARTER_MONTHLY,
    annual: env.STRIPE_PRICE_STARTER_ANNUAL,
  },
  booster: {
    monthly: env.STRIPE_PRICE_BOOSTER_MONTHLY,
    annual: env.STRIPE_PRICE_BOOSTER_ANNUAL,
  },
  master: {
    monthly: env.STRIPE_PRICE_MASTER_MONTHLY,
    annual: env.STRIPE_PRICE_MASTER_ANNUAL,
  },
};

const methodNotAllowed = (res: NextApiResponse<ResBody>) =>
  res.status(405).json({ ok: false, error: 'method_not_allowed' });
const badRequest = (res: NextApiResponse<ResBody>, msg: string) =>
  res.status(400).json({ ok: false, error: msg });

/** Attempt to write a pending due and provision the plan.
 * Uses service role if available; otherwise tries with the user-scoped client.
 * Fails gracefully (returns void).
 */
async function provisionManually(opts: {
  userId: string;
  plan: PlanKey;
  cycle: Cycle;
  userEmail?: string | null;
}) {
  const amountMajor = getPlanBillingAmount(opts.plan, opts.cycle);
  const amount_cents = Math.round(amountMajor * 100);
  const currency = 'USD';

  // Prefer service role for server-side writes
  const adminKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL!;
  const admin = adminKey ? createSbClient(url, adminKey, { auth: { persistSession: false } }) : null;

  const upsertClient = admin ?? createSupabaseServerClient({} as { req: NextApiRequest });

  // Insert pending due (ignore failure)
  try {
    await upsertClient
      .from('pending_payments')
      .insert({
        user_id: opts.userId,
        plan_key: opts.plan,
        cycle: opts.cycle,
        currency,
        amount_cents,
        status: 'due',
        note: 'Manual fallback: gateway unavailable',
        email: opts.userEmail ?? null,
      });
  } catch {
    // ignore
  }

  // Provision plan immediately (ignore failure if RLS blocks)
  try {
    await upsertClient
      .from('profiles')
      .update({ plan_id: opts.plan })
      .eq('id', opts.userId);
  } catch {
    // ignore
  }
}

// ---- Handler ----
const handler: NextApiHandler<ResBody> = async (req, res) => {
  if (req.method !== 'POST') return methodNotAllowed(res);

  // Body validation
  const body = req.body as Partial<CreateCheckoutBody> | undefined;
  if (!body) return badRequest(res, 'missing_body');
  const plan = isPlan(body.plan) ? body.plan : 'booster';
  const billingCycle = isCycle(body.billingCycle) ? body.billingCycle : 'monthly';
  const referralCode = typeof body.referralCode === 'string' ? body.referralCode.slice(0, 64) : undefined;

  // Auth (user id for metadata / customer lookup)
  const supabase = createSupabaseServerClient({ req });
  const { data: userResp } = await supabase.auth.getUser();
  const userId = userResp.user?.id || '';
  const userEmail = userResp.user?.email ?? null;

  if (!userId) {
    return res.status(401).json({ ok: false, error: 'unauthorized' });
  }

  const priceId = priceMap[plan][billingCycle];

  // If Stripe is not configured â†’ manual fallback (create pending due + provision plan)
  if (!env.STRIPE_SECRET_KEY || !priceId) {
    try {
      await provisionManually({ userId, plan, cycle: billingCycle, userEmail });
      return res.status(200).json({
        ok: true,
        manual: true,
        message:
          'Subscription activated. Your card was NOT charged; amount is marked as due. We will notify you before retrying payment.',
      });
    } catch (e) {
      const msg = (e as Error)?.message || 'manual_fallback_failed';
      return res.status(500).json({ ok: false, error: msg });
    }
  }

  // Stripe runtime load (avoid hard build dep if not installed yet)
  // @ts-expect-error TODO: add `stripe` to dependencies for full types
  const Stripe = (await import('stripe')).default ?? (await import('stripe'));
  const stripe = new Stripe(env.STRIPE_SECRET_KEY, { apiVersion: '2024-06-20' });

  const origin = getOrigin(req);
  const success_url = `${origin}/account/billing?success=1&plan=${plan}`;
  const cancel_url = `${origin}/pricing?canceled=1&plan=${plan}${referralCode ? `&code=${encodeURIComponent(referralCode)}` : ''}`;

  try {
    const session = await stripe.checkout.sessions.create(
      {
        mode: 'subscription',
        success_url,
        cancel_url,
        line_items: [{ price: priceId, quantity: 1 }],
        allow_promotion_codes: true,
        client_reference_id: userId,
        metadata: {
          plan,
          billingCycle,
          referralCode: referralCode || '',
          userId,
        },
        subscription_data: {
          metadata: {
            plan,
            billingCycle,
            referralCode: referralCode || '',
            userId, // â† critical for webhook backfill
          },
        },
      },
      {
        idempotencyKey:
          (req.headers['x-idempotency-key'] as string) || `${userId}:${plan}:${billingCycle}`,
      }
    );

    return res.status(200).json({ ok: true, url: session.url ?? success_url, sessionId: session.id });
  } catch (err) {
    const msg = (err as Error)?.message || 'stripe_error';
    return res.status(500).json({ ok: false, error: msg });
  }
};

export default handler;





============================================================
FILE #68
PATH: lib/navigation/types.ts
============================================================
// lib/navigation/types.ts
import type { IconName } from '@/components/design-system/Icon';
import type { FeatureToggleKey } from '@/lib/constants/features';
import type { FeatureFlagKey } from '@/lib/flags';

export type SubscriptionTier = 'free' | 'seedling' | 'rocket' | 'owl';

export const TIER_ORDER: readonly SubscriptionTier[] = ['free', 'seedling', 'rocket', 'owl'] as const;

export type FeatureGate = {
  /** Optional Supabase-authenticated requirement */
  requiresAuth?: boolean;
  /** Minimum subscription tier required to see this item */
  minTier?: SubscriptionTier;
  /** Legacy feature flag keys backed by lib/flags */
  flag?: FeatureFlagKey;
  /** Config-driven toggle, see lib/constants/features */
  featureToggle?: FeatureToggleKey;
};

export type NavItemConfig = {
  id: string;
  label: string;
  href: string;
  description?: string;
  icon?: IconName;
  badge?: string;
  external?: boolean;
  kbd?: string;
  target?: string;
  tier?: SubscriptionTier;
  featureGate?: FeatureGate;
};

export type NavSectionConfig = {
  id: string;
  label: string;
  description?: string;
  icon?: IconName;
  badge?: string;
  featureGate?: FeatureGate;
  items: NavItemConfig[];
};

type HeaderCtaItem = { label: string; href: string };

export type HeaderNavigationSchema = {
  main: NavItemConfig[];
  aiTools: NavItemConfig[];
  profile: NavItemConfig[];
  cta?: {
    guest?: HeaderCtaItem | null;
    authed?: HeaderCtaItem | null;
  };
  optional?: {
    themeToggle?: boolean;
    localeSwitch?: boolean;
    notifications?: boolean;
  };
};

export type FooterNavigationSchema = NavSectionConfig[];

export type FloatingNavigationSchema = {
  quickActions: NavItemConfig[];
};

export type AppNavigationSchema = {
  header: HeaderNavigationSchema;
  sidebar: NavSectionConfig[];
  footer: FooterNavigationSchema;
  floating: FloatingNavigationSchema;
};

export type NavigationContext = {
  isAuthenticated: boolean;
  tier: SubscriptionTier;
};





============================================================
FILE #69
PATH: lib/plan/gates.ts
============================================================
// lib/plan/gates.ts
// Declarative feature limits per subscription tier.

import { PLANS, type PlanId } from '@/types/pricing';

type WritingGateConfig = {
  aiEvaluationsPerDay: number;
  mockStartsPerDay: number;
  storageGB: number;
  exportPdf: boolean;
  certificateAccess: boolean;
  xpDailyCap: number;
  installPrompt: boolean;
  pushNotifications: boolean;
};

type AdminGateConfig = {
  healthDashboard: boolean;
  canImpersonate: boolean;
};

type AnalyticsGateConfig = {
  advancedWriting: boolean;
  perfBudgets: boolean;
};

type PlanGateConfig = {
  writing: WritingGateConfig;
  analytics: AnalyticsGateConfig;
  admin: AdminGateConfig;
};

const PLAN_GATES: Record<PlanId, PlanGateConfig> = {
  free: {
    writing: {
      aiEvaluationsPerDay: PLANS.free.quota.aiEvaluationsPerDay,
      mockStartsPerDay: PLANS.free.quota.dailyMocks,
      storageGB: PLANS.free.quota.storageGB,
      exportPdf: false,
      certificateAccess: false,
      xpDailyCap: 120,
      installPrompt: false,
      pushNotifications: false,
    },
    analytics: {
      advancedWriting: false,
      perfBudgets: false,
    },
    admin: {
      healthDashboard: false,
      canImpersonate: false,
    },
  },
  starter: {
    writing: {
      aiEvaluationsPerDay: PLANS.starter.quota.aiEvaluationsPerDay,
      mockStartsPerDay: PLANS.starter.quota.dailyMocks,
      storageGB: PLANS.starter.quota.storageGB,
      exportPdf: false,
      certificateAccess: false,
      xpDailyCap: 200,
      installPrompt: true,
      pushNotifications: true,
    },
    analytics: {
      advancedWriting: true,
      perfBudgets: false,
    },
    admin: {
      healthDashboard: false,
      canImpersonate: false,
    },
  },
  booster: {
    writing: {
      aiEvaluationsPerDay: PLANS.booster.quota.aiEvaluationsPerDay,
      mockStartsPerDay: PLANS.booster.quota.dailyMocks,
      storageGB: PLANS.booster.quota.storageGB,
      exportPdf: true,
      certificateAccess: true,
      xpDailyCap: 320,
      installPrompt: true,
      pushNotifications: true,
    },
    analytics: {
      advancedWriting: true,
      perfBudgets: true,
    },
    admin: {
      healthDashboard: true,
      canImpersonate: true,
    },
  },
  master: {
    writing: {
      aiEvaluationsPerDay: PLANS.master.quota.aiEvaluationsPerDay,
      mockStartsPerDay: PLANS.master.quota.dailyMocks,
      storageGB: PLANS.master.quota.storageGB,
      exportPdf: true,
      certificateAccess: true,
      xpDailyCap: 420,
      installPrompt: true,
      pushNotifications: true,
    },
    analytics: {
      advancedWriting: true,
      perfBudgets: true,
    },
    admin: {
      healthDashboard: true,
      canImpersonate: true,
    },
  },
};

export type PlanGateKey =
  | 'writing.export.pdf'
  | 'writing.certificate'
  | 'writing.ai.daily'
  | 'writing.mock.daily'
  | 'writing.storage'
  | 'writing.install.prompt'
  | 'writing.push.optin'
  | 'analytics.advanced'
  | 'analytics.perfBudgets'
  | 'admin.health'
  | 'admin.impersonate';

export function getPlanGates(plan: PlanId): PlanGateConfig {
  return PLAN_GATES[plan] ?? PLAN_GATES.free;
}

export function planAllows(plan: PlanId, feature: PlanGateKey): boolean {
  const gates = getPlanGates(plan);
  switch (feature) {
    case 'writing.export.pdf':
      return gates.writing.exportPdf;
    case 'writing.certificate':
      return gates.writing.certificateAccess;
    case 'writing.ai.daily':
      return gates.writing.aiEvaluationsPerDay > 0;
    case 'writing.mock.daily':
      return gates.writing.mockStartsPerDay > 0;
    case 'writing.storage':
      return gates.writing.storageGB > 0;
    case 'writing.install.prompt':
      return gates.writing.installPrompt;
    case 'writing.push.optin':
      return gates.writing.pushNotifications;
    case 'analytics.advanced':
      return gates.analytics.advancedWriting;
    case 'analytics.perfBudgets':
      return gates.analytics.perfBudgets;
    case 'admin.health':
      return gates.admin.healthDashboard;
    case 'admin.impersonate':
      return gates.admin.canImpersonate;
    default:
      return false;
  }
}

export function writingAiLimit(plan: PlanId): number {
  return getPlanGates(plan).writing.aiEvaluationsPerDay;
}

export function writingMockLimit(plan: PlanId): number {
  return getPlanGates(plan).writing.mockStartsPerDay;
}

export function xpDailyCap(plan: PlanId): number {
  return getPlanGates(plan).writing.xpDailyCap;
}

export function writingStorageLimit(plan: PlanId): number {
  return getPlanGates(plan).writing.storageGB;
}

export function writingInstallPromptEnabled(plan: PlanId): boolean {
  return getPlanGates(plan).writing.installPrompt;
}

export function writingPushOptInEnabled(plan: PlanId): boolean {
  return getPlanGates(plan).writing.pushNotifications;
}






============================================================
FILE #70
PATH: lib/lifecycle/events.ts
============================================================
// lib/lifecycle/events.ts
// Server helpers to enqueue lifecycle notification events.

import { supabaseService } from '@/lib/supabaseServer';
import { renderLifecycleTemplate, type LifecycleEventType } from '@/lib/lifecycle/templates';
import type { Database } from '@/types/supabase';

type LifecycleChannel = 'email' | 'whatsapp';

export type LifecycleTriggerOptions = {
  userId: string;
  event: LifecycleEventType;
  context?: Record<string, unknown>;
  dedupeKey?: string | null;
};

export type LifecycleTriggerResult =
  | { ok: true; id: number; channels: LifecycleChannel[]; locale: string }
  | { ok: false; reason: 'no_channels' | 'duplicate'; id?: number; channels?: LifecycleChannel[] };

function sanitizeContext(context?: Record<string, unknown>): Record<string, unknown> {
  if (!context) return {};
  try {
    return JSON.parse(JSON.stringify(context)) as Record<string, unknown>;
  } catch {
    const safe: Record<string, unknown> = {};
    for (const [key, value] of Object.entries(context)) {
      const type = typeof value;
      if (value === null || type === 'string' || type === 'number' || type === 'boolean') {
        safe[key] = value as unknown;
      }
    }
    return safe;
  }
}

function extractNumber(value: unknown): number | null {
  if (typeof value === 'number' && Number.isFinite(value)) return value;
  if (typeof value === 'string') {
    const parsed = Number(value);
    if (!Number.isNaN(parsed)) return parsed;
  }
  return null;
}

function computeDedupeKey(
  event: LifecycleEventType,
  context: Record<string, unknown>,
  explicit?: string | null,
): string {
  if (explicit && explicit.trim().length > 0) {
    return explicit.trim();
  }

  if (event === 'band_up') {
    const band =
      extractNumber(context.band) ??
      extractNumber((context as Record<string, unknown>).targetBand) ??
      extractNumber((context as Record<string, unknown>).toBand);
    if (band !== null) {
      return `band:${band}`;
    }
  }

  if (event === 'streak_broken') {
    const streak =
      extractNumber(context.streakDays) ??
      extractNumber(context.days) ??
      extractNumber(context.streak);
    if (streak !== null) {
      return `streak:${streak}`;
    }
    const date = (context.date ?? context.day ?? context.eventDate) as string | undefined;
    if (typeof date === 'string' && date.trim().length > 0) {
      return `streak:${date.trim()}`;
    }
  }

  return event;
}

export async function enqueueLifecycleEvent(
  options: LifecycleTriggerOptions,
): Promise<LifecycleTriggerResult> {
  const client = supabaseService<Database>();
  const safeContext = sanitizeContext(options.context);

  const [{ data: profile, error: profileError }, { data: optIn, error: optError }] = await Promise.all([
    client
      .from('profiles')
      .select(
        'user_id, full_name, email, phone, phone_verified, whatsapp_opt_in, notification_channels, locale, preferred_language',
      )
      .eq('user_id', options.userId)
      .maybeSingle(),
    client
      .from('notifications_opt_in')
      .select('email_opt_in, sms_opt_in, wa_opt_in')
      .eq('user_id', options.userId)
      .maybeSingle(),
  ]);

  if (profileError) {
    throw new Error(profileError.message);
  }
  if (optError) {
    throw new Error(optError.message);
  }

  let email = (profile?.email ?? null) as string | null;
  if (!email) {
    try {
      const { data: userData } = await client.auth.admin.getUserById(options.userId);
      email = userData.user?.email ?? null;
    } catch {
      // ignore admin lookup failures
    }
  }

  const phone = typeof profile?.phone === 'string' ? profile.phone : null;
  const rawPhoneVerified = profile?.phone_verified;
  const phoneVerified = rawPhoneVerified === null || rawPhoneVerified === undefined ? true : Boolean(rawPhoneVerified);
  const emailOptIn = optIn?.email_opt_in ?? true;
  const whatsappOptIn = optIn?.wa_opt_in ?? Boolean(profile?.whatsapp_opt_in);

  const channels: LifecycleChannel[] = [];
  if (emailOptIn && email) {
    channels.push('email');
  }
  if (whatsappOptIn && phone && phoneVerified) {
    channels.push('whatsapp');
  }

  if (channels.length === 0) {
    return { ok: false, reason: 'no_channels' };
  }

  const dedupeKey = computeDedupeKey(options.event, safeContext, options.dedupeKey ?? null);

  const { data: inserted, error } = await client
    .from('lifecycle_events')
    .insert({
      user_id: options.userId,
      event: options.event,
      context: safeContext,
      dedupe_key: dedupeKey,
      channels,
    })
    .select('id')
    .single();

  if (error) {
    if (error.code === '23505') {
      const { data: existing } = await client
        .from('lifecycle_events')
        .select('id, channels')
        .eq('user_id', options.userId)
        .eq('event', options.event)
        .eq('dedupe_key', dedupeKey)
        .order('created_at', { ascending: false })
        .limit(1)
        .maybeSingle();

      const existingChannels = Array.isArray(existing?.channels)
        ? (existing!.channels as string[]).filter((value): value is LifecycleChannel =>
            value === 'email' || value === 'whatsapp',
          )
        : undefined;

      return {
        ok: false,
        reason: 'duplicate',
        id: existing?.id ?? undefined,
        channels: existingChannels,
      };
    }
    throw new Error(error.message);
  }

  const rendered = renderLifecycleTemplate(options.event, {
    name: profile?.full_name ?? undefined,
    locale: profile?.locale ?? profile?.preferred_language ?? undefined,
    context: safeContext,
  });

  try {
    await client.functions.invoke('lifecycle-worker', {
      body: { eventIds: [inserted.id] },
    });
  } catch {
    // worker invocation best-effort
  }

  return {
    ok: true,
    id: inserted.id,
    channels,
    locale: rendered.locale,
  };
}





============================================================
FILE #71
PATH: lib/lifecycle/templates.ts
============================================================
// lib/lifecycle/templates.ts
// Shared messaging copy for lifecycle email + WhatsApp notifications.

export type LifecycleEventType = 'first_mock_done' | 'band_up' | 'streak_broken';

export type LifecycleTemplateInput = {
  name?: string | null;
  locale?: string | null;
  context?: Record<string, unknown> | null | undefined;
};

export type LifecycleChannelTemplate = {
  subject: string;
  text: string;
  html?: string | null;
};

export type LifecycleRenderedTemplate = {
  locale: string;
  email: LifecycleChannelTemplate;
  whatsapp: { text: string };
};

type TemplateBuilder = (
  event: LifecycleEventType,
  input: LifecycleTemplateInput,
  locale: 'en' | 'ur',
) => LifecycleRenderedTemplate;

function pickLocale(candidate?: string | null): 'en' | 'ur' {
  if (!candidate) return 'en';
  const normalized = candidate.toLowerCase();
  if (normalized.startsWith('ur') || normalized.includes('urdu')) {
    return 'ur';
  }
  return 'en';
}

function friendlyName(name?: string | null): string {
  if (!name) return 'there';
  return name.trim().split(' ')[0] || 'there';
}

function extractNumber(value: unknown): number | null {
  if (typeof value === 'number' && Number.isFinite(value)) return value;
  if (typeof value === 'string') {
    const parsed = Number(value);
    if (!Number.isNaN(parsed)) return parsed;
  }
  return null;
}

function extractUrl(context?: Record<string, unknown> | null): string | null {
  if (!context) return null;
  const candidate = context.url ?? context.link ?? context.href ?? null;
  if (typeof candidate === 'string' && candidate.trim().length > 0) {
    return candidate.trim();
  }
  return null;
}

function renderFirstMock(
  event: LifecycleEventType,
  input: LifecycleTemplateInput,
  locale: 'en' | 'ur',
): LifecycleRenderedTemplate {
  const name = friendlyName(input.name);
  const url = extractUrl(input.context);

  if (locale === 'ur') {
    const emailLines = [
      `Ø³Ù„Ø§Ù… ${name}!`,
      '',
      'Ø¢Ù¾ Ù†Û’ Ø§Ù¾Ù†Ø§ Ù¾ÛÙ„Ø§ Ù…ÙˆÚ© Ù¹ÛŒØ³Ù¹ Ù…Ú©Ù…Ù„ Ú©Ø± Ù„ÛŒØ§ ÛÛ’ â€” Ú©Ù…Ø§Ù„ Ú©ÛŒ Ø´Ø±ÙˆØ¹Ø§Øª! ÙÛŒÚˆØ¨ÛŒÚ© Ø¯ÛŒÚ©Ú¾ÛŒÚº Ø§ÙˆØ± Ø§Ú¯Ù„Ø§ Ù¾Ù„Ø§Ù† Ú©Ø±ÛŒÚºÛ”',
    ];
    if (url) {
      emailLines.push('', `Ù†ØªØ§Ø¦Ø¬ ÛŒÛØ§Úº Ø¯ÛŒÚ©Ú¾ÛŒÚº: ${url}`);
    }
    emailLines.push('', 'Ø¬Ø§Ø±ÛŒ Ø±Ú©Ú¾ÛŒÚºØŒ', 'GramorX Ù¹ÛŒÙ…');

    const whatsapp = url
      ? `ðŸ”¥ Ø²Ø¨Ø±Ø¯Ø³Øª ${name}! Ù¾ÛÙ„Ø§ Ù…ÙˆÚ© Ø®ØªÙ…Û” ÙÛŒÚˆØ¨ÛŒÚ© ÛŒÛØ§Úº Ø¯ÛŒÚ©Ú¾ÛŒÚº: ${url}`
      : `ðŸ”¥ Ø²Ø¨Ø±Ø¯Ø³Øª ${name}! Ù¾ÛÙ„Ø§ Ù…ÙˆÚ© Ø®ØªÙ…Û” ÙÛŒÚˆØ¨ÛŒÚ© Ú†ÛŒÚ© Ú©Ø±ÛŒÚº Ø§ÙˆØ± Ø§Ú¯Ù„Ø§ Ù‚Ø¯Ù… Ù„ÛŒÚºÛ”`;

    return {
      locale,
      email: {
        subject: 'Ù¾ÛÙ„Ø§ Ù…ÙˆÚ© Ù…Ú©Ù…Ù„ â€” Ø´Ø§Ø¨Ø§Ø´!',
        text: emailLines.join('\n'),
      },
      whatsapp: { text: whatsapp },
    };
  }

  const emailLines = [
    `Hi ${name},`,
    '',
    'You just wrapped your first mock test â€” amazing momentum! Review what went well and plan the next step while itâ€™s fresh.',
  ];
  if (url) {
    emailLines.push('', `See your feedback here: ${url}`);
  }
  emailLines.push('', 'Keep going,', 'Team GramorX');

  const whatsapp = url
    ? `ðŸ”¥ Nice work ${name}! Your first mock is done. Check the feedback: ${url}`
    : `ðŸ”¥ Nice work ${name}! Your first mock is done. Jump back in for the next practice when youâ€™re ready.`;

  return {
    locale,
    email: {
      subject: 'You finished your first mock! ðŸŽ‰',
      text: emailLines.join('\n'),
    },
    whatsapp: { text: whatsapp },
  };
}

function renderBandUp(
  event: LifecycleEventType,
  input: LifecycleTemplateInput,
  locale: 'en' | 'ur',
): LifecycleRenderedTemplate {
  const name = friendlyName(input.name);
  const ctx = input.context ?? {};
  const band = extractNumber((ctx as Record<string, unknown>).band ?? ctx.targetBand ?? ctx.toBand);
  const previous = extractNumber((ctx as Record<string, unknown>).previousBand ?? ctx.fromBand);
  const delta = band !== null && previous !== null ? band - previous : null;
  const url = extractUrl(ctx as Record<string, unknown>);

  if (locale === 'ur') {
    const subject = band ? `ðŸŽ¯ Band ${band} ØªÚ© Ù¾ÛÙ†Ú† Ú¯Ø¦Û’!` : 'ðŸŽ¯ Ù†ÛŒØ§ Ø¨ÛŒÙ†Úˆ Ø­Ø§ØµÙ„ ÛÙˆØ§!';
    const body: string[] = [
      `Ø³Ù„Ø§Ù… ${name}!`,
      '',
      band
        ? `Ù…Ø¨Ø§Ø±Ú© ÛÙˆ â€” Ø¢Ù¾ Ø§Ø¨ Band ${band} Ù¾Ø± ÛÛŒÚº!`
        : 'Ù…Ø¨Ø§Ø±Ú© ÛÙˆ â€” Ø¢Ù¾ Ù†Û’ Ø§Ù¾Ù†ÛŒ ØªØ­Ø±ÛŒØ±ÛŒ Ø¨ÛŒÙ†Úˆ Ø§Ø³Ú©ÙˆØ± Ù…ÛŒÚº Ø§Ø¶Ø§ÙÛ Ú©ÛŒØ§ ÛÛ’!',
    ];
    if (delta && delta > 0) {
      body.push(`ÛŒÛ ${delta.toFixed(1)} Ù¾ÙˆØ§Ø¦Ù†Ù¹ Ú©ÛŒ Ø¨ÛØªØ±ÛŒ ÛÛ’Û”`);
    }
    body.push('Ø§Ø³ Ø±ÙØªØ§Ø± Ú©Ùˆ Ø¨Ø±Ù‚Ø±Ø§Ø± Ø±Ú©Ú¾ÛŒÚº Ø§ÙˆØ± Ø§Ú¯Ù„Û’ Ù…Ù‚ØµØ¯ Ú©ÛŒÙ„Ø¦Û’ Ù…Ù†ØµÙˆØ¨Û Ø¨Ù†Ø§Ø¦ÛŒÚºÛ”');
    if (url) {
      body.push('', `Ø§Ù¾Ù†ÛŒ ØªÛŒØ§Ø±ÛŒ Ø¬Ø§Ø±ÛŒ Ø±Ú©Ú¾ÛŒÚº: ${url}`);
    }
    body.push('', 'GramorX Ù¹ÛŒÙ…');

    const whatsapp = url
      ? `ðŸŽ¯ Ø²Ø¨Ø±Ø¯Ø³Øª ${name}! Band ${band ?? ''} ØªÚ© Ù¾ÛÙ†Ú† Ú¯Ø¦Û’Û” Ø§Ú¯Ù„Û’ Ø³Ø¨Ù‚ Ú©ÛŒÙ„Ø¦Û’ ÛŒÛØ§Úº Ø¬Ø§Ø¦ÛŒÚº: ${url}`.trim()
      : `ðŸŽ¯ Ø²Ø¨Ø±Ø¯Ø³Øª ${name}! Ù†Ø¦ÛŒ Ø¨ÛŒÙ†Úˆ Ù…ÛŒÚº Ø§Ù¾ Ú¯Ø±ÛŒÚˆÛ” Ø§Ú¯Ù„Ø§ Ø³Ø¨Ù‚ Ù„Ø§Ú© Ú©Ø±ÛŒÚºÛ”`;

    return {
      locale,
      email: { subject, text: body.join('\n') },
      whatsapp: { text: whatsapp },
    };
  }

  const subject = band ? `ðŸŽ¯ Band ${band} unlocked!` : 'ðŸŽ¯ You moved up a band!';
  const body: string[] = [
    `Hi ${name},`,
    '',
    band
      ? `Huge congrats â€” youâ€™re now tracking at Band ${band}!`
      : 'Huge congrats â€” your band score just moved up!',
  ];
  if (delta && delta > 0) {
    body.push(`Thatâ€™s a +${delta.toFixed(1)} jump from your previous checkpoint.`);
  }
  body.push('Lock in the habits that worked and queue your next mock while the streak is hot.');
  if (url) {
    body.push('', `Plan your next step: ${url}`);
  }
  body.push('', 'Onward,', 'Team GramorX');

  const whatsapp = url
    ? `ðŸŽ¯ Band ${band ?? ''}! Keep the streak â€” next practice: ${url}`.trim()
    : `ðŸŽ¯ Band up! Keep momentum and queue your next practice.`;

  return {
    locale,
    email: { subject, text: body.join('\n') },
    whatsapp: { text: whatsapp },
  };
}

function renderStreakBroken(
  event: LifecycleEventType,
  input: LifecycleTemplateInput,
  locale: 'en' | 'ur',
): LifecycleRenderedTemplate {
  const name = friendlyName(input.name);
  const ctx = input.context ?? {};
  const streak = extractNumber((ctx as Record<string, unknown>).streakDays ?? ctx.days ?? ctx.streak);
  const url = extractUrl(ctx as Record<string, unknown>);

  if (locale === 'ur') {
    const subject = 'ÛÙ… Ø¢Ù¾ Ú©Ùˆ Ø¯ÙˆØ¨Ø§Ø±Û Ù¹Ø±ÛŒÚ© Ù¾Ø± Ù„Ø§Ù†Ø§ Ú†Ø§ÛØªÛ’ ÛÛŒÚº';
    const lines = [
      `Ø³Ù„Ø§Ù… ${name}!`,
      '',
      streak
        ? `Ø¢Ù¾ Ú©ÛŒ ${streak}-Ø¯Ù† Ú©ÛŒ Ø§Ø³Ù¹Ø±ÛŒÚ© Ø±ÙÚ© Ú¯Ø¦ÛŒ ÛÛ’ â€” Ú©ÙˆØ¦ÛŒ Ø¨Ø§Øª Ù†ÛÛŒÚºÛ”`
        : 'ÛÙ… Ù†Û’ Ø¯ÛŒÚ©Ú¾Ø§ ÛÛ’ Ú©Û Ø¢Ù¾ Ú©ÛŒ Ø§Ø³Ù¹Ø±ÛŒÚ© Ø±ÙÚ© Ú¯Ø¦ÛŒ ÛÛ’ â€” Ú©ÙˆØ¦ÛŒ Ù…Ø³Ø¦Ù„Û Ù†ÛÛŒÚºÛ”',
      'Ø§ÛŒÚ© ÛÙ„Ú©Ø§ Ø³Ø§ Ù…Ø´Ù‚ Ù…Ù†ØªØ®Ø¨ Ú©Ø±ÛŒÚº Ø§ÙˆØ± Ø¯ÙˆØ¨Ø§Ø±Û Ø±ÙØªØ§Ø± Ù¾Ú©Ú‘ÛŒÚºÛ”',
    ];
    if (url) {
      lines.push('', `ÛŒÛØ§Úº Ø³Û’ Ø¯ÙˆØ¨Ø§Ø±Û Ø´Ø±ÙˆØ¹ Ú©Ø±ÛŒÚº: ${url}`);
    }
    lines.push('', 'ÛÙ… Ø³Ø§ØªÚ¾ ÛÛŒÚºØŒ', 'GramorX Ù¹ÛŒÙ…');

    const whatsapp = url
      ? `â±ï¸ ${name}, Ø§Ø³Ù¹Ø±ÛŒÚ© ÛÙ„Ú©ÛŒ Ø³ÛŒ Ø±Ú© Ú¯Ø¦ÛŒ ÛÛ’Û” Ø§Ø¨Ú¾ÛŒ Ø§Ø³ Ù„Ù†Ú© Ø³Û’ Ù…Ø®ØªØµØ± Ù…Ø´Ù‚ Ú©Ø±ÛŒÚº: ${url}`
      : `â±ï¸ ${name}, Ø§Ø³Ù¹Ø±ÛŒÚ© Ø±Ú© Ú¯Ø¦ÛŒ ÛÛ’Û” Ø§ÛŒÚ© Ú†Ú¾ÙˆÙ¹ÛŒ Ù…Ø´Ù‚ Ø³Û’ Ø¯ÙˆØ¨Ø§Ø±Û Ø¢ØºØ§Ø² Ú©Ø±ÛŒÚºÛ”`;

    return {
      locale,
      email: { subject, text: lines.join('\n') },
      whatsapp: { text: whatsapp },
    };
  }

  const subject = 'Letâ€™s restart your study streak';
  const lines = [
    `Hi ${name},`,
    '',
    streak
      ? `Your ${streak}-day streak paused â€” totally okay.`
      : 'We noticed your study streak paused â€” totally okay.',
    'Grab a short practice to rebuild the rhythm. Even 10 focused minutes counts.',
  ];
  if (url) {
    lines.push('', `Jump back in: ${url}`);
  }
  lines.push('', 'Weâ€™ve got your back,', 'Team GramorX');

  const whatsapp = url
    ? `â±ï¸ Your streak paused, ${name}. Restart with a quick drill: ${url}`
    : `â±ï¸ Your streak paused, ${name}. A quick practice will restart the momentum.`;

  return {
    locale,
    email: { subject, text: lines.join('\n') },
    whatsapp: { text: whatsapp },
  };
}

const BUILDERS: Record<LifecycleEventType, TemplateBuilder> = {
  first_mock_done: renderFirstMock,
  band_up: renderBandUp,
  streak_broken: renderStreakBroken,
};

export function renderLifecycleTemplate(
  event: LifecycleEventType,
  input: LifecycleTemplateInput,
): LifecycleRenderedTemplate {
  const locale = pickLocale(input.locale);
  const builder = BUILDERS[event];
  return builder(event, input, locale);
}





============================================================
FILE #72
PATH: lib/profile/update.ts
============================================================
// lib/profile/update.ts
import type { SupabaseClient } from '@supabase/supabase-js';
// If you have a generated Database type, import it and use SupabaseClient<Database>
//
// import type { Database } from '@/types/supabase';
// export type TypedSupabaseClient = SupabaseClient<Database>;
//
// For now we keep it generic to avoid breaking anything:
export type TypedSupabaseClient = SupabaseClient<any, 'public', any>;

// Narrow payload to what we actually use from profiles.
export interface ProfileUpdatePayload {
  language_preference?: string;
  target_band?: number;
  exam_timeframe?: string;
  exam_date?: string | null;
  study_rhythm?: string;
  notification_channels?: string[];
  notification_time?: string | null;
  onboarding_completed_at?: string | null;
}

/**
 * Small helper to update profiles for a given user.
 * Centralizes the Supabase update + error shape.
 */
export async function updateProfileForUser(
  supabase: TypedSupabaseClient,
  userId: string,
  patch: ProfileUpdatePayload
) {
  const { error } = await supabase
    .from('profiles')
    .update(patch)
    .eq('id', userId);

  return { error };
}





============================================================
FILE #73
PATH: pages/api/webhooks/payment.ts
============================================================
// pages/api/webhooks/payment.ts
import type { NextApiHandler } from 'next';
import { buffer } from 'micro';
import { createSupabaseServerClient } from '@/lib/supabaseServer';
import { env } from '@/lib/env';
import { trackor } from '@/lib/analytics/trackor.server';
import { queueNotificationEvent, getNotificationContact } from '@/lib/notify';
import { getBaseUrl } from '@/lib/url';

// Important: disable body parsing so we can verify Stripe signatures
export const config = { api: { bodyParser: false } };

type Ok = { received: true };
type Err = { error: string };

const handler: NextApiHandler<Ok | Err> = async (req, res) => {
  if (req.method !== 'POST') return res.status(405).json({ error: 'Method Not Allowed' });

  // @ts-expect-error TODO: add `stripe` dependency for full types
  const Stripe = (await import('stripe')).default ?? (await import('stripe'));
  const secretKey = env.STRIPE_SECRET_KEY;
  const webhookSecret = env.STRIPE_WEBHOOK_SECRET;

  const supabase = createSupabaseServerClient({ serviceRole: true });
  const baseUrl = getBaseUrl();

  const notifyPayment = async (
    userId: string | null | undefined,
    eventKey: 'payment_success' | 'payment_failed',
    id: string,
    extras: Record<string, unknown> = {},
  ) => {
    if (!userId) return;
    const contact = await getNotificationContact(userId);
    if (!contact.email) return;

    const payload: Record<string, unknown> = {
      deep_link: `${baseUrl}/settings/billing`,
      user_email: contact.email,
      ...extras,
    };

    if (contact.phone) {
      payload.user_phone = contact.phone;
    }

    const result = await queueNotificationEvent({
      event_key: eventKey,
      user_id: userId,
      payload,
      channels: ['email'],
      idempotency_key: `${eventKey}:${id}`,
    });

    if (!result.ok && result.reason !== 'duplicate') {
      console.error('[payments:notify]', eventKey, result.message);
    }
  };

  // If Stripe not configured, accept as no-op (useful when testing local gateways)
  if (!secretKey || !webhookSecret) {
    return res.status(200).json({ received: true });
  }

  const stripe = new Stripe(secretKey, { apiVersion: '2024-06-20' });

  let event: any;
  try {
    const sig = req.headers['stripe-signature'] as string;
    const raw = await buffer(req);
    event = stripe.webhooks.constructEvent(raw, sig, webhookSecret);
  } catch (err) {
    return res.status(400).json({ error: `Webhook signature verification failed` });
  }

  try {
    // Persist raw event for audit
    try {
      await supabase.from('payment_events').insert([
        {
          provider: 'stripe',
          status: 'webhook_received',
          external_id: event.id,
          metadata: { type: event.type },
        },
      ]);
    } catch {
      /* non-fatal */
    }

    switch (event.type) {
      case 'checkout.session.completed': {
        const session = event.data.object as {
          id: string;
          client_reference_id?: string; // userId
          metadata?: Record<string, string>;
          subscription?: string;
          customer?: string;
        };

        const userId = session.client_reference_id;
        const plan = (session.metadata?.plan as 'starter' | 'booster' | 'master' | undefined) || 'booster';

        if (userId) {
          // Update profile entitlements
          await supabase
            .from('profiles')
            .update({
              membership: plan,
              subscription_status: 'active',
              stripe_customer_id: session.customer,
              subscription_renews_at: null,
              trial_ends_at: null,
              premium_until: null,
              updated_at: new Date().toISOString(),
            })
            .eq('id', userId);
        }

        if (session.id) {
          const { data: intent } = await supabase
            .from('payment_intents')
            .select('id, user_id, plan_id, cycle')
            .eq('gateway_session_id', session.id)
            .eq('provider', 'stripe')
            .maybeSingle();

          if (intent) {
            const confirmedAt = new Date().toISOString();
            await supabase
              .from('payment_intents')
              .update({ status: 'succeeded', confirmed_at: confirmedAt, updated_at: confirmedAt })
              .eq('id', intent.id);

            await supabase.from('payment_intent_events').insert({
              intent_id: intent.id,
              user_id: intent.user_id,
              event: 'webhook.success',
              payload: { provider: 'stripe', sessionId: session.id },
            });

            await trackor.log('payments.intent.success', {
              userId: intent.user_id ?? userId,
              intentId: intent.id,
              provider: 'stripe',
              plan: intent.plan_id ?? plan,
              cycle: intent.cycle,
            });
          }
        }

        await supabase.from('payment_events').insert([
          {
            provider: 'stripe',
            status: 'checkout.session.completed',
            external_id: session.id,
            user_id: userId,
            metadata: { plan, subscription: session.subscription, customer: session.customer },
          },
        ]);

        await notifyPayment(userId, 'payment_success', intent?.id ?? session.id, {
          provider: 'stripe',
          plan: intent?.plan_id ?? plan,
          cycle: intent?.cycle ?? 'monthly',
        });
        break;
      }

      case 'invoice.payment_succeeded': {
        const invoice = event.data.object as any;
        await supabase.from('payment_events').insert([
          {
            provider: 'stripe',
            status: 'invoice.payment_succeeded',
            external_id: invoice.id,
            user_id: null,
            metadata: { amount_paid: invoice.amount_paid, currency: invoice.currency },
          },
        ]);

        if (invoice.customer) {
          const { data: profile } = await supabase
            .from('profiles')
            .select('user_id')
            .eq('stripe_customer_id', invoice.customer as string)
            .maybeSingle<{ user_id: string }>();

          await notifyPayment(profile?.user_id ?? null, 'payment_success', invoice.id, {
            provider: 'stripe',
            amount: invoice.amount_paid,
            currency: invoice.currency,
            invoice_id: invoice.id,
          });
        }
        break;
      }

      case 'invoice.payment_failed': {
        const invoice = event.data.object as any;

        await supabase.from('payment_events').insert([
          {
            provider: 'stripe',
            status: 'invoice.payment_failed',
            external_id: invoice.id,
            user_id: null,
            metadata: { amount_due: invoice.amount_due, currency: invoice.currency },
          },
        ]);

        if (invoice.customer) {
          const { data: profile } = await supabase
            .from('profiles')
            .select('user_id')
            .eq('stripe_customer_id', invoice.customer as string)
            .maybeSingle<{ user_id: string }>();

          const reason =
            (invoice.last_payment_error?.message as string | undefined) ??
            'Payment failed';

          await notifyPayment(profile?.user_id ?? null, 'payment_failed', invoice.id, {
            provider: 'stripe',
            amount: invoice.amount_due,
            currency: invoice.currency,
            reason,
            invoice_id: invoice.id,
          });
        }

        break;
      }

      case 'customer.subscription.updated':
      case 'customer.subscription.deleted': {
        const sub = event.data.object as any;
        // Best-effort: if you store customer->user mapping, update profile
        try {
          const customerId: string | undefined = sub.customer;
          if (customerId) {
            const { data: prof } = await supabase
              .from('profiles')
              .select('id, membership')
              .eq('stripe_customer_id', customerId)
              .maybeSingle();
            if (prof?.id) {
              const status = (sub.status as string | undefined) || 'canceled';
              const periodEnd =
                typeof sub.current_period_end === 'number'
                  ? new Date(sub.current_period_end * 1000).toISOString()
                  : null;
              const trialEnd =
                typeof sub.trial_end === 'number'
                  ? new Date(sub.trial_end * 1000).toISOString()
                  : null;

              const shouldDowngrade =
                status === 'canceled' || status === 'past_due' || status === 'unpaid';

              const updates: Record<string, any> = {
                subscription_status: status,
                subscription_renews_at: periodEnd,
                trial_ends_at: trialEnd,
                updated_at: new Date().toISOString(),
              };

              if (shouldDowngrade) {
                updates.membership = 'free';
                updates.premium_until = null;
              }

              await supabase
                .from('profiles')
                .update(updates)
                .eq('id', prof.id);
            }
          }
        } catch {
          /* non-fatal */
        }
        await supabase.from('payment_events').insert([
          {
            provider: 'stripe',
            status: event.type,
            external_id: sub.id,
            user_id: null,
            metadata: { status: sub.status, current_period_end: sub.current_period_end },
          },
        ]);
        break;
      }

      default:
        // Store unknowns for visibility
        await supabase.from('payment_events').insert([
          {
            provider: 'stripe',
            status: 'unhandled_event',
            external_id: event.id,
            metadata: { type: event.type },
          },
        ]);
    }

    return res.status(200).json({ received: true });
  } catch (err) {
    return res.status(500).json({ error: (err as Error).message || 'Webhook handler error' });
  }
};

export default handler;





============================================================
FILE #74
PATH: pages/api/institutions/invite.ts
============================================================
import type { NextApiRequest, NextApiResponse } from 'next';
import { z } from 'zod';
import { supabaseServer } from '@/lib/supabaseServer';
import { withPlan } from '@/lib/apiGuard';

const BodySchema = z.object({
  orgId: z.string().uuid(),
  email: z.string().email(),
  role: z.enum(['student', 'teacher', 'admin']).default('student'),
});

type InviteResponse =
  | { ok: true; orgId: string; inviteId: string }
  | { ok: false; error: string; code?: 'UNAUTHORIZED' | 'FORBIDDEN' | 'NOT_FOUND' | 'DB_ERROR' | 'BAD_REQUEST' };

async function handler(req: NextApiRequest, res: NextApiResponse<InviteResponse>) {
  if (req.method !== 'POST') return res.status(405).json({ ok: false, error: 'Method not allowed' });

  // â—ï¸ Fixed: only pass req so cookies are actually read
  const supabase = supabaseServer(req);

  const { data: auth } = await supabase.auth.getUser();
  const user = auth?.user;
  if (!user) return res.status(401).json({ ok: false, error: 'Unauthorized', code: 'UNAUTHORIZED' });

  const parsed = BodySchema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json({ ok: false, error: parsed.error.message, code: 'BAD_REQUEST' });
  const { orgId, email, role } = parsed.data;

  // Verify caller is org admin
  const { data: membership } = await supabase
    .from('org_members')
    .select('role')
    .eq('org_id', orgId)
    .eq('user_id', user.id)
    .eq('role', 'admin')
    .maybeSingle();

  if (!membership) return res.status(403).json({ ok: false, error: 'Forbidden', code: 'FORBIDDEN' });

  // Verify org exists
  const { data: org } = await supabase.from('orgs').select('id').eq('id', orgId).maybeSingle();
  if (!org) return res.status(404).json({ ok: false, error: 'Organization not found', code: 'NOT_FOUND' });

  // Create invite
  const { data: invite, error } = await supabase
    .from('org_invites')
    .insert({
      org_id: orgId,
      email,
      role,
      invited_by: user.id,
      expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(), // 7 days
    })
    .select('id')
    .single();

  if (error) return res.status(500).json({ ok: false, error: error.message, code: 'DB_ERROR' });

  // TODO: trigger email (use your existing notification service)
  return res.status(200).json({ ok: true, orgId, inviteId: invite!.id as string });
}

export default withPlan('master', handler);





============================================================
FILE #75
PATH: lib/notify.ts
============================================================
// lib/notify.ts
// Notification helpers for GramorX (email / WhatsApp / SMS)

import type { SupabaseClient } from '@supabase/supabase-js';

export type NotificationChannel = 'email' | 'whatsapp' | 'sms';

export type NotificationContact = {
  channel: NotificationChannel;
  value: string;
};

/**
 * Tries to find the best contact for a user.
 * 1) Look in a dedicated `notification_contacts` table (if it exists).
 * 2) Fallback to profile email / phone.
 */
export async function getNotificationContactByUser(
  supabase: SupabaseClient,
  userId: string,
): Promise<NotificationContact | null> {
  // 1) Custom table (if you have it)
  const { data: customRows } = await supabase
    .from('notification_contacts')
    .select('channel, value')
    .eq('user_id', userId)
    .limit(1);

  if (customRows && customRows.length > 0) {
    const row = customRows[0] as { channel: NotificationChannel; value: string };
    return row;
  }

  // 2) Fallback: use profile / auth user email if available
  const { data: profile } = await supabase
    .from('profiles')
    .select('email, phone')
    .eq('id', userId)
    .single();

  if (profile?.email) {
    return { channel: 'email', value: profile.email as string };
  }

  if (profile?.phone) {
    return { channel: 'whatsapp', value: profile.phone as string };
  }

  return null;
}

/**
 * Legacy helper â€“ right now just proxies to getNotificationContactByUser.
 */
export async function getNotificationContact(
  supabase: SupabaseClient,
  userId: string,
): Promise<NotificationContact | null> {
  return getNotificationContactByUser(supabase, userId);
}

/**
 * Queue a notification event.
 * Currently a no-op stub so builds & cron routes donâ€™t crash.
 */
export async function queueNotificationEvent(
  _supabase: SupabaseClient,
  _userId: string,
  _payload: unknown,
): Promise<void> {
  // TODO: implement notification queueing (insert into notification_events table)
}

/**
 * Dispatch pending queued notifications.
 * Also a stub for now.
 */
export async function dispatchPending(
  _supabase: SupabaseClient,
): Promise<void> {
  // TODO: implement dispatcher that reads pending events and sends them
}

/**
 * High-level notify helper.
 * For now it just queues the event.
 */
export async function notify(
  supabase: SupabaseClient,
  userId: string,
  payload: unknown,
): Promise<void> {
  await queueNotificationEvent(supabase, userId, payload);
}

/**
 * Alias to keep older imports happy.
 */
export async function enqueueEvent(
  supabase: SupabaseClient,
  userId: string,
  payload: unknown,
): Promise<void> {
  await queueNotificationEvent(supabase, userId, payload);
}

// Default object export â€“ matches older usage like `Notify.notify(...)`
const Notify = {
  notify,
  enqueueEvent,
  queueNotificationEvent,
  dispatchPending,
  getNotificationContact,
  getNotificationContactByUser,
};

export default Notify;





============================================================
FILE #76
PATH: pages/checkout/save-card.tsx
============================================================
// pages/checkout/save-card.tsx
import Head from 'next/head';
import Link from 'next/link';
import { useRouter } from 'next/router';
import * as React from 'react';
import { loadStripe } from '@stripe/stripe-js';
import { Elements, CardElement, useStripe, useElements } from '@stripe/react-stripe-js';

import { Container } from '@/components/design-system/Container';
import { Card } from '@/components/design-system/Card';
import { Button } from '@/components/design-system/Button';
import { Alert } from '@/components/design-system/Alert';

const stripePromise = loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY || '');

function SaveCardForm() {
  const router = useRouter();
  const stripe = useStripe();
  const elements = useElements();

  const [name, setName] = React.useState('');
  const [line1, setLine1] = React.useState('');
  const [city, setCity] = React.useState('');
  const [postal, setPostal] = React.useState('');
  const [country, setCountry] = React.useState('PK');
  const [phone, setPhone] = React.useState('');
  const [loading, setLoading] = React.useState(false);
  const [msg, setMsg] = React.useState<string | null>(null);

  const plan = (router.query.plan as string) ?? 'starter';
  const cycle = (router.query.cycle as string) ?? 'monthly';

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault();
    setMsg(null);
    if (!stripe || !elements) return;

    setLoading(true);

    const pmRes = await stripe.createPaymentMethod({
      type: 'card',
      card: elements.getElement(CardElement)!,
      billing_details: {
        name: name || undefined,
        phone: phone || undefined,
        address: {
          line1: line1 || undefined,
          city: city || undefined,
          postal_code: postal || undefined,
          country: country || undefined,
        },
      },
    });

    if (pmRes.error) {
      setLoading(false);
      setMsg(pmRes.error.message || 'Card error');
      return;
    }

    const r = await fetch('/api/payments/vault', {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({
        payment_method_id: pmRes.paymentMethod!.id,
        plan,
        cycle,
        billing_details: {
          name,
          phone,
          address: { line1, city, postal_code: postal, country },
        },
      }),
    });

    const j = await r.json();
    setLoading(false);

    if (!r.ok) {
      setMsg(j?.error || j?.details || 'Vault failed');
      return;
    }

    router.replace({ pathname: '/account/billing', query: { due: '1', vaulted: '1' } });
  }

  return (
    <>
      <Head>
        <title>Enter card Â· GramorX</title>
        <meta name="description" content="Securely save a card to activate your membership." />
      </Head>

      <div className="py-8">
        <Container className="max-w-3xl space-y-6">
          <header className="space-y-1">
            <h1 className="text-h2 font-semibold text-foreground">Enter card details</h1>
            <p className="text-small text-muted-foreground">
              Your plan will be activated, and the amount recorded as due. Weâ€™ll notify you before charging later.
            </p>
          </header>

          <Card as="section" padding="lg" insetBorder>
            <form onSubmit={onSubmit} className="space-y-5">
              {/* Name */}
              <div className="space-y-2">
                <label htmlFor="name" className="text-small text-muted-foreground">
                  Name on card
                </label>
                <input
                  id="name"
                  className="input"
                  autoComplete="cc-name"
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                  required
                />
              </div>

              {/* Billing address */}
              <div className="space-y-2">
                <label className="text-small text-muted-foreground">Billing address</label>
                <input
                  className="input"
                  placeholder="Address line 1"
                  autoComplete="address-line1"
                  value={line1}
                  onChange={(e) => setLine1(e.target.value)}
                />
                <div className="grid grid-cols-1 gap-2 sm:grid-cols-2">
                  <input
                    className="input"
                    placeholder="City"
                    autoComplete="address-level2"
                    value={city}
                    onChange={(e) => setCity(e.target.value)}
                  />
                  <input
                    className="input"
                    placeholder="Postal code"
                    autoComplete="postal-code"
                    value={postal}
                    onChange={(e) => setPostal(e.target.value)}
                  />
                </div>
                <input
                  className="input"
                  placeholder="Country code (e.g., PK, US)"
                  autoComplete="country"
                  value={country}
                  onChange={(e) => setCountry(e.target.value.toUpperCase())}
                  maxLength={2}
                />
                <input
                  className="input"
                  placeholder="Phone (optional)"
                  autoComplete="tel"
                  value={phone}
                  onChange={(e) => setPhone(e.target.value)}
                />
              </div>

              {/* Card element */}
              <div className="space-y-2">
                <label htmlFor="card" className="text-small text-muted-foreground">
                  Card
                </label>
                <div
                  id="card"
                  className="rounded-ds-xl border border-border/60 bg-background px-3 py-3"
                >
                  {/* CardElement renders inside an iframe; DS styling is applied to the wrapper */}
                  <CardElement options={{ hidePostalCode: true }} />
                </div>
              </div>

              <Button
                type="submit"
                size="lg"
                className="w-full"
                loading={loading || !stripe}
                disabled={loading || !stripe}
              >
                {loading ? 'Savingâ€¦' : 'Save card & activate membership'}
              </Button>

              <p className="text-caption text-muted-foreground">
                By continuing you agree we may charge this saved card later to settle your due. Youâ€™ll be notified first.
              </p>

              {msg && (
                <Alert variant="error" appearance="soft" className="mt-2">
                  {msg}
                </Alert>
              )}

              <div className="pt-1">
                <Button asChild variant="link" size="sm">
                  <Link href="/account/billing">Back to billing</Link>
                </Button>
              </div>
            </form>
          </Card>
        </Container>
      </div>
    </>
  );
}

export default function SaveCardPage() {
  if (!process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY) {
    return (
      <div className="py-8">
        <Container className="max-w-3xl">
          <Alert variant="warning" appearance="soft" title="Card payments unavailable">
            Add <code>NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY</code> to show the secure card form.
          </Alert>
          <div className="mt-4">
            <Button asChild variant="link" size="sm">
              <Link href="/account/billing">Back to billing</Link>
            </Button>
          </div>
        </Container>
      </div>
    );
  }

  return (
    <Elements stripe={stripePromise}>
      <SaveCardForm />
    </Elements>
  );
}





============================================================
FILE #77
PATH: lib/notificationTemplates.ts
============================================================
export interface NotificationTemplate {
  event_key: string;
  message: string;
  url?: string;
  channels?: string[];
  payload?: Record<string, any>;
}

export const NOTIFICATION_TEMPLATES: Record<string, NotificationTemplate> = {
  // ðŸŽ¯ User Onboarding & Welcome (10)
  WELCOME: {
    event_key: 'welcome',
    message: 'ðŸŽ‰ Welcome to GramorX! Start your learning journey today.',
    url: '/onboarding',
    channels: ['in_app', 'email']
  },
  PROFILE_COMPLETE: {
    event_key: 'profile_complete',
    message: 'âœ… Profile completed! Youâ€™re all set to explore courses.',
    url: '/profile'
  },
  FIRST_LOGIN: {
    event_key: 'first_login',
    message: 'ðŸ‘‹ Great to see you! Check out our beginner-friendly courses.',
    url: '/courses?level=beginner'
  },
  MOBILE_APP: {
    event_key: 'mobile_app',
    message: 'ðŸ“± Get our mobile app for learning on the go!',
    url: '/mobile-app'
  },
  INTRO_VIDEO: {
    event_key: 'intro_video',
    message: 'ðŸŽ¬ Watch our platform intro to get started quickly.',
    url: '/intro'
  },
  COMMUNITY_JOIN: {
    event_key: 'community_join',
    message: 'ðŸ‘¥ Join our learner community for support and discussions.',
    url: '/community'
  },
  LEARNING_PATH: {
    event_key: 'learning_path',
    message: 'ðŸ—ºï¸ Your personalized learning path is ready!',
    url: '/learning-path'
  },
  GOAL_SETTING: {
    event_key: 'goal_setting',
    message: 'ðŸŽ¯ Set your first learning goal to stay motivated.',
    url: '/goals'
  },
  PREFERENCES: {
    event_key: 'preferences',
    message: 'âš™ï¸ Customize your learning preferences for better experience.',
    url: '/settings/preferences'
  },
  NOTIFICATION_SETUP: {
    event_key: 'notification_setup',
    message: 'ðŸ”” Set up notifications to never miss important updates.',
    url: '/settings/notifications'
  },

  // ðŸ“š Course & Learning (25)
  COURSE_ENROLLED: {
    event_key: 'course_enrolled',
    message: 'ðŸ“– You enrolled in "{course_name}"! Start learning now.',
    url: '/learning/{course_id}'
  },
  COURSE_PROGRESS_25: {
    event_key: 'course_progress_25',
    message: 'ðŸ“Š Youâ€™re 25% through "{course_name}"! Keep going!',
    url: '/learning/{course_id}'
  },
  COURSE_PROGRESS_50: {
    event_key: 'course_progress_50',
    message: 'ðŸŽ¯ Halfway through "{course_name}"! Youâ€™re doing great.',
    url: '/learning/{course_id}'
  },
  COURSE_PROGRESS_75: {
    event_key: 'course_progress_75',
    message: 'ðŸš€ 75% complete in "{course_name}"! Almost there.',
    url: '/learning/{course_id}'
  },
  COURSE_COMPLETED: {
    event_key: 'course_completed',
    message: 'ðŸ† Congratulations! You completed "{course_name}"!',
    url: '/certificate/{course_id}'
  },
  NEW_COURSE_AVAILABLE: {
    event_key: 'new_course',
    message: 'ðŸ†• New course available: "{course_name}"',
    url: '/courses/{course_id}'
  },
  COURSE_UPDATE: {
    event_key: 'course_update',
    message: 'ðŸ”„ "{course_name}" has been updated with new content.',
    url: '/learning/{course_id}'
  },
  PREREQUISITE_MET: {
    event_key: 'prerequisite_met',
    message: 'âœ… You can now access "{course_name}" - prerequisites completed!',
    url: '/courses/{course_id}'
  },
  LEARNING_REMINDER: {
    event_key: 'learning_reminder',
    message: 'ðŸ“š Time for your daily learning session!',
    url: '/learning'
  },
  WEEKLY_PROGRESS: {
    event_key: 'weekly_progress',
    message: 'ðŸ“ˆ This week: {completed_lessons} lessons, {study_time} hours studied.',
    url: '/progress'
  },
  MONTHLY_REVIEW: {
    event_key: 'monthly_review',
    message: 'ðŸ“Š Monthly learning report: {courses_completed} courses finished!',
    url: '/reports/monthly'
  },
  COURSE_RECOMMENDATION: {
    event_key: 'course_recommendation',
    message: 'ðŸ’¡ Based on your progress, you might like "{course_name}"',
    url: '/courses/{course_id}'
  },
  DIFFICULTY_ADJUSTED: {
    event_key: 'difficulty_adjusted',
    message: 'ðŸŽ›ï¸ Course difficulty adjusted based on your performance.',
    url: '/learning/{course_id}'
  },
  LEARNING_STREAK_3: {
    event_key: 'learning_streak_3',
    message: 'ðŸ”¥ 3-day learning streak! Keep the momentum going.',
    url: '/streaks'
  },
  LEARNING_STREAK_7: {
    event_key: 'learning_streak_7',
    message: 'ðŸ”¥ 7-day streak! Youâ€™re building great habits.',
    url: '/streaks'
  },
  LEARNING_STREAK_30: {
    event_key: 'learning_streak_30',
    message: 'ðŸ”¥ 30-day streak! Amazing consistency!',
    url: '/streaks'
  },
  STUDY_GROUP_INVITE: {
    event_key: 'study_group_invite',
    message: 'ðŸ‘¥ Youâ€™ve been invited to join "{group_name}" study group',
    url: '/groups/{group_id}'
  },
  PEER_HELP: {
    event_key: 'peer_help',
    message: 'ðŸ¤ {student_name} asked a question in your study group',
    url: '/groups/{group_id}/discussion'
  },
  EXPERT_QA: {
    event_key: 'expert_qa',
    message: 'ðŸŽ¤ Live Q&A session with {expert_name} starting soon',
    url: '/live-sessions/{session_id}'
  },
  COURSE_DEADLINE: {
    event_key: 'course_deadline',
    message: 'â° "{course_name}" access expires in {days_left} days',
    url: '/learning/{course_id}'
  },
  CERTIFICATE_READY: {
    event_key: 'certificate_ready',
    message: 'ðŸ“œ Your certificate for "{course_name}" is ready!',
    url: '/certificate/{course_id}'
  },
  SKILL_VERIFIED: {
    event_key: 'skill_verified',
    message: 'âœ… Your {skill_name} skill has been verified!',
    url: '/skills'
  },
  LEARNING_PATH_UPDATED: {
    event_key: 'learning_path_updated',
    message: 'ðŸ”„ Your learning path has been updated with new recommendations',
    url: '/learning-path'
  },
  KNOWLEDGE_CHECK: {
    event_key: 'knowledge_check',
    message: 'ðŸ§  Time for a quick review of what youâ€™ve learned recently',
    url: '/review'
  },

  // ðŸ† Achievements & Milestones (20)
  ACHIEVEMENT_UNLOCKED: {
    event_key: 'achievement_unlocked',
    message: 'ðŸ† Achievement unlocked: "{achievement_name}"!',
    url: '/achievements'
  },
  FIRST_COURSE_COMPLETE: {
    event_key: 'first_course_complete',
    message: 'ðŸŽ¯ You completed your first course! Learning journey begins.',
    url: '/achievements'
  },
  PERFECT_QUIZ: {
    event_key: 'perfect_quiz',
    message: 'ðŸ’¯ Perfect score on "{quiz_name}"! Excellent work.',
    url: '/quizzes/{quiz_id}/results'
  },
  RANK_UP: {
    event_key: 'rank_up',
    message: 'â­ Rank upgraded to {new_rank}! Keep climbing.',
    url: '/profile/rank'
  },
  TOP_LEARNER: {
    event_key: 'top_learner',
    message: 'ðŸ‘‘ Youâ€™re in top 10% of learners this week!',
    url: '/leaderboard'
  },
  CONSISTENCY_AWARD: {
    event_key: 'consistency_award',
    message: 'ðŸ“… Consistency award: You learned every day this month!',
    url: '/achievements'
  },
  SPEED_LEARNER: {
    event_key: 'speed_learner',
    message: 'âš¡ Speed learner: Completed course faster than 90% of students!',
    url: '/achievements'
  },
  HELPful_LEARNER: {
    event_key: 'helpful_learner',
    message: 'ðŸ¤ Helpful learner: Your answers helped {count} peers!',
    url: '/community/contributions'
  },
  EARLY_ADOPTER: {
    event_key: 'early_adopter',
    message: 'ðŸš€ Early adopter: You were among first to try new feature!',
    url: '/achievements'
  },
  KNOWLEDGE_SHARER: {
    event_key: 'knowledge_sharer',
    message: 'ðŸ“¢ Knowledge sharer: You shared {count} learning insights!',
    url: '/community/contributions'
  },
  WEEKLY_CHALLENGE_WIN: {
    event_key: 'weekly_challenge_win',
    message: 'ðŸŽ¯ You won this week\'s learning challenge!',
    url: '/challenges'
  },
  MILESTONE_10_COURSES: {
    event_key: 'milestone_10_courses',
    message: 'ðŸ”Ÿ Milestone: 10 courses completed! Learning machine!',
    url: '/achievements'
  },
  MILESTONE_100_HOURS: {
    event_key: 'milestone_100_hours',
    message: 'â±ï¸ 100 hours of learning completed! Incredible dedication.',
    url: '/achievements'
  },
  PERFECT_ATTENDANCE: {
    event_key: 'perfect_attendance',
    message: 'ðŸ“š Perfect attendance: No missed learning days this month!',
    url: '/achievements'
  },
  CROSS_DISCIPLINE: {
    event_key: 'cross_discipline',
    message: 'ðŸŒ Cross-discipline explorer: Completed courses in {count} categories!',
    url: '/achievements'
  },
  QUIZ_MASTER: {
    event_key: 'quiz_master',
    message: 'ðŸ§  Quiz master: Perfect scores on {count} consecutive quizzes!',
    url: '/achievements'
  },
  NIGHT_OWL: {
    event_key: 'night_owl',
    message: 'ðŸ¦‰ Night owl: Most productive during late hours!',
    url: '/achievements'
  },
  EARLY_BIRD: {
    event_key: 'early_bird',
    message: 'ðŸ¦ Early bird: Consistent morning learning sessions!',
    url: '/achievements'
  },
  WEEKEND_WARRIOR: {
    event_key: 'weekend_warrior',
    message: 'ðŸ’ª Weekend warrior: Maximum learning on weekends!',
    url: '/achievements'
  },
  GLOBAL_RANK: {
    event_key: 'global_rank',
    message: 'ðŸŒŽ Global rank #{rank} - Among top learners worldwide!',
    url: '/leaderboard'
  },

  // ðŸ’° Payments & Subscriptions (15)
  PAYMENT_SUCCESS: {
    event_key: 'payment_success',
    message: 'âœ… Payment successful! Thank you for your purchase.',
    url: '/billing/receipts/{payment_id}'
  },
  SUBSCRIPTION_RENEWAL: {
    event_key: 'subscription_renewal',
    message: 'ðŸ”„ Subscription renewed successfully.',
    url: '/billing/subscriptions'
  },
  SUBSCRIPTION_UPGRADE: {
    event_key: 'subscription_upgrade',
    message: 'â¬†ï¸ Subscription upgraded to {plan_name}! New features unlocked.',
    url: '/billing/subscriptions'
  },
  TRIAL_ENDS_SOON: {
    event_key: 'trial_ends_soon',
    message: 'â° Your free trial ends in {days_left} days.',
    url: '/billing/upgrade'
  },
  TRIAL_EXPIRED: {
    event_key: 'trial_expired',
    message: 'ðŸ”’ Trial period ended. Upgrade to continue learning.',
    url: '/billing/upgrade'
  },
  PAYMENT_FAILED: {
    event_key: 'payment_failed',
    message: 'âŒ Payment failed. Please update your payment method.',
    url: '/billing/payment-methods'
  },
  REFUND_PROCESSED: {
    event_key: 'refund_processed',
    message: 'ðŸ’¸ Refund processed for {amount}.',
    url: '/billing/receipts'
  },
  DISCOUNT_APPLIED: {
    event_key: 'discount_applied',
    message: 'ðŸŽ« Discount applied! You saved {discount_amount}.',
    url: '/billing/receipts/{payment_id}'
  },
  LOYALTY_DISCOUNT: {
    event_key: 'loyalty_discount',
    message: 'ðŸŽ Loyalty discount: {discount_percent}% off for being a valued member!',
    url: '/billing'
  },
  BULK_PURCHASE: {
    event_key: 'bulk_purchase',
    message: 'ðŸ“¦ Bulk purchase: {course_count} courses added to your library!',
    url: '/library'
  },
  GIFT_SENT: {
    event_key: 'gift_sent',
    message: 'ðŸŽ Gift sent to {recipient_name}! Theyâ€™ll love learning with us.',
    url: '/gifts/sent'
  },
  GIFT_RECEIVED: {
    event_key: 'gift_received',
    message: 'ðŸŽ‰ You received a gift from {sender_name}! Start learning now.',
    url: '/gifts/received'
  },
  AFFILIATE_EARNED: {
    event_key: 'affiliate_earned',
    message: 'ðŸ’° Affiliate earnings: {amount} earned from referrals!',
    url: '/affiliate'
  },
  SCHOLARSHIP_APPLIED: {
    event_key: 'scholarship_applied',
    message: 'ðŸ“ Scholarship application received! Decision in 3-5 days.',
    url: '/scholarships'
  },
  SCHOLARSHIP_APPROVED: {
    event_key: 'scholarship_approved',
    message: 'ðŸŽ“ Scholarship approved! {coverage}% of your courses covered.',
    url: '/scholarships'
  },

  // ðŸ”” System & Platform (15)
  SYSTEM_MAINTENANCE: {
    event_key: 'system_maintenance',
    message: 'ðŸ”§ Scheduled maintenance in {hours} hours. Platform may be unavailable.',
    url: '/status'
  },
  NEW_FEATURE: {
    event_key: 'new_feature',
    message: 'ðŸ†• New feature: {feature_name}! Check it out now.',
    url: '/whats-new'
  },
  APP_UPDATE: {
    event_key: 'app_update',
    message: 'ðŸ“± App update available with new features and improvements.',
    url: '/mobile-app'
  },
  SECURITY_ALERT: {
    event_key: 'security_alert',
    message: 'ðŸ”’ Security alert: Unusual login detected from {location}',
    url: '/security'
  },
  PASSWORD_CHANGED: {
    event_key: 'password_changed',
    message: 'ðŸ”‘ Password changed successfully.',
    url: '/security'
  },
  EMAIL_VERIFIED: {
    event_key: 'email_verified',
    message: 'âœ… Email verified successfully!',
    url: '/profile'
  },
  TWO_FACTOR_ENABLED: {
    event_key: 'two_factor_enabled',
    message: 'ðŸ›¡ï¸ Two-factor authentication enabled for extra security.',
    url: '/security'
  },
  DATA_EXPORT_READY: {
    event_key: 'data_export_ready',
    message: 'ðŸ“¤ Your data export is ready for download.',
    url: '/settings/privacy'
  },
  PRIVACY_POLICY_UPDATE: {
    event_key: 'privacy_policy_update',
    message: 'ðŸ“„ Privacy policy updated. Please review changes.',
    url: '/privacy-policy'
  },
  COMMUNITY_GUIDELINES: {
    event_key: 'community_guidelines',
    message: 'ðŸ“– Updated community guidelines. Help keep our platform positive.',
    url: '/community/guidelines'
  },
  FEEDBACK_REQUEST: {
    event_key: 'feedback_request',
    message: 'ðŸ’¬ How was your learning experience? Share your feedback.',
    url: '/feedback'
  },
  SURVEY_INVITE: {
    event_key: 'survey_invite',
    message: 'ðŸ“‹ Quick survey: Help us improve GramorX (2 min)',
    url: '/surveys/{survey_id}'
  },
  BUG_REPORT_STATUS: {
    event_key: 'bug_report_status',
    message: 'ðŸ› Your bug report has been {status}. Thank you!',
    url: '/support/tickets/{ticket_id}'
  },
  FEATURE_REQUEST_UPDATE: {
    event_key: 'feature_request_update',
    message: 'ðŸ’¡ Your feature request "{feature_name}" is under review!',
    url: '/feature-requests'
  },
  SUPPORT_TICKET_UPDATE: {
    event_key: 'support_ticket_update',
    message: 'ðŸ“ž Update on your support ticket: {update_message}',
    url: '/support/tickets/{ticket_id}'
  },

  // ðŸ‘¥ Social & Community (15)
  FOLLOWED: {
    event_key: 'followed',
    message: 'ðŸ‘¤ {follower_name} started following you!',
    url: '/profile/{follower_id}'
  },
  PROFILE_VIEW: {
    event_key: 'profile_view',
    message: 'ðŸ‘€ {viewer_name} viewed your profile.',
    url: '/profile/views'
  },
  POST_LIKED: {
    event_key: 'post_liked',
    message: 'â¤ï¸ {user_name} liked your post "{post_title}"',
    url: '/community/posts/{post_id}'
  },
  COMMENT_REPLY: {
    event_key: 'comment_reply',
    message: 'ðŸ’¬ {user_name} replied to your comment',
    url: '/community/posts/{post_id}#comment-{comment_id}'
  },
  MENTIONED: {
    event_key: 'mentioned',
    message: 'ðŸ“ {user_name} mentioned you in a post',
    url: '/community/posts/{post_id}'
  },
  STUDY_BUDDY_REQUEST: {
    event_key: 'study_buddy_request',
    message: 'ðŸ¤ Study buddy request from {user_name}',
    url: '/study-buddies/requests'
  },
  STUDY_BUDDY_ACCEPTED: {
    event_key: 'study_buddy_accepted',
    message: 'âœ… {user_name} accepted your study buddy request!',
    url: '/study-buddies/{buddy_id}'
  },
  GROUP_INVITE: {
    event_key: 'group_invite',
    message: 'ðŸ‘¥ Invitation to join "{group_name}" study group',
    url: '/groups/invitations'
  },
  GROUP_EVENT: {
    event_key: 'group_event',
    message: 'ðŸ“… Upcoming group event: "{event_name}"',
    url: '/groups/{group_id}/events/{event_id}'
  },
  COMMUNITY_CHALLENGE: {
    event_key: 'community_challenge',
    message: 'ðŸ… New community challenge: "{challenge_name}"',
    url: '/community/challenges/{challenge_id}'
  },
  BADGE_EARNED: {
    event_key: 'badge_earned',
    message: 'ðŸŽ–ï¸ Community badge earned: "{badge_name}"',
    url: '/profile/badges'
  },
  CONTRIBUTION_RECOGNIZED: {
    event_key: 'contribution_recognized',
    message: 'ðŸŒŸ Your community contribution was recognized by moderators!',
    url: '/community/contributions'
  },
  PEER_REVIEW_REQUEST: {
    event_key: 'peer_review_request',
    message: 'ðŸ” Peer review requested for your project submission',
    url: '/projects/{project_id}/reviews'
  },
  PEER_REVIEW_COMPLETE: {
    event_key: 'peer_review_complete',
    message: 'âœ… Peer review completed for your project',
    url: '/projects/{project_id}/results'
  },
  COMMUNITY_RANK_UP: {
    event_key: 'community_rank_up',
    message: 'â­ Community rank upgraded to {new_rank}!',
    url: '/community/rank'
  }
};

export const getNotificationTemplate = (key: string, variables?: Record<string, any>): NotificationTemplate => {
  const template = NOTIFICATION_TEMPLATES[key];
  if (!template) {
    return {
      event_key: 'generic',
      message: 'You have a new notification',
      url: '/notifications'
    };
  }

  // Replace variables in message and URL
  let message = template.message;
  let url = template.url;

  if (variables) {
    Object.entries(variables).forEach(([key, value]) => {
      const placeholder = `{${key}}`;
      message = message.replace(new RegExp(placeholder, 'g'), String(value));
      if (url) {
        url = url.replace(new RegExp(placeholder, 'g'), String(value));
      }
    });
  }

  return {
    ...template,
    message,
    url
  };
};




============================================================
FILE #78
PATH: components/NotificationsDropdown.tsx
============================================================
import * as React from 'react';
import Link from 'next/link';
import { Bell, Check, ExternalLink } from 'lucide-react';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/design-system/DropdownMenu';
import { Button } from '@/components/design-system/Button';
import { useNotifications } from '@/hooks/useNotifications';
import { formatTimestamp } from '@/lib/utils';

export const NotificationsDropdown: React.FC = () => {
  const { notifications, unreadCount, markAsRead, markAllAsRead, isLoading } = useNotifications();

  const handleNotificationClick = (notification: any) => {
    if (!notification.read) {
      markAsRead(notification.id);
    }
  };

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size="sm" className="relative p-2">
          <Bell className="h-5 w-5" />
          {unreadCount > 0 && (
            <span className="absolute -top-1 -right-1 flex h-5 w-5 items-center justify-center rounded-full bg-red-500 text-xs font-medium text-white">
              {unreadCount > 9 ? '9+' : unreadCount}
            </span>
          )}
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-80">
        <DropdownMenuLabel className="flex items-center justify-between">
          <span>Notifications</span>
          {unreadCount > 0 && (
            <Button
              variant="ghost"
              size="sm"
              onClick={markAllAsRead}
              className="text-xs"
            >
              Mark all read
            </Button>
          )}
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        
        <div className="max-h-96 overflow-y-auto">
          {isLoading ? (
            <div className="p-4 text-center text-sm text-muted-foreground">
              Loading...
            </div>
          ) : notifications.length === 0 ? (
            <div className="p-4 text-center text-sm text-muted-foreground">
              No notifications
            </div>
          ) : (
            notifications.slice(0, 5).map((notification) => (
              <DropdownMenuItem
                key={notification.id}
                className="flex flex-col items-start p-3"
                asChild
              >
                {notification.url ? (
                  <Link
                    href={notification.url}
                    className="w-full"
                    onClick={() => handleNotificationClick(notification)}
                  >
                    <div className="flex w-full items-start justify-between gap-2">
                      <p className="text-sm font-medium flex-1">
                        {notification.message}
                      </p>
                      {!notification.read && (
                        <div className="flex items-center gap-1">
                          <span className="h-2 w-2 rounded-full bg-blue-500" />
                          <Check className="h-3 w-3" />
                        </div>
                      )}
                    </div>
                    <p className="text-xs text-muted-foreground mt-1">
                      {formatTimestamp(notification.createdAt)}
                    </p>
                  </Link>
                ) : (
                  <div 
                    className="w-full"
                    onClick={() => handleNotificationClick(notification)}
                  >
                    <div className="flex w-full items-start justify-between gap-2">
                      <p className="text-sm font-medium flex-1">
                        {notification.message}
                      </p>
                      {!notification.read && (
                        <Check className="h-3 w-3" />
                      )}
                    </div>
                    <p className="text-xs text-muted-foreground mt-1">
                      {formatTimestamp(notification.createdAt)}
                    </p>
                  </div>
                )}
              </DropdownMenuItem>
            ))
          )}
        </div>

        <DropdownMenuSeparator />
        <DropdownMenuItem asChild>
          <Link
            href="/notifications"
            className="flex items-center justify-center text-sm font-medium"
          >
            View all notifications
            <ExternalLink className="ml-1 h-3 w-3" />
          </Link>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
};




============================================================
FILE #79
PATH: lib/notificationService.ts
============================================================
import { createClient } from '@supabase/supabase-js';
import type { Database } from '@/types/supabase';
import type { CreateNotificationInput, NotificationNudge } from './schemas/notifications';
import { getNotificationTemplate, type NotificationTemplate } from './notificationTemplates';

export class NotificationService {
  constructor(private supabase: ReturnType<typeof createClient<Database>>) {}

  // ... existing methods ...

  async createNotificationFromTemplate(
    userId: string,
    templateKey: string,
    variables?: Record<string, any>
  ): Promise<NotificationNudge> {
    const template = getNotificationTemplate(templateKey, variables);
    
    return this.createNotification(userId, {
      message: template.message,
      url: template.url
    });
  }

  async bulkCreateNotifications(
    userId: string,
    notifications: Array<{
      templateKey: string;
      variables?: Record<string, any>;
      created_at?: Date;
    }>
  ): Promise<NotificationNudge[]> {
    const results: NotificationNudge[] = [];
    
    for (const notification of notifications) {
      try {
        const result = await this.createNotificationFromTemplate(
          userId,
          notification.templateKey,
          notification.variables
        );
        results.push(result);
        
        // Add delay to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 100));
      } catch (error) {
        console.error(`Failed to create notification ${notification.templateKey}:`, error);
      }
    }
    
    return results;
  }

  async seedUserNotifications(userId: string): Promise<void> {
    const notifications = [
      // Onboarding sequence
      { templateKey: 'WELCOME' },
      { templateKey: 'PROFILE_COMPLETE' },
      { templateKey: 'FIRST_LOGIN' },
      { templateKey: 'LEARNING_PATH' },
      
      // Course enrollments
      { 
        templateKey: 'COURSE_ENROLLED', 
        variables: { course_name: 'Introduction to Programming', course_id: 'prog-101' } 
      },
      { 
        templateKey: 'COURSE_PROGRESS_25', 
        variables: { course_name: 'Introduction to Programming', course_id: 'prog-101' } 
      },
      { 
        templateKey: 'COURSE_PROGRESS_50', 
        variables: { course_name: 'Introduction to Programming', course_id: 'prog-101' } 
      },
      { 
        templateKey: 'COURSE_PROGRESS_75', 
        variables: { course_name: 'Introduction to Programming', course_id: 'prog-101' } 
      },
      { 
        templateKey: 'COURSE_COMPLETED', 
        variables: { course_name: 'Introduction to Programming', course_id: 'prog-101' } 
      },
      
      // Achievements
      { templateKey: 'FIRST_COURSE_COMPLETE' },
      { templateKey: 'LEARNING_STREAK_3' },
      { templateKey: 'LEARNING_STREAK_7' },
      { 
        templateKey: 'ACHIEVEMENT_UNLOCKED', 
        variables: { achievement_name: 'Fast Learner' } 
      },
      { 
        templateKey: 'PERFECT_QUIZ', 
        variables: { quiz_name: 'Python Basics Quiz' } 
      },
      
      // Additional courses
      { 
        templateKey: 'COURSE_ENROLLED', 
        variables: { course_name: 'Web Development Fundamentals', course_id: 'web-101' } 
      },
      { 
        templateKey: 'COURSE_ENROLLED', 
        variables: { course_name: 'Data Science Essentials', course_id: 'ds-101' } 
      },
      
      // Progress updates
      { 
        templateKey: 'WEEKLY_PROGRESS', 
        variables: { completed_lessons: 12, study_time: 8 } 
      },
      { 
        templateKey: 'MONTHLY_REVIEW', 
        variables: { courses_completed: 3 } 
      },
      
      // Community
      { 
        templateKey: 'FOLLOWED', 
        variables: { follower_name: 'Alex Johnson' } 
      },
      { 
        templateKey: 'POST_LIKED', 
        variables: { user_name: 'Maria Garcia', post_title: 'My learning journey so far' } 
      },
      { 
        templateKey: 'STUDY_GROUP_INVITE', 
        variables: { group_name: 'Python Learners Club' } 
      }
    ];

    await this.bulkCreateNotifications(userId, notifications);
  }
}




============================================================
FILE #80
PATH: lib/schemas/notifications.ts
============================================================
import { z } from 'zod';

export const MarkNotificationReadParamsSchema = z.object({
  id: z.string().uuid(),
});

export const CreateNotificationSchema = z.object({
  message: z.string().min(1).max(500),
  url: z.string().url().optional().or(z.literal('')),
});

export const NotificationNudgeSchema = z.object({
  id: z.string().uuid().or(z.literal('welcome')),
  message: z.string(),
  url: z.string().url().nullable(),
  read: z.boolean(),
  createdAt: z.string().datetime(),
});

export const NotificationListQuerySchema = z.object({
  cursor: z.string().datetime().optional(),
  limit: z.number().int().min(1).max(100).default(20),
});

export const NotificationListResponseSchema = z.object({
  items: z.array(NotificationNudgeSchema),
  nextCursor: z.string().datetime().nullable(),
  unreadCount: z.number().int().min(0),
});

export type MarkNotificationReadParams = z.infer<typeof MarkNotificationReadParamsSchema>;
export type CreateNotificationInput = z.infer<typeof CreateNotificationSchema>;
export type NotificationNudge = z.infer<typeof NotificationNudgeSchema>;
export type NotificationListQuery = z.infer<typeof NotificationListQuerySchema>;
export type NotificationListResponse = z.infer<typeof NotificationListResponseSchema>;




============================================================
FILE #81
PATH: lib/push/client.ts
============================================================
import { env, isBrowser } from '@/lib/env';
import {
  DEFAULT_TOPICS,
  PushTopic,
  diffTopics,
  getStoredTopics,
  persistTopics,
  sanitizeTopics,
} from '@/lib/push/topics';

export type Platform = 'web' | 'ios' | 'android';

export type DeviceInfo = {
  id?: string;
  model?: string;
  os?: string;
  osVersion?: string;
  appVersion?: string;
  manufacturer?: string;
};

export type RegisterPushOptions = {
  topics?: PushTopic[];
  metadata?: Record<string, unknown> | null;
  platform?: Platform;
  device?: DeviceInfo | null;
};

export type RegisterResponse =
  | {
      ok: true;
      permission: NotificationPermission;
      topics: PushTopic[];
      subscription: SerializedSubscription;
      diff: { added: PushTopic[]; removed: PushTopic[] };
    }
  | {
      ok: false;
      reason: 'unsupported' | 'permission_denied';
      permission: NotificationPermission;
    };

export type SerializedSubscription = {
  endpoint: string;
  expirationTime: number | null;
  keys: {
    p256dh: string | null;
    auth: string | null;
  };
};

export function isPushSupported(): boolean {
  if (!isBrowser) return false;
  return 'serviceWorker' in navigator && 'PushManager' in window;
}

export async function ensurePushPermission(): Promise<NotificationPermission> {
  if (!isBrowser || !('Notification' in window)) return 'default';
  const current = Notification.permission;
  if (current === 'granted' || current === 'denied') return current;
  try {
    return await Notification.requestPermission();
  } catch {
    return Notification.permission;
  }
}

export async function registerPush(options: RegisterPushOptions = {}): Promise<RegisterResponse> {
  if (!isPushSupported()) {
    return { ok: false, reason: 'unsupported', permission: 'default' };
  }

  const permission = await ensurePushPermission();
  if (permission !== 'granted') {
    return { ok: false, reason: 'permission_denied', permission };
  }

  const registration = await navigator.serviceWorker.ready;
  let subscription = await registration.pushManager.getSubscription();

  if (!subscription) {
    const vapidKey = env.NEXT_PUBLIC_PUSH_PUBLIC_KEY;
    if (!vapidKey) {
      throw new Error('Missing NEXT_PUBLIC_PUSH_PUBLIC_KEY for web push registration.');
    }

    subscription = await registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: urlBase64ToUint8Array(vapidKey),
    });
  }

  const serialized = serializeSubscription(subscription);
  const storedTopics = getStoredTopics();
  const targetTopics = sanitizeTopics(options.topics ?? storedTopics ?? DEFAULT_TOPICS);
  const topicDiff = diffTopics(storedTopics, targetTopics);

  await postRegistration(serialized, targetTopics, options);
  persistTopics(targetTopics);

  return { ok: true, permission, topics: targetTopics, subscription: serialized, diff: topicDiff };
}

export async function updatePushTopics(topics: PushTopic[]): Promise<RegisterResponse> {
  const targetTopics = sanitizeTopics(topics);
  if (!isPushSupported()) {
    return { ok: false, reason: 'unsupported', permission: 'default' };
  }

  const registration = await navigator.serviceWorker.ready;
  const subscription = await registration.pushManager.getSubscription();
  if (!subscription) {
    return registerPush({ topics: targetTopics });
  }

  const serialized = serializeSubscription(subscription);
  const storedTopics = getStoredTopics();
  const topicDiff = diffTopics(storedTopics, targetTopics);

  await postRegistration(serialized, targetTopics, {});
  persistTopics(targetTopics);

  return {
    ok: true,
    permission: Notification.permission,
    topics: targetTopics,
    subscription: serialized,
    diff: topicDiff,
  };
}

export async function unregisterPush(): Promise<boolean> {
  if (!isPushSupported()) return false;
  const registration = await navigator.serviceWorker.ready;
  const subscription = await registration.pushManager.getSubscription();
  if (!subscription) return false;
  const result = await subscription.unsubscribe();
  if (result) persistTopics(DEFAULT_TOPICS);
  return result;
}

async function postRegistration(
  subscription: SerializedSubscription,
  topics: PushTopic[],
  options: RegisterPushOptions,
) {
  const response = await fetch('/api/push/register', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      token: subscription.endpoint,
      subscription,
      topics,
      platform: options.platform ?? 'web',
      metadata: options.metadata ?? null,
      device: options.device ?? null,
    }),
  });

  if (!response.ok) {
    const payload = await safeJson(response);
    throw new Error(payload?.error ?? `Failed to register push token (${response.status})`);
  }
}

function serializeSubscription(sub: PushSubscription): SerializedSubscription {
  return {
    endpoint: sub.endpoint,
    expirationTime: sub.expirationTime,
    keys: {
      p256dh: encodeKey(sub.getKey('p256dh')),
      auth: encodeKey(sub.getKey('auth')),
    },
  };
}

function encodeKey(key: ArrayBuffer | null): string | null {
  if (!key) return null;
  const bytes = new Uint8Array(key);
  let binary = '';
  for (const byte of bytes) {
    binary += String.fromCharCode(byte);
  }
  return btoa(binary);
}

function urlBase64ToUint8Array(base64String: string): Uint8Array {
  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
  const rawData = atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}

async function safeJson(res: Response): Promise<any> {
  try {
    return await res.json();
  } catch {
    return null;
  }
}





============================================================
FILE #82
PATH: components/waitlist/WaitlistForm.tsx
============================================================
import * as React from 'react';
import { Button } from '@/components/design-system/Button';

const COUNTRIES = [
  { code: 'US', name: 'United States' },
  { code: 'CA', name: 'Canada' },
  { code: 'GB', name: 'United Kingdom' },
  { code: 'AU', name: 'Australia' },
  { code: 'IN', name: 'India' },
  { code: 'PK', name: 'Pakistan' },
  { code: 'AE', name: 'United Arab Emirates' },
];

export function WaitlistForm() {
  const [state, setState] = React.useState({
    name: '', email: '', phone: '', country: 'US', targetBand: '', testMonth: '',
  });
  const [msg, setMsg] = React.useState<string | null>(null);
  const [busy, setBusy] = React.useState(false);

  const submit = async (e: React.FormEvent) => {
    e.preventDefault();
    setBusy(true);
    setMsg(null);
    const res = await fetch('/api/waitlist/submit', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...state,
        targetBand: state.targetBand ? Number(state.targetBand) : undefined,
      }),
    });
    setBusy(false);
    setMsg(res.ok ? 'Joined! We will notify you.' : (await res.json()).error ?? 'Failed');
  };

  return (
    <form onSubmit={submit} className="space-y-3">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
        <input className="rounded-lg border border-border bg-background px-3 py-2" placeholder="Full name"
               value={state.name} onChange={e=>setState(s=>({ ...s, name: e.target.value }))} required />
        <input className="rounded-lg border border-border bg-background px-3 py-2" placeholder="Email"
               type="email" value={state.email} onChange={e=>setState(s=>({ ...s, email: e.target.value }))} required />
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
        <select className="rounded-lg border border-border bg-background px-3 py-2"
                value={state.country} onChange={e=>setState(s=>({ ...s, country: e.target.value }))} required>
          {COUNTRIES.map(c => <option key={c.code} value={c.code}>{c.name}</option>)}
        </select>
        <input className="rounded-lg border border-border bg-background px-3 py-2" placeholder="Phone (international)"
               value={state.phone} onChange={e=>setState(s=>({ ...s, phone: e.target.value }))} required />
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
        <input className="rounded-lg border border-border bg-background px-3 py-2" placeholder="Target band (e.g., 7.5)"
               value={state.targetBand} onChange={e=>setState(s=>({ ...s, targetBand: e.target.value }))} />
        <input className="rounded-lg border border-border bg-background px-3 py-2" placeholder="Test month (YYYY-MM)"
               value={state.testMonth} onChange={e=>setState(s=>({ ...s, testMonth: e.target.value }))} />
      </div>

      <div className="flex items-center gap-3">
        <Button variant="primary" type="submit" disabled={busy}>Join Waitlist</Button>
        {msg && <span className="text-small text-muted-foreground">{msg}</span>}
      </div>
    </form>
  );
}





============================================================
FILE #83
PATH: pages/quick/index.tsx
============================================================
import type { GetServerSideProps } from 'next';
import Head from 'next/head';
import Link from 'next/link';

import { Container } from '@/components/design-system/Container';
import { Card } from '@/components/design-system/Card';
import { Button } from '@/components/design-system/Button';
import { env } from '@/lib/env';
import { flags } from '@/lib/flags';

type QuickPageProps = Record<string, never>;

const canonical = env.NEXT_PUBLIC_SITE_URL
  ? `${env.NEXT_PUBLIC_SITE_URL.replace(/\/$/, '')}/quick`
  : undefined;

export const getServerSideProps: GetServerSideProps<QuickPageProps> = async () => {
  if (!flags.enabled('quickTen')) {
    return {
      redirect: {
        destination: '/study-plan',
        permanent: false,
      },
    };
  }

  return { props: {} };
};

export default function QuickTenLanding() {
  return (
    <>
      <Head>
        <title>Quick 10 drills (private beta)</title>
        {canonical ? <link rel="canonical" href={canonical} /> : null}
        <meta name="robots" content="noindex, nofollow" />
        <meta
          name="description"
          content="Quick 10 gives you a focused micro-drill in under ten minutes. We&apos;re polishing the beta before opening it up."
        />
      </Head>

      <section className="bg-lightBg py-24 dark:bg-gradient-to-br dark:from-dark/80 dark:to-darker/90">
        <Container>
          <Card className="mx-auto max-w-3xl space-y-6 rounded-ds-2xl p-6 text-center">
            <span className="inline-flex items-center justify-center rounded-full bg-primary/10 px-4 py-1 text-small font-medium text-primary">
              Private beta
            </span>
            <h1 className="font-slab text-h2">Quick 10 is in final prep</h1>
            <p className="text-body text-mutedText">
              Quick 10 serves a personalised ten-minute micro-drill built from your weakest skills. Early testers are
              helping us tune the difficulty and instant feedback right now.
            </p>
            <p className="text-body text-mutedText">
              Keep momentum going with your study plan while we finish the experience. We&apos;ll notify you the moment it
              switches on for your account.
            </p>

            <div className="flex flex-col items-center justify-center gap-3 sm:flex-row">
              <Button asChild size="lg">
                <Link href="/study-plan">Open study plan</Link>
              </Button>
              <Button asChild variant="outline" size="lg">
                <Link href="/dashboard#tasks">Check today&apos;s tasks</Link>
              </Button>
            </div>
          </Card>
        </Container>
      </section>
    </>
  );
}






============================================================
FILE #84
PATH: components/mobile/PushOptInCard.tsx
============================================================
import React, { useCallback, useEffect, useMemo, useState } from 'react';

import { Card } from '@/components/design-system/Card';
import { Button } from '@/components/design-system/Button';
import { track } from '@/lib/analytics/track';
import { isBrowser } from '@/lib/env';

const NOTIFICATION_AVAILABLE = () => isBrowser && 'Notification' in window;

export type PushOptInCardProps = {
  onGranted?: () => void;
  onDismiss?: () => void;
};

export function PushOptInCard({ onGranted, onDismiss }: PushOptInCardProps) {
  const [status, setStatus] = useState<NotificationPermission>(() =>
    NOTIFICATION_AVAILABLE() ? Notification.permission : 'default',
  );
  const [requesting, setRequesting] = useState(false);

  const permissionLabel = useMemo(() => {
    switch (status) {
      case 'granted':
        return 'Push alerts enabled';
      case 'denied':
        return 'Push alerts blocked';
      default:
        return 'Push alerts disabled';
    }
  }, [status]);

  useEffect(() => {
    if (!NOTIFICATION_AVAILABLE()) return;
    track('mobile.push_opt_in.shown', { permission: Notification.permission });
  }, []);

  const handleEnable = useCallback(async () => {
    if (!NOTIFICATION_AVAILABLE()) {
      track('mobile.push_opt_in.permission', { permission: 'unsupported' });
      onGranted?.();
      return;
    }

    setRequesting(true);
    try {
      track('mobile.push_opt_in.request', { permission: Notification.permission });
      const permission = await Notification.requestPermission();
      setStatus(permission);
      track('mobile.push_opt_in.permission', { permission });
      if (permission === 'granted') {
        onGranted?.();
      }
    } catch (error) {
      track('mobile.push_opt_in.permission', { permission: 'error', error: (error as Error).message });
    } finally {
      setRequesting(false);
    }
  }, [onGranted]);

  const handleDismiss = useCallback(() => {
    track('mobile.push_opt_in.dismissed', { permission: status });
    onDismiss?.();
  }, [onDismiss, status]);

  if (!NOTIFICATION_AVAILABLE()) {
    return null;
  }

  if (status === 'granted') {
    return (
      <Card padding="lg" className="border-success/40 bg-success/10">
        <div className="space-y-2">
          <p className="text-xs font-semibold uppercase tracking-wide text-success">Push ready</p>
          <h3 className="text-base font-semibold text-foreground">You&apos;ll receive grading alerts</h3>
          <p className="text-sm text-muted-foreground">
            Thanks! We&apos;ll let you know instantly when writing scores or AI feedback are available.
          </p>
        </div>
      </Card>
    );
  }

  return (
    <Card padding="lg" className="border-border/70">
      <div className="flex flex-col gap-4">
        <div>
          <p className="text-xs font-semibold uppercase tracking-wide text-muted-foreground">Stay notified</p>
          <h3 className="text-lg font-semibold text-foreground">Enable push alerts</h3>
          <p className="mt-1 text-sm text-muted-foreground">
            We&apos;ll remind you when it&apos;s time to submit, and send writing score updates instantly.
          </p>
        </div>
        <div className="flex flex-col gap-2 sm:flex-row sm:items-center">
          <Button size="lg" variant="primary" onClick={handleEnable} loading={requesting}>
            Turn on alerts
          </Button>
          <Button size="sm" variant="ghost" onClick={handleDismiss}>
            Maybe later
          </Button>
        </div>
        <p className="text-xs text-muted-foreground" aria-live="polite">
          Status: {permissionLabel}
        </p>
      </div>
    </Card>
  );
}

export default PushOptInCard;





============================================================
FILE #85
PATH: components/NotificationsBell.tsx
============================================================
import * as React from 'react';
import Link from 'next/link';
import { Bell } from 'lucide-react';
import { Button } from '@/components/design-system/Button';
import { useNotifications } from '@/hooks/useNotifications';

interface NotificationsBellProps {
  className?: string;
}

export const NotificationsBell: React.FC<NotificationsBellProps> = ({ className }) => {
  const { unreadCount, markAllAsRead } = useNotifications();

  return (
    <div className={`relative ${className}`}>
      <Button
        as={Link}
        href="/notifications"
        variant="ghost"
        size="sm"
        className="relative p-2"
        onClick={markAllAsRead}
      >
        <Bell className="h-5 w-5" />
        {unreadCount > 0 && (
          <span className="absolute -top-1 -right-1 flex h-5 w-5 items-center justify-center rounded-full bg-red-500 text-xs font-medium text-white">
            {unreadCount > 9 ? '9+' : unreadCount}
          </span>
        )}
      </Button>
    </div>
  );
};




============================================================
FILE #86
PATH: pages/api/classes/cancel.ts
============================================================
import type { NextApiRequest, NextApiResponse } from 'next';
import { z } from 'zod';
import { supabaseServer } from '@/lib/supabaseServer';
import { withPlan } from '@/lib/apiGuard';

const BodySchema = z.object({
  classId: z.string().uuid(),
  reason: z.string().max(500).optional(),
});

type CancelClassResponse =
  | { ok: true; classId: string; status: 'canceled' }
  | { ok: false; error: string; code?: 'UNAUTHORIZED'|'FORBIDDEN'|'NOT_FOUND'|'DB_ERROR'|'BAD_REQUEST' };

async function handler(req: NextApiRequest, res: NextApiResponse<CancelClassResponse>) {
  if (req.method !== 'POST') return res.status(405).json({ ok: false, error: 'Method not allowed' });

  const supabase = supabaseServer(req);

  const { data: auth } = await supabase.auth.getUser();
  const user = auth?.user;
  if (!user) return res.status(401).json({ ok: false, error: 'Unauthorized', code: 'UNAUTHORIZED' });

  const parsed = BodySchema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json({ ok: false, error: parsed.error.message, code: 'BAD_REQUEST' });
  const { classId, reason } = parsed.data;

  // Load class
  const { data: klass, error: kErr } = await supabase
    .from('classes')
    .select('id, teacher_id, status')
    .eq('id', classId)
    .maybeSingle();

  if (kErr) return res.status(500).json({ ok: false, error: kErr.message, code: 'DB_ERROR' });
  if (!klass) return res.status(404).json({ ok: false, error: 'Class not found', code: 'NOT_FOUND' });

  // Authorize teacher
  const { data: coach } = await supabase.from('coaches').select('id').eq('user_id', user.id).maybeSingle();
  if (!coach || coach.id !== klass.teacher_id) {
    return res.status(403).json({ ok: false, error: 'Forbidden', code: 'FORBIDDEN' });
  }

  // Update status
  const { error: uErr } = await supabase
    .from('classes')
    .update({ status: 'canceled', cancel_reason: reason ?? null })
    .eq('id', classId);

  if (uErr) return res.status(500).json({ ok: false, error: uErr.message, code: 'DB_ERROR' });

  // Notify members (best-effort)
  await supabase.from('class_notifications').insert({ class_id: classId, type: 'class_canceled', payload_json: { reason } }).catch(() => {});

  return res.status(200).json({ ok: true, classId, status: 'canceled' });
}

export default withPlan('master', handler);





============================================================
FILE #87
PATH: components/layouts/ProfileLayout.tsx
============================================================
// components/layouts/ProfileLayout.tsx
import { ReactNode } from 'react';
import Link from 'next/link';
import { useRouter } from 'next/router';
import { Button } from '@/components/design-system/Button';

interface ProfileLayoutProps {
  children: ReactNode;
  userRole?: string;
}

function NavItem({
  href,
  label,
  active,
}: {
  href: string;
  label: string;
  active: boolean;
}) {
  return (
    <Button
      asChild
      variant={active ? 'secondary' : 'ghost'}
      className="w-full justify-start"
      size="sm"
    >
      <Link href={href}>{label}</Link>
    </Button>
  );
}

export function ProfileLayout({ children }: ProfileLayoutProps) {
  const router = useRouter();
  const path = router.pathname;

  const isActive = (p: string) => path === p || path.startsWith(`${p}/`);

  return (
    <div className="flex min-h-screen bg-background">
      <aside className="w-64 border-r bg-card">
        <div className="p-4">
          <div className="px-2 pb-3 text-sm font-medium text-muted-foreground">
            Profile
          </div>
          <nav className="space-y-1">
            <NavItem href="/profile" label="Overview" active={isActive('/profile')} />
            <NavItem href="/profile/account" label="Account" active={isActive('/profile/account')} />
            <NavItem href="/profile/security" label="Security" active={isActive('/profile/security')} />
            <NavItem href="/profile/notifications" label="Notifications" active={isActive('/profile/notifications')} />
            <NavItem href="/profile/preferences" label="Preferences" active={isActive('/profile/preferences')} />
          </nav>
        </div>
      </aside>
      <main className="flex-1 p-6">{children}</main>
    </div>
  );
}

export default ProfileLayout;





============================================================
FILE #88
PATH: pages/api/safepay/create-intent.ts
============================================================
import type { NextApiRequest, NextApiResponse } from 'next';
import { z } from 'zod';
import { getServerClient } from '@/lib/supabaseServer';

// IMPORTANT: match the actual export. If you're unsure, guard it.
// If your lib really exports `getNotificationContact`, keep as-is.
// If it exports `getNotificationContactByUser` or default, update accordingly.
import * as Notify from '@/lib/notify'; // weâ€™ll resolve the function at runtime

// ---------- Types ----------
const Body = z.object({
  plan: z.enum(['starter', 'booster', 'master']),
  cycle: z.enum(['monthly', 'annual']),
  currency: z.string().default('PKR'), // enforce what you support; PKR by default
});

type Provider = 'safepay';

type PaymentIntentRow = {
  id?: string;
  user_id: string;
  provider: Provider;
  reference: string;
  plan: 'starter' | 'booster' | 'master';
  cycle: 'monthly' | 'annual';
  currency: string;            // 'PKR' | 'USD' | 'GBP' etc.
  amount_minor: number;        // cents/paisa
  status: 'pending' | 'succeeded' | 'failed';
  provider_session_id?: string | null;
  provider_receipt_url?: string | null;
  created_at?: string;
  paid_at?: string | null;
};

// ---------- Helpers ----------
const amountFor = (plan: PaymentIntentRow['plan'], cycle: PaymentIntentRow['cycle']): number => {
  // TODO: wire to your canonical pricing calc
  // For demo: booster monthly = Rs 19.00 (1900 paisa), adjust as needed
  if (cycle === 'monthly') {
    if (plan === 'starter') return 900;   // Rs 9.00
    if (plan === 'booster') return 1900;  // Rs 19.00
    if (plan === 'master')  return 3900;  // Rs 39.00
  } else {
    if (plan === 'starter') return 96000; // Rs 960.00 (12Ã—80)
    if (plan === 'booster') return 192000;
    if (plan === 'master')  return 420000;
  }
  return 1900;
};

const buildSafepayComponentsUrl = (opts: {
  reference: string;
  returnUrl: string;
  cancelUrl: string;
  env: 'sandbox' | 'production';
}) => {
  const base =
    opts.env === 'production'
      ? 'https://api.getsafepay.com/components'
      : 'https://sandbox.api.getsafepay.com/components';
  const q = new URLSearchParams({
    env: opts.env,
    reference: opts.reference,
    return_url: opts.returnUrl,
    cancel_url: opts.cancelUrl,
  });
  return `${base}?${q.toString()}`;
};

// best effort lookup; wonâ€™t crash if the export name differs
const getNotificationContact =
  // @ts-expect-error TODO: tighten typing once lib/notify export is finalized
  (Notify.getNotificationContact ||
   // @ts-expect-error
   Notify.getNotificationContactByUser ||
   // @ts-expect-error
   Notify.default ||
   null);

// ---------- Handler ----------
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' });

  const parse = Body.safeParse(req.body);
  if (!parse.success) {
    return res.status(400).json({ error: 'Invalid body', details: parse.error.flatten() });
  }

  const supabase = getServerClient(req, res);
  const { data: auth } = await supabase.auth.getUser();
  const user = auth?.user;
  if (!user) return res.status(401).json({ error: 'Unauthorized' });

  const { plan, cycle, currency } = parse.data;

  // 1) Create our own intent
  const reference = `GXR-${Date.now()}`;
  const amount_minor = amountFor(plan, cycle);
  const provider: Provider = 'safepay';

  const { error: insertErr, data: inserted } = await supabase
    .from('payment_intents')
    .insert({
      user_id: user.id,
      provider,
      reference,
      plan,
      cycle,
      currency: currency.toUpperCase(),
      amount_minor,
      status: 'pending',
    } satisfies PaymentIntentRow)
    .select('id')
    .single();

  if (insertErr) {
    return res.status(500).json({ error: 'DB insert failed', details: insertErr.message });
  }

  // 2) Build redirect URL (server-side truth of return/cancel)
  const origin =
    process.env.NEXT_PUBLIC_APP_URL ||
    (req.headers['x-forwarded-proto'] && req.headers.host
      ? `${req.headers['x-forwarded-proto']}://${req.headers.host}`
      : `https://${req.headers.host}`);

  const returnUrl = `${origin}/checkout/success?reference=${encodeURIComponent(reference)}`;
  const cancelUrl  = `${origin}/checkout/cancel?reference=${encodeURIComponent(reference)}`;

  const env = (process.env.SAFEPAY_ENV === 'production' ? 'production' : 'sandbox') as
    | 'sandbox'
    | 'production';

  // If youâ€™re using Safepay Components you can redirect directly to this URL.
  // If youâ€™re using their tokenization API first, call it here and replace with their checkout URL.
  const checkoutUrl = buildSafepayComponentsUrl({ reference, returnUrl, cancelUrl, env });

  // 3) Try to inform the user (non-blocking). DO NOT break the request on notification failure.
  (async () => {
    if (!getNotificationContact) return;
    try {
      const contact = await getNotificationContact(user.id);
      // @ts-expect-error implement your notify(event, contact, payload) in lib/notify
      await Notify.notify?.('payment_intent_created', contact, {
        provider,
        plan,
        cycle,
        currency,
        amount_minor,
        reference,
      });
    } catch (e) {
      // swallow â€” logging only
      console.warn('[payments] notify failed', e);
    }
  })();

  // 4) Respond to client
  return res.status(200).json({
    ok: true,
    provider,
    intentId: inserted?.id ?? null,
    reference,
    checkoutUrl,
  });
}





============================================================
FILE #89
PATH: components/audio/Player.tsx
============================================================
import React, {
  forwardRef,
  useEffect,
  useImperativeHandle,
  useMemo,
  useRef,
  useState,
} from 'react';

type Source = { src: string; type?: string };

export type AudioPlayerProps = {
  /** Primary audio source URL. */
  src: string;
  /** Optional additional `<source>` elements. */
  sources?: Source[];
  /** Override preload strategy. Defaults to `auto`, but falls back to `metadata` on slow connections. */
  preload?: 'none' | 'metadata' | 'auto';
  /** Allow callers to force metadata-only preloading. */
  preferMetadataOnly?: boolean;
  /** Cross-origin policy for the underlying audio element. Defaults to `anonymous`. */
  crossOrigin?: '' | 'anonymous' | 'use-credentials';
  /** Optional class name applied to the `<audio>` element. */
  className?: string;
  /** When true, renders a minimal player without visible controls. */
  hidden?: boolean;
  /** Optional aria label passed to the `<audio>` element. */
  'aria-label'?: string;
  /** Callback fired when the player decides on a preload strategy. */
  onPreloadStrategyChange?: (strategy: 'none' | 'metadata' | 'auto') => void;
  /** MIME type hint for the primary source. Defaults to audio/mpeg. */
  primaryType?: string;
} & React.AudioHTMLAttributes<HTMLAudioElement>;

type ImperativeApi = HTMLAudioElement | null;

function detectLowBandwidth(): boolean {
  if (typeof navigator === 'undefined') return false;
  const connection = (navigator as any).connection || (navigator as any).mozConnection || (navigator as any).webkitConnection;
  if (!connection) return false;
  const saveData = Boolean(connection.saveData);
  const type = String(connection.effectiveType || '').toLowerCase();
  // Consider 2g / slow-2g or explicit Save-Data preference as low-bandwidth.
  return saveData || type.includes('2g') || type.includes('slow');
}

/**
 * Lightweight audio player that auto-adjusts preload strategy for low-bandwidth networks
 * and exposes an imperative ref compatible with native `<audio>` methods.
 */
export const AudioPlayer = forwardRef<ImperativeApi, AudioPlayerProps>(function AudioPlayer(
  {
    src,
    sources,
    preload = 'auto',
    preferMetadataOnly = false,
    crossOrigin = 'anonymous',
    className,
    hidden,
    onPreloadStrategyChange,
    primaryType,
    ...rest
  },
  forwardedRef
) {
  const localRef = useRef<HTMLAudioElement | null>(null);
  const [strategy, setStrategy] = useState<'none' | 'metadata' | 'auto'>(() =>
    preferMetadataOnly || detectLowBandwidth() ? 'metadata' : preload
  );

  useImperativeHandle(forwardedRef, () => localRef.current, []);

  // Re-evaluate network conditions only once on mount.
  useEffect(() => {
    if (preferMetadataOnly) {
      setStrategy('metadata');
      return;
    }
    if (detectLowBandwidth()) {
      setStrategy('metadata');
    }
  }, [preferMetadataOnly]);

  // Notify listeners when strategy changes.
  useEffect(() => {
    onPreloadStrategyChange?.(strategy);
  }, [strategy, onPreloadStrategyChange]);

  // Apply attributes whenever relevant props change.
  useEffect(() => {
    const audio = localRef.current;
    if (!audio) return;
    audio.preload = strategy;
    audio.crossOrigin = crossOrigin;
    // Encourage byte-range requests by enabling controls (even if hidden) and metadata-only preload.
    if (strategy === 'metadata') {
      audio.setAttribute('preload', 'metadata');
    }
    if (hidden) {
      audio.style.display = 'none';
    }
  }, [crossOrigin, hidden, strategy]);

  const sourceNodes = useMemo(() => {
    if (!sources || !sources.length) return null;
    return sources.map((item) => (
      <source key={`${item.src}|${item.type || 'audio/mpeg'}`} src={item.src} type={item.type} />
    ));
  }, [sources]);

  const resolvedClassName = useMemo(() => {
    return [hidden ? 'sr-only' : '', className || ''].filter(Boolean).join(' ');
  }, [className, hidden]);

  return (
    <audio
      ref={localRef}
      className={resolvedClassName}
      preload={strategy}
      crossOrigin={crossOrigin}
      controls={!hidden}
      {...rest}
    >
      {/* Prefer explicit MIME types to help Safari pick the optimal codec. */}
      <source src={src} type={primaryType || 'audio/mpeg'} />
      {sourceNodes}
      {/* Fallback */}
      Your browser does not support the audio element.
    </audio>
  );
});

AudioPlayer.displayName = 'AudioPlayer';

export default AudioPlayer;





============================================================
FILE #90
PATH: pages/api/checkout/manual.ts
============================================================
import type { NextApiRequest, NextApiResponse } from 'next';
import { createServerClient } from '@supabase/ssr';
import { createPendingPayment } from '@/lib/billing/manual';
import { type PlanKey, type Cycle, PLANS } from '@/lib/pricing';

type Resp =
  | { ok: true; message: string }
  | { ok: false; error: string };

export default async function handler(req: NextApiRequest, res: NextApiResponse<Resp>) {
  if (req.method !== 'POST') return res.status(405).json({ ok: false, error: 'method_not_allowed' });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    { cookies: { get: (n: string) => req.cookies[n] } }
  );

  const { data: auth } = await supabase.auth.getUser();
  const user = auth?.user;
  if (!user) return res.status(401).json({ ok: false, error: 'unauthorized' });

  const { planKey, cycle, name, phone } = req.body as {
    planKey?: string; cycle?: string; name?: string; phone?: string;
  };

  if (!planKey || !cycle) return res.status(400).json({ ok: false, error: 'missing_fields' });
  if (!['starter','booster','master'].includes(planKey)) return res.status(400).json({ ok: false, error: 'invalid_plan' });
  if (!['monthly','annual'].includes(cycle)) return res.status(400).json({ ok: false, error: 'invalid_cycle' });

  try {
    // Basic authenticity checks (expand as needed)
    if (name && name.length > 100) return res.status(400).json({ ok: false, error: 'name_too_long' });
    if (phone && phone.length > 40) return res.status(400).json({ ok: false, error: 'phone_too_long' });

    await createPendingPayment({
      userId: user.id,
      email: user.email,
      plan: planKey as PlanKey,
      cycle: cycle as Cycle,
      name, phone,
      note: 'Manual checkout (payment gateway unavailable)',
    });

    return res.status(200).json({
      ok: true,
      message: 'Your subscription is activated. Your card was NOT charged; amount is marked as due. We will notify you before retrying payment.',
    });
  } catch (e: any) {
    return res.status(500).json({ ok: false, error: e?.message ?? 'internal_error' });
  }
}





